<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><script type="text/javascript" src="https://file.bkxsj.com/skin/book/js/sk.js"></script><meta name="robots" content="index,follow"><title>软件工程 实践者的研究方法 第8版 英文版[PDF|Epub|txt|kindle电子书版本网盘下载]-灵感之桥</title><meta name="Keywords" content="软件工程 实践者的研究方法 第8版 英文版"/><meta name="description" content="软件工程 实践者的研究方法 第8版 英文版pdf下载文件大小为160MB,PDF页数为969页"/><meta http-equiv="X-UA-Compatible" content="IE=9; IE=8; IE=7; IE=EDGE;chrome=1"><link type="image/x-icon" rel="shortcut icon" href="https://www.shukui.net/skin/book/images/favicon.ico"><link type="text/css" rel="stylesheet" href="https://www.shukui.net/skin/book/css/style.css"><style>#main .d-main {margin-left: 0;width: 620px;}.down-btn {animation: myShake 2.5s linear .15s infinite}@keyframes myShake {0%, 66% {transform: translateZ(0)}67%, 73.6%, 83.6%, 93.6%, to {animation-timing-function: cubic-bezier(.215, .61, .355, 1);transform: translateZ(0)}80.3%, 81.4% {animation-timing-function: cubic-bezier(.755, .05, .855, .06);transform: translate3d(0, -4px, 0)}90.3% {animation-timing-function: cubic-bezier(.755, .05, .855, .06);transform: translate3d(0, -2px, 0)}97% {transform: translate3d(0, -.5px, 0)}}.copylink-btn {margin-right: 20px;}.copymd5-btn {margin-bottom: 25px;margin-left: 10px;}</style></head><body><div id="header"><div class="inner"><div class="logo"><a href="/"><img width="103" height="25" alt="灵感之桥"src="https://www.shukui.net/skin/book/images/logo.png"></a></div><div class="search"><form action="/so/search.php" target="_blank"><input type="text" autocomplete="off" id="bdcsMain" name="q" placeholder="书名 / 作者 / 出版社 / ISBN"class="inp-txt"><select class="inp-select" id="datasource" onchange="selectDatasource(this)"><option value="so">主库</option><option value="s">从库</option></select><input type="submit" value="搜索" class="inp-btn"></form></div></div></div><div id="main"><div class="d-main"><div class="tit"><h3>图书介绍</h3></div><h1 class="book-name">软件工程 实践者的研究方法 第8版 英文版PDF|Epub|txt|kindle电子书版本网盘下载</h1><div class="d-info"><div class="b-thumb"><img src="https://www.shukui.net/cover/15/30953986.jpg" alt="软件工程 实践者的研究方法 第8版 英文版"></div><div class="b-info"><ul><li>（美）普莱斯曼，（美）马克西姆著 著</li><li>出版社： 北京：机械工业出版社</li><li>ISBN：9787111489504</li><li>出版时间：2015</li><li>标注页数：941页</li><li>文件大小：160MB</li><li>文件页数：969页</li><li>主题词：软件工程－英文</li></ul></div></div><div class="tit"><h3>PDF下载</h3></div><div></br><a style="color:red;" rel="external nofollow" href="https://www.kjlm.net/ebook/864557.html"target="_blank"><b>点此进入-本书在线PDF格式电子书下载【推荐-云解压-方便快捷】直接下载PDF格式图书。移动端-PC端通用</a></b></br><a class="down-btn" rel="external nofollow" href="https://down.trackerbk.com/bt/02/30953986.torrent"target="_blank">种子下载</a>[BT下载速度快]温馨提示：（请使用BT下载软件FDM进行下载）<a rel="nofollow" href="https://www.freedownloadmanager.org/zh/" target="_blank">软件下载地址页</a><a class="down-btn" rel="external nofollow" href="https://down.p2spdb.com/02/30953986.rar" target="_blank">直链下载</a>[便捷但速度慢]&nbsp;&nbsp;<a style="color:red;" rel="external nofollow" href="https://pdfyl.ertongbook.com/20/30953986.pdf" target="_blank"><b>[在线试读本书]</b></a>&nbsp;&nbsp;<b> <a style="color:red;" rel="external nofollow" href="https://web.jyjl.org/index/recovery.html" target="_blank">[在线获取解压码]</a></b><div class="copymd5-btn"><a href="javascript:copyToClip('e7ab2c9275cae84b297004c7fa858931')">点击复制MD5值：e7ab2c9275cae84b297004c7fa858931</a></div></div><div class="tit"><h3>下载说明</h3></div><div style="margin:20px 10px"><h2>软件工程 实践者的研究方法 第8版 英文版PDF格式电子书版下载</h2>下载的文件为RAR压缩包。需要使用解压软件进行解压得到PDF格式图书。<br><br><div class="copymd5-btn"><a href="javascript:copyToClip('magnet:?xt=urn:btih:RX6G6JQ2LJW7PBBEDNUSCQM7ICDMHIWK')">点击复制85GB完整离线版磁力链接到迅雷FDM等BT下载工具进行下载</a>&nbsp;&nbsp;<a rel="nofollow" target="_blank">详情点击-查看共享计划</a></div>建议使用BT下载工具Free Download Manager进行下载,简称FDM(免费,没有广告,支持多平台）。本站资源全部打包为BT种子。所以需要使用专业的BT下载软件进行下载。如BitComet qBittorrent uTorrent等BT下载工具。迅雷目前由于本站不是热门资源。不推荐使用！后期资源热门了。安装了迅雷也可以迅雷进行下载！<br><br><b>（文件页数 要大于 标注页数，上中下等多册电子书除外）</b><br><br><p style="color:red;"> <b>注意：本站所有压缩包均有解压码：</b> <a rel="nofollow" target="_blank"><b>点击下载压缩包解压工具</b></a></p></div><div class="tit"><h3>图书目录</h3></div><div id="book-contents"><p>CHAPTER 1 THE NATURE OF SOFTWARE1</p><p>1.1 The Nature of Software3</p><p>1.1.1 Defining Software4</p><p>1.1.2 Software Application Domains6</p><p>1.1.3 Legacy Software7</p><p>1.2 The Changing Nature of Software9</p><p>1.2.1 WebApps9</p><p>1.2.2 Mobile Applications9</p><p>1.2.3 Cloud Computing10</p><p>1.2.4 Product Line Software11</p><p>1.3 Summary11</p><p>PROBLEMS AND POINTS TO PONDER12</p><p>FURTHER READINGS AND INFORMATION SOURCES12</p><p>CHAPTER 2 SOFTWARE ENGINEERING14</p><p>2.1 Defining the Discipline15</p><p>2.2 The Software Process16</p><p>2.2.1 The Process Framework17</p><p>2.2.2 Umbrella Activities18</p><p>2.2.3 Process Adaptation18</p><p>2.3 Software Engineering Practice19</p><p>2.3.1 The Essence of Practice19</p><p>2.3.2 General Principles21</p><p>2.4 Software Development Myths23</p><p>2.5 How It All Starts26</p><p>2.6 Summary27</p><p>PROBLEMS AND POINTS TO PONDER27</p><p>FURTHER READINGS AND INFORMATION SOURCES27</p><p>PART ONE THE SOFTWAREP ROCESS29</p><p>CHAPTER 3 SOFTWARE PROCESS STRUCTURE30</p><p>3.1 A Generic Process Model31</p><p>3.2 Defining a Framework Activity32</p><p>3.3 Identifying a Task Set34</p><p>3.4 Process Patterns35</p><p>3.5 Process Assessment and Improvement37</p><p>3.6 Summary38</p><p>PROBLEMS AND POINTS TO PONDER38</p><p>FURTHER READINGS AND INFORMATION SOURCES39</p><p>CHAPTER 4 PROCESS MODELS40</p><p>4.1 Prescriptive Process Models41</p><p>4.1.1 The Waterfall Model41</p><p>4.1.2 Incremental Process Models43</p><p>4.1.3 Evolutionary Process Models45</p><p>4.1.4 Concurrent Models49</p><p>4.1.5 A Final Word on Evolutionary Processes51</p><p>4.2 Specialized Process Models52</p><p>4.2.1 Component-Based Development53</p><p>4.2.2 The Formal Methods Model53</p><p>4.2.3 Aspect-Oriented Software Development54</p><p>4.3 The Unified Process55</p><p>4.3.1 A Brief History56</p><p>4.3.2 Phases of the Unified Process56</p><p>4.4 Personal and Team Process Models59</p><p>4.4.1 Personal Software Process59</p><p>4.4.2 Team Software Process60</p><p>4.5 Process Technology61</p><p>4.6 Product and Process62</p><p>4.7 Summary64</p><p>PROBLEMS AND POINTS TO PONDER64</p><p>FURTHER READINGS AND INFORMATION SOURCES65</p><p>CHAPTER 5 AGILE DEVELOPMENT66</p><p>5.1 What Is Agility?68</p><p>5.2 Agility and the Cost of Change68</p><p>5.3 What Is an Agile Process?69</p><p>5.3.1 Agility Principles70</p><p>5.3.2 The Politics of Agile Development71</p><p>5.4 Extreme Programming72</p><p>5.4.1 The XP Process72</p><p>5.4.2 Industrial XP75</p><p>5.5 Other Agile Process Models77</p><p>5.5.1 Scrum78</p><p>5.5.2 Dynamic Systems Development Method79</p><p>5.5.3 Agile Modeling80</p><p>5.5.4 Agile Unified Process82</p><p>5.6 A Tool Set for the Agile Process83</p><p>5.7 Summary84</p><p>PROBLEMS AND POINTS TO PONDER85</p><p>FURTHER READINGS AND INFORMATION SOURCES85</p><p>CHAPTER 6 HUMAN ASPECTS OF SOFTWARE ENGINEERING87</p><p>6.1 Characteristics of a Software Engineer88</p><p>6.2 The Psychology of Software Engineering89</p><p>6.3 The Software Team90</p><p>6.4 Team Structures92</p><p>6.5 Agile Teams93</p><p>6.5.1 The Generic Agile Team93</p><p>6.5.2 The XP Team94</p><p>6.6 The Impact Of Social Media95</p><p>6.7 Software Engineering Using the Cloud97</p><p>6.8 Collaboration Tools98</p><p>6.9 Global Teams99</p><p>6.10 Summary100</p><p>PROBLEMS AND POINTS TO PONDER101</p><p>FURTHER READINGS AND INFORMATION SOURCES102</p><p>PART TWO MODELING103</p><p>CHAPTER 7 PRINCIPLES THAT GUIDE PRACTICE104</p><p>7.1 Software Engineering Knowledge105</p><p>7.2 Core Principles106</p><p>7.2.1 Principles That Guide Process106</p><p>7.2.2 Principles That Guide Practice107</p><p>7.3 Principles That Guide Each Framework Activity109</p><p>7.3.1 Communication Principles110</p><p>7.3.2 Planning Principles112</p><p>7.3.3 Modeling Principles114</p><p>7.3.4 Construction Principles121</p><p>7.3.5 Deployment Principles125</p><p>7.4 Work Practices126</p><p>7.5 Summary127</p><p>PROBLEMS AND POINTS TO PONDER128</p><p>FURTHER READINGS AND INFORMATION SOURCES129</p><p>CHAPTER 8 UNDERSTANDING REQUIREMENTS131</p><p>8.1 Requirements Engineering132</p><p>8.2 Establishing the Groundwork138</p><p>8.2.1 Identifying Stakeholders139</p><p>8.2.2 Recognizing Multiple Viewpoints139</p><p>8.2.3 Working toward Collaboration140</p><p>8.2.4 Asking the First Questions140</p><p>8.2.5 Nonfunctional Requirements141</p><p>8.2.6 Traceability142</p><p>8.3 Eliciting Requirements142</p><p>8.3.1 Collaborative Requirements Gathering143</p><p>8.3.2 Quality Function Deployment146</p><p>8.3.3 Usage Scenarios146</p><p>8.3.4 Elicitation Work Products147</p><p>8.3.5 Agile Requirements Elicitation148</p><p>8.3.6 Service-Oriented Methods148</p><p>8.4 Developing Use Cases149</p><p>8.5 Building the Analysis Model154</p><p>8.5.1 Elements of the Analysis Model154</p><p>8.5.2 Analysis Patterns157</p><p>8.5.3 Agile Requirements Engineering158</p><p>8.5.4 Requirements for Self-Adaptive Systems158</p><p>8.6 Negotiating Requirements159</p><p>8.7 Requirements Monitoring160</p><p>8.8 Validating Requirements161</p><p>8.9 Avoiding Common Mistakes162</p><p>8.10 Summary162</p><p>PROBLEMS AND POINTS TO PONDER163</p><p>FURTHER READINGS AND OTHER INFORMATION SOURCES164</p><p>CHAPTER 9 REQUIREMENTS MODELING：SCENARIO-BASED METHODS166</p><p>9.1 Requirements Analysis167</p><p>9.1.1 Overall Objectives and Philosophy168</p><p>9.1.2 Analysis Rules of Thumb169</p><p>9.1.3 Domain Analysis170</p><p>9.1.4 Requirements Modeling Approaches171</p><p>9.2 Scenario-Based Modeling173</p><p>9.2.1 Creating a Preliminary Use Case173</p><p>9.2.2 Refining a Preliminary Use Case176</p><p>9.2.3 Writing a Formal Use Case177</p><p>9.3 UML Models That Supplement the Use Case179</p><p>9.3.1 Developing an Activity Diagram180</p><p>9.3.2 Swimlane Diagrams181</p><p>9.4 Summary182</p><p>PROBLEMS AND POINTS TO PONDER182</p><p>FURTHER READINGS AND INFORMATION SOURCES183</p><p>CHAPTER 10 REQUIREMENTS MODELING：CLASS-BASED METHODS184</p><p>10.1 Identifying Analysis Classes185</p><p>10.2 Specifying Attributes188</p><p>10.3 Defining Operations189</p><p>10.4 Class-Responsibility-Collaborator Modeling192</p><p>10.5 Associations and Dependencies198</p><p>10.6 Analysis Packages199</p><p>10.7 Summary200</p><p>PROBLEMS AND POINTS TO PONDER201</p><p>FURTHER READINGS AND INFORMATION SOURCES201</p><p>CHAPTER 11 REQUIREMENTS MODELING：BEHAVIOR,PATTERNS,AND WEB/MOBILE APPS202</p><p>11.1 Creating a Behavioral Model203</p><p>11.2 Identifying Events with the Use Case203</p><p>11.3 State Representations204</p><p>11.4 Patterns for Requirements Modeling207</p><p>11.4.1 Discovering Analysis Patterns208</p><p>11.4.2 A Requirements Pattern Example：Actuator-Sensor209</p><p>11.5 Requirements Modeling for Web and Mobile Apps213</p><p>11.5.1 How Much Analysis Is Enough?214</p><p>11.5.2 Requirements Modeling Input214</p><p>11.5.3 Requirements Modeling Output215</p><p>11.5.4 Content Model216</p><p>11.5.5 Interaction Model for Web and Mobile Apps217</p><p>11.5.6 Functional Model218</p><p>11.5.7 Configuration Models for Web Apps219</p><p>11.5.8 Navigation Modeling220</p><p>11.6 Summary221</p><p>PROBLEMS AND POINTS TO PONDER222</p><p>FURTHER READINGS AND INFORMATION SOURCES222</p><p>CHAPTER 12 DESIGN CONCEPTS224</p><p>12.1 Design within the Context of Software Engineering225</p><p>12.2 The Design Process228</p><p>12.2.1 Software Quality Guidelines and Attributes228</p><p>12.2.2 The Evolution of Software Design230</p><p>12.3 Design Concepts231</p><p>12.3.1 Abstraction232</p><p>12.3.2 Architecture232</p><p>12.3.3 Patterns233</p><p>12.3.4 Separation of Concerns234</p><p>12.3.5 Modularity234</p><p>12.3.6 Information Hiding235</p><p>12.3.7 Functional Independence236</p><p>12.3.8 Refinement237</p><p>12.3.9 Aspects237</p><p>12.3.10 Refactoring238</p><p>12.3.11 Object-Oriented Design Concepts238</p><p>12.3.12 Design Classes239</p><p>12.3.13 Dependency Inversion241</p><p>12.3.14 Design for Test242</p><p>12.4 The Design Model243</p><p>12.4.1 Data Design Elements244</p><p>12.4.2 Architectural Design Elements244</p><p>12.4.3 Interface Design Elements245</p><p>12.4.4 Component-Level Design Elements247</p><p>12.4.5 Deployment-Level Design Elements248</p><p>12.5 Summary249</p><p>PROBLEMS AND POINTS TO PONDER250</p><p>FURTHER READINGS AND INFORMATION SOURCES251</p><p>CHAPTER 13 ARCHITECTURAL DESIGN252</p><p>13.1 Software Architecture253</p><p>13.1.1 What Is Architecture?253</p><p>13.1.2 Why Is Architecture Important?254</p><p>13.1.3 Architectural Descriptions255</p><p>13.1.4 Architectural Decisions256</p><p>13.2 Architectural Genres257</p><p>13.3 Architectural Styles258</p><p>13.3.1 A Brief Taxonomy of Architectural Styles258</p><p>13.3.2 Architectural Patterns263</p><p>13.3.3 Organization and Refinement263</p><p>13.4 Architectural Considerations264</p><p>13.5 Architectural Decisions266</p><p>13.6 Architectural Design267</p><p>13.6.1 Representing the System in Context267</p><p>13.6.2 Defining Archetypes269</p><p>13.6.3 Refining the Architecture into Components270</p><p>13.6.4 Describing Instantiations of the System272</p><p>13.6.5 Architectural Design for Web Apps273</p><p>13.6.6 Architectural Design for Mobile Apps274</p><p>13.7 Assessing Alternative Architectural Designs274</p><p>13.7.1 Architectural Description Languages276</p><p>13.7.2 Architectural Reviews277</p><p>13.8 Lessons Learned278</p><p>13.9 Pattern-based Architecture Review278</p><p>13.10 Architecture Conformance Checking279</p><p>13.11 Agility and Architecture280</p><p>13.12 Summary282</p><p>PROBLEMS AND POINTS TO PONDER282</p><p>FURTHER READINGS AND INFORMATION SOURCES283</p><p>CHAPTER 14 COMPONENT-LEVEL DESIGN285</p><p>14.1 What Is a Component?286</p><p>14.1.1 An Object-Oriented View286</p><p>14.1.2 The Traditional View288</p><p>14.1.3 A Process-Related View291</p><p>14.2 Designing Class-Based Components291</p><p>14.2.1 Basic Design Principles292</p><p>14.2.2 Component-Level Design Guidelines295</p><p>14.2.3 Cohesion296</p><p>14.2.4 Coupling298</p><p>14.3 Conducting Component-Level Design299</p><p>14.4 Component-Level Design for WebApps305</p><p>14.4.1 Content Design at the Component Level306</p><p>14.4.2 Functional Design at the Component Level306</p><p>14.5 Component-Level Design for Mobile Apps306</p><p>14.6 Designing Troditional Components307</p><p>14.7 Component-Based Development308</p><p>14.7.1 Domain Engineering308</p><p>14.7.2 Component Qualification,Adaptation,and Composition309</p><p>14.7.3 Architectural Mismatch311</p><p>14.7.4 Analysis and Design for Reuse312</p><p>14.7.5 Classifying and Retrieving Components312</p><p>14.8 Summary313</p><p>PROBLEMS AND POINTS TO PONDER315</p><p>FURTHER READINGS AND INFORMATION SOURCES315</p><p>CHAPTER 15 USER INTERFACE DESIGN317</p><p>15.1 The Golden Rules318</p><p>15.1.1 Place the User in Control318</p><p>15.1.2 Reduce the User's Memory Load319</p><p>15.1.3 Make the Interface Consistent321</p><p>15.2 User Interface Analysis and Design322</p><p>15.2.1 Interface Analysis and Design Models322</p><p>15.2.2 The Process323</p><p>15.3 Interface Analysis325</p><p>15.3.1 User Analysis325</p><p>15.3.2 Task Analysis and Modeling326</p><p>15.3.3 Analysis of Display Content331</p><p>15.3.4 Analysis of the Work Environment331</p><p>15.4 Interface Design Steps332</p><p>15.4.1 Applying Interface Design Steps332</p><p>15.4.2 User Interface Design Patterns334</p><p>15.4.3 Design Issues335</p><p>15.5 WebApp and Mobile Interface Design337</p><p>15.5.1 Interface Design Principles and Guidelines337</p><p>15.5.2 Interface Design Workflow for Web and Mobile Apps341</p><p>15.6 Design Evaluation342</p><p>15.7 Summary344</p><p>PROBLEMS AND POINTS TO PONDER345</p><p>FURTHER READINGS AND INFORMATION SOURCES346</p><p>CHAPTER 16 PATTERN-BASED DESIGN347</p><p>16.1 Design Patterns348</p><p>16.1.1 Kinds Of Patterns349</p><p>16.1.2 Frameworks351</p><p>16.1.3 Describing a Pattern352</p><p>16.1.4 Pattern Languages and Repositories353</p><p>16.2 Pattern-Based Software Design354</p><p>16.2.1 Pattern-Based Design in Context354</p><p>16.2.2 Thinking in Patterns354</p><p>16.2.3 Design Tasks356</p><p>16.2.4 Building a Pattern-Organizing Table358</p><p>16.2.5 Common Design Mistakes359</p><p>16.3 Architectural Patterns359</p><p>16.4 Component-Level Design Patterns360</p><p>16.5 User Interface Design Patterns362</p><p>16.6 WebApp Design Patterns364</p><p>16.6.1 Design Focus365</p><p>16.6.2 Design Granularity365</p><p>16.7 Patterns for Mobile Apps366</p><p>16.8 Summary367</p><p>PROBLEMS AND POINTS TO PONDER368</p><p>FURTHER READINGS AND INFORMATION SOURCES369</p><p>CHAPTER 17 WEBAPP DESIGN371</p><p>17.1 WebApp Design Quality372</p><p>17.2 Design Goals374</p><p>17.3 A Design Pyramid for WebApps375</p><p>17.4 WebApp Interface Design376</p><p>17.5 Aesthetic Design377</p><p>17.5.1 Layout Issues378</p><p>17.5.2 Graphic Design Issues378</p><p>17.6 Content Design379</p><p>17.6.1 Content Objects379</p><p>17.6.2 Content Design Issues380</p><p>17.7 Architecture Design381</p><p>17.7.1 Content Architecture381</p><p>17.7.2 WebApp Architecture384</p><p>17.8 Navigation Design385</p><p>17.8.1 Navigation Semantics385</p><p>17.8.2 Navigation Syntax387</p><p>17.9 Component-Level Design387</p><p>17.10 Summary388</p><p>PROBLEMS AND POINTS TO PONDER389</p><p>FURTHER READINGS AND INFORMATION SOURCES389</p><p>CHAPTER 18 MOBILEAPP DESIGN391</p><p>18.1 The Challenges392</p><p>18.1.1 Development Considerations392</p><p>18.1.2 Technical Considerations393</p><p>18.2 Developing MobileApps395</p><p>18.2.1 MobileApp Quality397</p><p>18.2.2 User Interface Design398</p><p>18.2.3 Context-Aware Apps399</p><p>18.2.4 Lessons Learned400</p><p>18.3 MobileApp Design-Best Practices401</p><p>18.4 Mobility Environments403</p><p>18.5 The Cloud405</p><p>18.6 The Applicability of Conventional Software Engineering407</p><p>18.7 Summary408</p><p>PROBLEMS AND POINTS TO PONDER409</p><p>FURTHER READINGS AND INFORMATION SOURCES409</p><p>PART THREE QUALITY MANAGEMENT411</p><p>CHAPTER 19 QUALITY CONCEPTS412</p><p>19.1 What Is Quality?413</p><p>19.2 Software Quality414</p><p>19.2.1 Garvin's Quality Dimensions415</p><p>19.2.2 McCall's Quality Factors416</p><p>19.2.3 ISO 9126 Quality Factors418</p><p>19.2.4 Targeted Quality Factors418</p><p>19.2.5 The Transition to a Quantitative View420</p><p>19.3 The Software Quality Dilemma420</p><p>19.3.1 &quot;Good Enough&quot;Software421</p><p>19.3.2 The Cost of Quality422</p><p>19.3.3 Risks424</p><p>19.3.4 Negligence and Liability425</p><p>19.3.5 Quality and Security425</p><p>19.3.6 The Impact of Management Actions426</p><p>19.4 Achieving Software Quality427</p><p>19.4.1 Software Engineering Methods427</p><p>19.4.2 Project Management Techniques427</p><p>19.4.3 Quality Control427</p><p>19.4.4 Quality Assurance428</p><p>19.5 Summary428</p><p>PROBLEMS AND POINTS TO PONDER429</p><p>FURTHER READINGS AND INFORMATION SOURCES429</p><p>CHAPTER 20 REVIEW TECHNIQUES431</p><p>20.1 Cost Impact of Software Defects432</p><p>20.2 Defect Amplification and Removal433</p><p>20.3 Review Metrics and Their Use435</p><p>20.3.1 Analyzing Metrics435</p><p>20.3.2 Cost-Effectiveness Of Reviews436</p><p>20.4 Reviews：A Formality Spectrum438</p><p>20.5 Informal Reviews439</p><p>20.6 Formal Technical Reviews441</p><p>20.6.1 The Review Meeting441</p><p>20.6.2 Review Reporting and Record Keeping442</p><p>20.6.3 Review Guidelines442</p><p>20.6.4 Sample-Driven Reviews444</p><p>20.7 Post-Mortem Evaluations445</p><p>20.8 Summary446</p><p>PROBLEMS AND POINTS TO PONDER446</p><p>FURTHER READINGS AND INFORMATION SOURCES447</p><p>CHAPTER 21 SOFTWARE QUALITY ASSURANCE448</p><p>21.1 Background Issues449</p><p>21.2 Elements of Software Quality Assurance450</p><p>21.3 SQA Processes and Product Characteristics452</p><p>21.4 SQA Tasks,Goals,and Metrics452</p><p>21.4.1 SQA Tasks453</p><p>21.4.2 Goals,Attributes,and Metrics454</p><p>21.5 Formal Approaches to SQA456</p><p>21.6 Statistical Software Quality Assurance456</p><p>21.6.1 A Generic Example457</p><p>21.6.2 Six Sigma for Software Engineering458</p><p>21.7 Software Reliability459</p><p>21.7.1 Measures of Reliability and Availability459</p><p>21.7.2 Software Safety460</p><p>21.8 The ISO 9000 Quality Standards461</p><p>21.9 The SQA Plan463</p><p>21.10 Summary463</p><p>PROBLEMS AND POINTS TO PONDER464</p><p>FURTHER READINGS AND INFORMATION SOURCES464</p><p>CHAPTER 22 SOFTWARE TESTING STRATEGIES466</p><p>22.1 A Strategic Approach to Software Testing466</p><p>22.1.1 Verification and Validation468</p><p>22.1.2 Organizing for Software Testing468</p><p>22.1.3 Software Testing Strategy-The Big Picture469</p><p>22.1.4 Criteria for Completion of Testing472</p><p>22.2 Strategic Issues472</p><p>22.3 Test Strategies for Conventional Software473</p><p>22.3.1 Unit Testing473</p><p>22.3.2 Integration Testing475</p><p>22.4 Test Strategies for Object-Oriented Software481</p><p>22.4.1 Unit Testing in the OO Context481</p><p>22.4.2 Integration Testing in the OO Context481</p><p>22.5 Test Strategies for WebApps482</p><p>22.6 Test Strategies for MobileApps483</p><p>22.7 Validation Testing483</p><p>22.7.1 Validation-Test Criteria484</p><p>22.7.2 Configuration Review484</p><p>22.7.3 Alpha and Beta Testing484</p><p>22.8 System Testing486</p><p>22.8.1 Recovery Testing486</p><p>22.8.2 Security Testing486</p><p>22.8.3 Stress Testing487</p><p>22.8.4 Performance Testing487</p><p>22.8.5 Deployment Testing487</p><p>22.9 The Art of Debugging488</p><p>22.9.1 The Debugging Process488</p><p>22.9.2 Psychological Considerations490</p><p>22.9.3 Debugging Strategies491</p><p>22.9.4 Correcting the Error492</p><p>22.10 Summary493</p><p>PROBLEMS AND POINTS TO PONDER493</p><p>FURTHER READINGS AND INFORMATION SOURCES494</p><p>CHAPTER 23 TESTING CONVENTIONAL APPLICATIONS496</p><p>23.1 Software Testing Fundamentals497</p><p>23.2 Internal and External Views of Testing499</p><p>23.3 White-Box Testing500</p><p>23.4 Basis Path Testing500</p><p>23.4.1 Flow Graph Notation500</p><p>23.4.2 Independent Program Paths502</p><p>23.4.3 Deriving Test Cases504</p><p>23.4.4 Graph Matrices506</p><p>23.5 Control Structure Testing507</p><p>23.6 Black-Box Testing509</p><p>23.6.1 Graph-Based Testing Methods509</p><p>23.6.2 Equivalence Partitioning511</p><p>23.6.3 Boundary Value Analysis512</p><p>23.6.4 Orthogonal Array Testing513</p><p>23.7 Model-Based Testing516</p><p>23.8 Testing Documentation and Help Facilities516</p><p>23.9 Testing for Real-Time Systems517</p><p>23.10 Patterns for Software Testing519</p><p>23.11 Summary520</p><p>PROBLEMS AND POINTS TO PONDER521</p><p>FURTHER READINGS AND INFORMATION SOURCES521</p><p>CHAPTER 24 TESTING OBJECT-ORIENTED APPLICATIONS523</p><p>24.1 Broadening the View of Testing524</p><p>24.2 Testing OOA and OOD Models525</p><p>24.2.1 Correctness of OOA and OOD Models525</p><p>24.2.2 Consistency of Object-Oriented Models526</p><p>24.3 Object-Oriented Testing Strategies528</p><p>24.3.1 Unit Testing in the OO Context528</p><p>24.3.2 Integration Testing in the OO Context529</p><p>24.3.3 Validation Testing in an OO Context529</p><p>24.4 Object-Oriented Testing Methods529</p><p>24.4.1 The Test-Case Design Implications of OO Concepts530</p><p>24.4.2 Applicability of Conventional Test-Case Design Methods531</p><p>24.4.3 Fault-Based Testing531</p><p>24.4.4 Scenario-Based Test Design532</p><p>24.5 Testing Methods Applicable at the Class Level532</p><p>24.5.1 Random Testing for OO Classes532</p><p>24.5.2 Partition Testing at the Class Level533</p><p>24.6 Interclass Test-Case Design534</p><p>24.6.1 Multiple Class Testing534</p><p>24.6.2 Tests Derived from Behavior Models536</p><p>24.7 Summary537</p><p>PROBLEMS AND POINTS TO PONDER538</p><p>FURTHER READINGS AND INFORMATION SOURCES538</p><p>CHAPTER 25 TESTING WEB APPLICATIONS540</p><p>25.1 Testing Concepts for WebApps541</p><p>25.1.1 Dimensions of Quality541</p><p>25.1.2 Errors within a WebApp Environment542</p><p>25.1.3 Testing Strategy543</p><p>25.1.4 Test Planning543</p><p>25.2 The Testing Process-An Overview544</p><p>25.3 Content Testing545</p><p>25.3.1 Content Testing Objectives545</p><p>25.3.2 Database Testing547</p><p>25.4 User Interface Testing549</p><p>25.4.1 Interface Testing Strategy549</p><p>25.4.2 Testing Interface Mechanisms550</p><p>25.4.3 Testing Interface Semantics552</p><p>25.4.4 Usability Tests552</p><p>25.4.5 Compatibility Tests554</p><p>25.5 Component-Level Testing555</p><p>25.6 Navigation Testing556</p><p>25.6.1 Testing Navigation Syntax556</p><p>25.6.2 Testing Navigation Semantics556</p><p>25.7 Configuration Testing558</p><p>25.7.1 Server-Side Issues558</p><p>25.7.2 Client-Side Issues559</p><p>25.8 Security Testing559</p><p>25.9 Performance Testing560</p><p>25.9.1 Performance Testing Objectives561</p><p>25.9.2 Load Testing562</p><p>25.9.3 Stress Testing562</p><p>25.10 Summary563</p><p>PROBLEMS AND POINTS TO PONDER564</p><p>FURTHER READINGS AND INFORMATION SOURCES565</p><p>CHAPTER 26 TESTING MOBILEAPPS567</p><p>26.1 Testing Guidelines568</p><p>26.2 The Testing Strategies569</p><p>26.2.1 Are Conventional Approaches Applicable?570</p><p>26.2.2 The Need for Automation571</p><p>26.2.3 Building a Test Matrix572</p><p>26.2.4 Stress Testing573</p><p>26.2.5 Testing in a Production Environment573</p><p>26.3 Considering the Spectrum of User Interaction574</p><p>26.3.1 Gesture Testing575</p><p>26.3.2 Voice Input and Recognition576</p><p>26.3.3 Virtual Key Board Input577</p><p>26.3.4 Alerts and Extraordinary Conditions577</p><p>26.4 Test Across Borders578</p><p>26.5 Real-Time Testing Issues578</p><p>26.6 Testing Tools and Environments579</p><p>26.7 Summary581</p><p>PROBLEMS AND POINTS TO PONDER582</p><p>FURTHER READINGS AND INFORMATION SOURCES582</p><p>CHAPTER 27 SECURITY ENGINEERING584</p><p>27.1 Analyzing Security Requirements585</p><p>27.2 Security and Privacy in an Online Warld586</p><p>27.2.1 Social Media587</p><p>27.2.2 Mobile Applications587</p><p>27.2.3 Cloud Computing587</p><p>27.2.4 The Internet of Things588</p><p>27.3 Security Engineering Analysis588</p><p>27.3.1 Security Requirement Elicitation589</p><p>27.3.2 Security Modeling590</p><p>27.3.3 Measures Design591</p><p>27.3.4 Correctness Checks591</p><p>27.4 Security Assurance592</p><p>27.4.1 The Security Assurance Process592</p><p>27.4.2 Organization and Management593</p><p>27.5 Security Risk Analysis594</p><p>27.6 The Role of Conventional Software Engineering Activities595</p><p>27.7 Verification of Trustworthy Systems597</p><p>27.8 Summary599</p><p>PROBLEMS AND POINTS TO PONDER599</p><p>FURTHER READINGS AND INFORMATION SOURCES600</p><p>CHAPTER 28 FORMAL MODELING AND VERIFICATION601</p><p>28.1 The Cleanroom Strategy602</p><p>28.2 Functional Specification604</p><p>28.2.1 Black-Box Specification605</p><p>28.2.2 State-Box Specification606</p><p>28.2.3 Clear-Box Specification607</p><p>28.3 Cleanroom Design607</p><p>28.3.1 Design Refinement608</p><p>28.3.2 Design Verification608</p><p>28.4 Cleanroom Testing610</p><p>28.4.1 Statistical Use Testing610</p><p>28.4.2 Certification612</p><p>28.5 Rethinking Formal Methods612</p><p>28.6 Formal Methods Concepts615</p><p>28.7 Alternative Arguments618</p><p>28.8 Summary619</p><p>PROBLEMS AND POINTS TO PONDER620</p><p>FURTHER READINGS AND INFORMATION SOURCES621</p><p>CHAPTER 29 SOFTWARE CONFIGURATION MANAGEMENT623</p><p>29.1 Software Configuration Management624</p><p>29.1.1 An SCM Scenario625</p><p>29.1.2 Elements of a Configuration Management System626</p><p>29.1.3 Baselines626</p><p>29.1.4 Software Configuration Items628</p><p>29.1.5 Management of Dependencies and Changes628</p><p>29.2 The SCM Repository630</p><p>29.2.1 General Features and Content630</p><p>29.2.2 SCM Features631</p><p>29.3 The SCM Process632</p><p>29.3.1 Identification of Objects in the Software Configuration633</p><p>29.3.2 Version Control634</p><p>29.3.3 Change Control635</p><p>29.3.4 Impact Management638</p><p>29.3.5 Configuration Audit639</p><p>29.3.6 Status Reporting639</p><p>29.4 Configuration Management for Web and MobileApps640</p><p>29.4.1 Dominant Issues641</p><p>29.4.2 Configuration Objects642</p><p>29.4.3 Content Management643</p><p>29.4.4 Change Management646</p><p>29.4.5 Version Control648</p><p>29.4.6 Auditing and Reporting649</p><p>29.5 Summary650</p><p>PROBLEMS AND POINTS TO PONDER651</p><p>FURTHER READINGS AND INFORMATION SOURCES651</p><p>CHAPTER 30 PRODUCT METRICS653</p><p>30.1 A Framework for Product Metrics654</p><p>30.1.1 Measures,Metrics,and Indicators654</p><p>30.1.2 The Challenge of Product Metrics655</p><p>30.1.3 Measurement Principles656</p><p>30.1.4 Goal-Oriented Software Measurement656</p><p>30.1.5 The Attributes of Effective Software Metrics657</p><p>30.2 Metrics for the Requirements Model659</p><p>30.2.1 Function-Based Metrics659</p><p>30.2.2 Metrics for Specification Quality662</p><p>30.3 Metrics for the Design Model663</p><p>30.3.1 Architectural Design Metrics663</p><p>30.3.2 Metrics for Object-Oriented Design666</p><p>30.3.3 Class-Oriented Metrics-The CK Metrics Suite667</p><p>30.3.4 Class-Oriented Metrics-The MOOD Metrics Suite670</p><p>30.3.5 OO Metrics Proposed by Lorenz and Kidd671</p><p>30.3.6 Component-Level Design Metrics671</p><p>30.3.7 Operation-Oriented Metrics671</p><p>30.3.8 User Interface Design Metrics672</p><p>30.4 Design Metrics for Web and Mobile Apps672</p><p>30.5 Metrics for Source Code675</p><p>30.6 Metrics for Testing676</p><p>30.6.1 Halstead Metrics Applied to Testing676</p><p>30.6.2 Metrics for Object-Oriented Testing677</p><p>30.7 Metrics for Maintenance678</p><p>30.8 Summary679</p><p>PROBLEMS AND POINTS TO PONDER679</p><p>FURTHER READINGS AND INFORMATION SOURCES680</p><p>PART FOUR MANAGING SOFTWARE PROJECTS683</p><p>CHAPTER 31 PROJECT MANAGEMENT CONCEPTS684</p><p>31.1 The Management Spectrum685</p><p>31.1.1 The People685</p><p>31.1.2 The Product686</p><p>31.1.3 The Process686</p><p>31.1.4 The Project686</p><p>31.2 People687</p><p>31.2.1 The Stakeholders687</p><p>31.2.2 Team Leaders688</p><p>31.2.3 The Software Team689</p><p>31.2.4 Agile Teams691</p><p>31.2.5 Coordination and Communication Issues692</p><p>31.3 The Product693</p><p>31.3.1 Software Scope694</p><p>31.3.2 Problem Decomposition694</p><p>31.4 The Process694</p><p>31.4.1 Melding the Product and the Process695</p><p>31.4.2 Process Decomposition696</p><p>31.5 The Project697</p><p>31.6 The W5HH Principle698</p><p>31.7 Critical Practices699</p><p>31.8 Summaty700</p><p>PROBLEMS AND POINTS TO PONDER700</p><p>FURTHER READINGS AND INFORMATION SOURCES701</p><p>CHAPTER 32 PROCESS AND PROJECT METRICS703</p><p>32.1 Metrics in the Process and Project Domains704</p><p>32.1.1 Process Metrics and Software Process Improvement704</p><p>32.1.2 Project Metrics707</p><p>32.2 Software Measurement708</p><p>32.2.1 Size-Oriented Metrics709</p><p>32.2.2 Function-Driented Metrics710</p><p>32.2.3 Reconciling LOC and FP Metrics711</p><p>32.2.4 Object-Oriented Metrics713</p><p>32.2.5 Use Case-Oriented Metrics714</p><p>32.2.6 WebApp Project Metrics714</p><p>32.3 Metrics for Software Quality716</p><p>32.3.1 Measuring Quality717</p><p>32.3.2 Defect Removal Efficiency718</p><p>32.4 Integrating Metrics within the Software Process719</p><p>32.4.1 Arguments for Software Metrics720</p><p>32.4.2 Establishing a Baseline720</p><p>32.4.3 Metrics Collection,Computation and Evaluation721</p><p>32.5 Metrics for Small Organizations721</p><p>32.6 Establishing a Software Metrics Program722</p><p>32.7 Summary724</p><p>PROBLEMS AND POINTS TO PONDER724</p><p>FURTHER READINGS AND INFORMATION SOURCES725</p><p>CHAPTER 33 ESTIMATION FOR SOFTWARE PROJECTS727</p><p>33.1 Observations on Estimation728</p><p>33.2 The Project Planning Process729</p><p>33.3 Software Scope and Feasibility730</p><p>33.4 Resources731</p><p>33.4.1 Human Resources731</p><p>33.4.2 Reusable Software Resources732</p><p>33.4.3 Environmental Resources732</p><p>33.5 Software Project Estimation733</p><p>33.6 Decomposition Techniques734</p><p>33.6.1 Software Sizing734</p><p>33.6.2 Problem-Based Estimation735</p><p>33.6.3 An Example of LOC-Based Estimation736</p><p>33.6.4 An Example of FP-Based Estimation738</p><p>33.6.5 Process-Based Estimation739</p><p>33.6.6 An Example of Process-Based Estimation740</p><p>33.6.7 Estimation with Use Cases740</p><p>33.6.8 An Example of Estimation Using Use Case Points742</p><p>33.6.9 Reconciling Estimates742</p><p>33.7 Empirical Estimation Models743</p><p>33.7.1 The Structure of Estimation Models744</p><p>33.7.2 The COCOMOⅡ Model744</p><p>33.7.3 The Software Equation744</p><p>33.8 Estimation for Object-Oriented Projects746</p><p>33.9 Specialized Estimation Techniques746</p><p>33.9.1 Estimation for Agile Development746</p><p>33.9.2 Estimation for WebApp Projects747</p><p>33.10 The Make/Buy Decision748</p><p>33.10.1 Creating a Decision Tree749</p><p>33.10.2 Outsourcing750</p><p>33.11 Summary752</p><p>PROBLEMS AND POINTS TO PONDER752</p><p>FURTHER READINGS AND INFORMATION SOURCES753</p><p>CHAPTER 34 PROJECT SCHEDULING754</p><p>34.1 Basic Concepts755</p><p>34.2 Project Scheduling757</p><p>34.2.1 Basic Principles758</p><p>34.2.2 The Relationship between People and Effort759</p><p>34.2.3 Effort Distribution760</p><p>34.3 Defining a Task Set for the Software Project761</p><p>34.3.1 A Task Set Example762</p><p>34.3.2 Refinement of Major Tasks763</p><p>34.4 Defining a Task Network764</p><p>34.5 Scheduling765</p><p>34.5.1 Time-Line Charts766</p><p>34.5.2 Tracking the Schedule767</p><p>34.5.3 Tracking Progress for an OO Project768</p><p>34.5.4 Scheduling for WebApp and Mobile Projects769</p><p>34.6 Earned Value Analysis772</p><p>34.7 Summary774</p><p>PROBLEMS AND POINTS TO PONDER774</p><p>FURTHER READINGS AND INFORMATION SOURCES776</p><p>CHAPTER 35 RISK MANAGEMENT777</p><p>35.1 Reactive versus Proactive Risk Strategies778</p><p>35.2 Software Risks778</p><p>35.3 Risk Identification780</p><p>35.3.1 Assessing Overall Project Risk781</p><p>35.3.2 Risk Components and Drivers782</p><p>35.4 Risk Projection782</p><p>35.4.1 Developing a Risk Table783</p><p>35.4.2 Assessing Risk Impact785</p><p>35.5 Risk Refinement787</p><p>35.6 Risk Mitigation,Monitoring,and Management788</p><p>35.7 The RMMM Plan790</p><p>35.8 Summary792</p><p>PROBLEMS AND POINTS TO PONDER792</p><p>FURTHER READINGS AND INFORMATION SOURCES793</p><p>CHAPTER 36 MAINTENANCE AND REENGINEERING795</p><p>36.1 Software Maintenance796</p><p>36.2 Software Supportability798</p><p>36.3 Reengineering798</p><p>36.4 Business Process Reengineering799</p><p>36.4.1 Business Processes799</p><p>36.4.2 A BPR Model800</p><p>36.5 Software Reengineering802</p><p>36.5.1 A Software Reengineering Process Model802</p><p>36.5.2 Software Reengineering Activities803</p><p>36.6 Reverse Engineering805</p><p>36.6.1 Reverse Engineering to Understand Data807</p><p>36.6.2 Reverse Engineering to Understand Processing807</p><p>36.6.3 Reverse Engineering User Interfaces808</p><p>36.7 Restructuring809</p><p>36.7.1 Code Restructuring809</p><p>36.7.2 Data Restructuring810</p><p>36.8 Forward Engineering811</p><p>36.8.1 Forward Engineering for Client-Server Architectures812</p><p>36.8.2 Forward Engineering for Object-Oriented Architectures813</p><p>36.9 The Economics of Reengineering813</p><p>36.10 Summary814</p><p>PROBLEMS AND POINTS TO PONDER815</p><p>FURTHER READINGS AND INFORMATION SOURCES816</p><p>PART FIVE ADVANCED TOPICS817</p><p>CHAPTER 37 SOFTWARE PROCESS IMPROVEMENT818</p><p>37.1 What Is SPI?819</p><p>37.1.1 Approaches to SPI819</p><p>37.1.2 Maturity Models821</p><p>37.1.3 Is SPI for Everyone?822</p><p>37.2 The SPI Process823</p><p>37.2.1 Assessment and Gap Analysis823</p><p>37.2.2 Education and Trainina825</p><p>37.2.3 Selection and Justification825</p><p>37.2.4 Installation/Migration826</p><p>37.2.5 Evaluation827</p><p>37.2.6 Risk Management for SPI827</p><p>37.3 The CMMI828</p><p>37.4 The People CMM832</p><p>37.5 Other SPI Frameworks832</p><p>37.6 SPI Return on Investment834</p><p>37.7 SPI Trends835</p><p>37.8 Summary836</p><p>PROBLEMS AND POINTS TO PONDER837</p><p>FURTHER READINGS AND INFORMATION SOURCES837</p><p>CHAPTER 38 EMERGING TRENDS IN SOFTWARE ENGINEERING839</p><p>38.1 Technology Evolution840</p><p>38.2 Prospects for a True Engineering Discipline841</p><p>38.3 Observing Software Engineering Trends842</p><p>38.4 Identifying&quot;Soft Trends&quot;843</p><p>38.4.1 Managing Complexity845</p><p>38.4.2 Open-World Software846</p><p>38.4.3 Emergent Requirements846</p><p>38.4.4 The Talent Mix847</p><p>38.4.5 Software Building Blocks847</p><p>38.4.6 Changing Perceptions of&quot;Value&quot;848</p><p>38.4.7 Open Source848</p><p>38.5 Technology Directions849</p><p>38.5.1 Process Trends849</p><p>38.5.2 The Grand Challenge851</p><p>38.5.3 Collaborative Development852</p><p>38.5.4 Requirements Engineering852</p><p>38.5.5 Model Driven Software Development853</p><p>38.5.6 Postmodern Design854</p><p>38.5.7 Test-Driven Development854</p><p>38.6 Tools-Related Trends855</p><p>38.7 Summary857</p><p>PROBLEMS AND POINTS TO PONDER857</p><p>FURTHER READINGS AND IN FORMATION SOURCES858</p><p>CHAPTER 39 CONCLUDING COMMENTS860</p><p>39.1 The Importance of Software-Revisited861</p><p>39.2 People and the Way They Build Systems861</p><p>39.3 New Modes for Representing Information862</p><p>39.4 The Long View864</p><p>39.5 The Software Engineer's Responsibility865</p><p>39.6 A Final Comment from RSP867</p><p>APPENDIX 1 AN INTRODUCTION TO UML869</p><p>APPENDIX 2 OBJECT-ORIENTED CONCEPTS891</p><p>APPENDIX 3 FORMAL METHODS899</p><p>REFERENCES909</p><p>INDEX933</p><p></p></div></div><div class="d-rt"><h3>热门推荐</h3><ul><li><a href="/book/1348961.html">1348961.html</a></li><li><a href="/book/1952657.html">1952657.html</a></li><li><a href="/book/1235284.html">1235284.html</a></li><li><a href="/book/3684354.html">3684354.html</a></li><li><a href="/book/3490429.html">3490429.html</a></li><li><a href="/book/211906.html">211906.html</a></li><li><a href="/book/3499861.html">3499861.html</a></li><li><a href="/book/6141.html">6141.html</a></li><li><a href="/book/2184755.html">2184755.html</a></li><li><a href="/book/566857.html">566857.html</a></li></ul></div></div><div id="footer"><p>Copyright&nbsp;&copy;&nbsp;2025&nbsp;&nbsp;<a href="/list/">最新更新</a></p><p>请使用FDM BitComet qBittorrent uTorrent等BT下载工具，下载本站电子书资源！首推Free Download Manager下载软件。文件页数>标注页数[分册图书除外]</p></div></body></html>