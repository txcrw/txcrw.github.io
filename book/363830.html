<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><script type="text/javascript" src="https://file.bkxsj.com/skin/book/js/sk.js"></script><meta name="robots" content="index,follow"><title>C++ Primer 第4版 评注版 英文[PDF|Epub|txt|kindle电子书版本网盘下载]-灵感之桥</title><meta name="Keywords" content="C++ Primer 第4版 评注版 英文"/><meta name="description" content="C++ Primer 第4版 评注版 英文pdf下载文件大小为209MB,PDF页数为689页"/><meta http-equiv="X-UA-Compatible" content="IE=9; IE=8; IE=7; IE=EDGE;chrome=1"><link type="image/x-icon" rel="shortcut icon" href="https://www.shukui.net/skin/book/images/favicon.ico"><link type="text/css" rel="stylesheet" href="https://www.shukui.net/skin/book/css/style.css"><style>#main .d-main {margin-left: 0;width: 620px;}.down-btn {animation: myShake 2.5s linear .15s infinite}@keyframes myShake {0%, 66% {transform: translateZ(0)}67%, 73.6%, 83.6%, 93.6%, to {animation-timing-function: cubic-bezier(.215, .61, .355, 1);transform: translateZ(0)}80.3%, 81.4% {animation-timing-function: cubic-bezier(.755, .05, .855, .06);transform: translate3d(0, -4px, 0)}90.3% {animation-timing-function: cubic-bezier(.755, .05, .855, .06);transform: translate3d(0, -2px, 0)}97% {transform: translate3d(0, -.5px, 0)}}.copylink-btn {margin-right: 20px;}.copymd5-btn {margin-bottom: 25px;margin-left: 10px;}</style></head><body><div id="header"><div class="inner"><div class="logo"><a href="/"><img width="103" height="25" alt="灵感之桥"src="https://www.shukui.net/skin/book/images/logo.png"></a></div><div class="search"><form action="/so/search.php" target="_blank"><input type="text" autocomplete="off" id="bdcsMain" name="q" placeholder="书名 / 作者 / 出版社 / ISBN"class="inp-txt"><select class="inp-select" id="datasource" onchange="selectDatasource(this)"><option value="so">主库</option><option value="s">从库</option></select><input type="submit" value="搜索" class="inp-btn"></form></div></div></div><div id="main"><div class="d-main"><div class="tit"><h3>图书介绍</h3></div><h1 class="book-name">C++ Primer 第4版 评注版 英文PDF|Epub|txt|kindle电子书版本网盘下载</h1><div class="d-info"><div class="b-thumb"><img src="https://www.shukui.net/cover/75/30399171.jpg" alt="C++ Primer 第4版 评注版 英文"></div><div class="b-info"><ul><li>（美）李普曼著 著</li><li>出版社： 北京：电子工业出版社</li><li>ISBN：9787121174414</li><li>出版时间：2012</li><li>标注页数：662页</li><li>文件大小：209MB</li><li>文件页数：689页</li><li>主题词：C语言－程序设计－教材</li></ul></div></div><div class="tit"><h3>PDF下载</h3></div><div></br><a style="color:red;" rel="external nofollow" href="https://www.kjlm.net/ebook/363831.html"target="_blank"><b>点此进入-本书在线PDF格式电子书下载【推荐-云解压-方便快捷】直接下载PDF格式图书。移动端-PC端通用</a></b></br><a class="down-btn" rel="external nofollow" href="https://down.trackerbk.com/bt/01/30399171.torrent"target="_blank">种子下载</a>[BT下载速度快]温馨提示：（请使用BT下载软件FDM进行下载）<a rel="nofollow" href="https://www.freedownloadmanager.org/zh/" target="_blank">软件下载地址页</a><a class="down-btn" rel="external nofollow" href="https://down.p2spdb.com/01/30399171.rar" target="_blank">直链下载</a>[便捷但速度慢]&nbsp;&nbsp;<a style="color:red;" rel="external nofollow" href="https://pdfyl.ertongbook.com/09/30399171.pdf" target="_blank"><b>[在线试读本书]</b></a>&nbsp;&nbsp;<b> <a style="color:red;" rel="external nofollow" href="https://web.jyjl.org/index/recovery.html" target="_blank">[在线获取解压码]</a></b><div class="copymd5-btn"><a href="javascript:copyToClip('ecd313c6103cd7cd24cc566b6391fb3d')">点击复制MD5值：ecd313c6103cd7cd24cc566b6391fb3d</a></div></div><div class="tit"><h3>下载说明</h3></div><div style="margin:20px 10px"><h2>C++ Primer 第4版 评注版 英文PDF格式电子书版下载</h2>下载的文件为RAR压缩包。需要使用解压软件进行解压得到PDF格式图书。<br><br><div class="copymd5-btn"><a href="javascript:copyToClip('magnet:?xt=urn:btih:RX6G6JQ2LJW7PBBEDNUSCQM7ICDMHIWK')">点击复制85GB完整离线版磁力链接到迅雷FDM等BT下载工具进行下载</a>&nbsp;&nbsp;<a rel="nofollow" target="_blank">详情点击-查看共享计划</a></div>建议使用BT下载工具Free Download Manager进行下载,简称FDM(免费,没有广告,支持多平台）。本站资源全部打包为BT种子。所以需要使用专业的BT下载软件进行下载。如BitComet qBittorrent uTorrent等BT下载工具。迅雷目前由于本站不是热门资源。不推荐使用！后期资源热门了。安装了迅雷也可以迅雷进行下载！<br><br><b>（文件页数 要大于 标注页数，上中下等多册电子书除外）</b><br><br><p style="color:red;"> <b>注意：本站所有压缩包均有解压码：</b> <a rel="nofollow" target="_blank"><b>点击下载压缩包解压工具</b></a></p></div><div class="tit"><h3>图书目录</h3></div><div id="book-contents"><p>Chapter 1 Getting Started（新增评注29条）1</p><p>1.1 Writing a Simple C++ Program2</p><p>1.1.1 Compiling and Executing Our Program3</p><p>1.2 A First Look at Input/Output5</p><p>1.2.1 Standard Input and Output Objects5</p><p>1.2.2 A Program that Uses the IO Library5</p><p>1.3 A Word About Comments8</p><p>1.4 Control Structures10</p><p>1.4.1 The while Statement10</p><p>1.4.2 The for Statement12</p><p>1.4.3 The if Statement14</p><p>1.4.4 Reading an Unknown Number of Inputs15</p><p>1.5 Introducing Classes17</p><p>1.5.1 The Sales_item Class17</p><p>1.5.2 A First Look at Member Functions20</p><p>1.6 The C++ Program21</p><p>Part Ⅰ The Basics23</p><p>Chapter 2 Variables and Basic Types（新增评注42条）25</p><p>2.1 Primitive Built-in Types26</p><p>2.1.1 Integral Types26</p><p>2.1.2 Floating-Point Types28</p><p>2.2 Literal Constants29</p><p>2.3 Variables33</p><p>2.3.1 What Is a Variable?34</p><p>2.3.2 The Name of a Variable36</p><p>2.3.3 Defining Objects37</p><p>2.3.4 Variable Initialization Rules39</p><p>2.3.5 Declarations and Definitions41</p><p>2.3.6 Scope of a Name42</p><p>2.3.7 Define Variables Where They Are Used43</p><p>2.4 const Qualifier44</p><p>2.5 References46</p><p>2.6 Typedef Names48</p><p>2.7 Enumerations48</p><p>2.8 Class Types49</p><p>2.9 Writing Our Own Header Files52</p><p>2.9.1 Designing Our Own Headers53</p><p>2.9.2 A Brief Introduction to the Preprocessor55</p><p>Chapter 3 Library Types（新增评注30条）59</p><p>3.1 Namespace using Declarations60</p><p>3.2 Library string Type62</p><p>3.2.1 Defining and Initializing strings62</p><p>3.2.2 Reading and Writing strings62</p><p>3.2.3 Operations on strings64</p><p>3.2.4 Dealing with the Characters of a string68</p><p>3.3 Library vector Type70</p><p>3.3.1 Defining and Initializing vectors70</p><p>3.3.2 Operations on vectors72</p><p>3.4 Introducing Iterators74</p><p>3.4.1 Iterator Arithmetic78</p><p>3.5 Library bitset Type79</p><p>3.5.1 Defining and Initializing bitsets79</p><p>3.5.2 Operations on bitsets81</p><p>Chapter 4 Arrays and Pointers（新增评注33条）85</p><p>4.1 Arrays86</p><p>4.1.1 Defining and Initializing Arrays86</p><p>4.1.2 Operations on Arrays89</p><p>4.2 Introducing Pointers89</p><p>4.2.1 What Is a Pointer?90</p><p>4.2.2 Defining and Initializing Pointers91</p><p>4.2.3 Operations on Pointers94</p><p>4.2.4 Using Pointers to Access Array Elements96</p><p>4.2.5 Pointers and the const Qualifier99</p><p>4.3 C-Style Character Strings102</p><p>4.3.1 Dynamically Allocating Arrays106</p><p>4.3.2 Interfacing to Older Code110</p><p>4.4 Multidimensioned Arrays111</p><p>4.4.1 Pointers and Multidimensioned Arrays113</p><p>Chapter 5 Expressions（新增评注49条）115</p><p>5.1 Arithmetic Operators117</p><p>5.2 Relational and Logical Operators119</p><p>5.3 The Bitwise Operators121</p><p>5.3.1 Using bitset Objects or Integral Values123</p><p>5.3.2 Using the Shift Operators for IO124</p><p>5.4 Assignment Operators125</p><p>5.4.1 Assignment Is Right Associative125</p><p>5.4.2 Assignment Has Low Precedence126</p><p>5.4.3 Compound Assignment Operators127</p><p>5.5 Increment and Decrement Operators127</p><p>5.6 The Arrow Operator129</p><p>5.7 The Conditional Operator130</p><p>5.8 The sizeof Operator131</p><p>5.9 Comma Operator132</p><p>5.10 Evaluating Compound Expressions132</p><p>5.10.1 Precedence132</p><p>5.10.2 Associativity133</p><p>5.10.3 Order of Evaluation135</p><p>5.11 The new and delete Expressions137</p><p>5.12 Type Conversions140</p><p>5.12.1 When Implicit Type Conversions Occur141</p><p>5.12.2 The Arithmetic Conversions142</p><p>5.12.3 Other Implicit Conversions143</p><p>5.12.4 Explicit Conversions145</p><p>5.12.5 When Casts Might Be Useful145</p><p>5.12.6 Named Casts145</p><p>5.12.7 Old-Style Casts147</p><p>Chapter 6 Statements（新增评注29条）149</p><p>6.1 Simple Statements150</p><p>6.2 Declaration Statements151</p><p>6.3 Compound Statements（Blocks）151</p><p>6.4 Statement Scope152</p><p>6.5 The if Statement153</p><p>6.5.1 The if Statement else Branch154</p><p>6.6 The switch Statement156</p><p>6.6.1 Using a switch156</p><p>6.6.2 Control Flow within a switch157</p><p>6.6.3 The default Label158</p><p>6.6.4 switch Expression and Case Labels159</p><p>6.6.5 Variable Definitions inside a switch159</p><p>6.7 The while Statement160</p><p>6.8 The for Loop Statement162</p><p>6.8.1 Omitting Parts of the for Header163</p><p>6.8.2 Multiple Definitions in the forHeader164</p><p>6.9 The do while Statement165</p><p>6.10 The break Statement166</p><p>6.11 The continue Statement167</p><p>6.12 The goto Statement168</p><p>6 13 try Blocks and Exception Handling169</p><p>6.13.1 A throw Expression169</p><p>6.13.2 The try Block170</p><p>6.13.3 Standard Exceptions172</p><p>6.14 Using the Preprocessorfor Debugging173</p><p>Chapter 7 Functions（新增评注56条）175</p><p>7.1 Defining a Function176</p><p>7.1.1 Function Return Type177</p><p>7.1.2 Function Parameter List178</p><p>7.2 Argument Passing179</p><p>7.2.1 Nonreference Parameters179</p><p>7.2.2 Reference Parameters181</p><p>7.2.3 vector and Other Container Parameters185</p><p>7.2.4 Array Parameters186</p><p>7.2.5 Managing Arrays Passed to Functions188</p><p>7.2.6 main:Handling Command-Line Options190</p><p>7.2.7 Functions with Varying Parameters191</p><p>7.3 The return Statement191</p><p>7.3.1 Functions with No Return Value191</p><p>7.3.2 Functions that Return a Value192</p><p>7.3.3 Recursion195</p><p>7.4 Function Declarations196</p><p>7.4.1 Default Arguments197</p><p>7.5 Local Objects199</p><p>7.5.1 Automatic Objects199</p><p>7.5.2 Static Local Objects200</p><p>7.6 Inline Functions200</p><p>7.7 Class Member Functions202</p><p>7.7.1 Defining the Body of a Member Function203</p><p>7.7.2 Defining a Member Function Outside the Class204</p><p>7.7.3 Writing the Sales item Constructor205</p><p>7.7.4 Organizing Class Code Files207</p><p>7.8 Overloaded Functions208</p><p>7.8.1 Overloading and Scope210</p><p>7.8.2 Function Matching and Argument Conversions211</p><p>7.8.3 The Three Steps in Overload Resolution212</p><p>7.8.4 Argument-Type Conversions214</p><p>7.9 Pointers to Functions217</p><p>Chapter 8 The IO Library（新增评注11条）221</p><p>8.1 An Object-Oriented Library222</p><p>8.2 Condition States224</p><p>8.3 Managing the Output Buffer227</p><p>8 4 File Input and Output229</p><p>8.4.1 Using File Stream Objects229</p><p>8.4.2 File Modes232</p><p>8.4.3 A Program to Open and Check Input Files234</p><p>8.5 String Streams234</p><p>Part Ⅱ Containers and Algorithms237</p><p>Chapter 9 Sequential Containers（新增评注54条）239</p><p>9.1 Defining a Sequential Container240</p><p>9.1.1 Initializing Container Elements241</p><p>9.1.2 Constraints on Types that a Container Can Hold243</p><p>9.2 Iterators and Iterator Ranges244</p><p>9.2.1 Iterator Ranges246</p><p>9.2.2 Some Container Operations Invalidate Iterators247</p><p>9.3 Sequence Container Operations248</p><p>9.3.1 Container Typedefs248</p><p>9.3.2 begin and end Members249</p><p>9.3.3 Adding Elements to a Sequential Container249</p><p>9.3.4 Relational Operators252</p><p>9.3.5 Container Size Operations254</p><p>9.3.6 Accessing Elements255</p><p>9.3.7 Erasing Elements256</p><p>9.3.8 Assignment and swap258</p><p>9.4 How a vector Grows259</p><p>9.4.1 capacity and reserve Members260</p><p>9.5 Deciding Which Container to Use262</p><p>9.6 strings Revisited264</p><p>9.6.1 Other Ways to Construct strings266</p><p>9.6.2 Other Ways to Change a string267</p><p>9.6.3 string-Only Operations268</p><p>9.6.4 string Search Operations270</p><p>9.6.5 Comparing strings272</p><p>9.7 Container Adaptors274</p><p>9.7.1 Stack Adaptor275</p><p>9.7.2 Queue and Priority Queue276</p><p>Chapter 10 Associative Containers（新增评注22条）279</p><p>10.1 Preliminaries:the pair Type280</p><p>10.2 Associative Containers282</p><p>10.3 The map Type283</p><p>10.3.1 Defining a map283</p><p>10.3.2 Types Defined by map284</p><p>10.3.3 Adding Elements to a map285</p><p>10.3.4 Subscripting a map285</p><p>10.3.5 Using map::insert287</p><p>10.3.6 Finding and Retrieving a map Element289</p><p>10.3.7 Erasing Elements from a map290</p><p>10.3.8 Iterating across a map290</p><p>10.3.9 A Word Transformation Map291</p><p>10.4 The set Type293</p><p>10.4.1 Defining and Using sets293</p><p>10.4.2 Building a Word-Exclusion Set295</p><p>10.5 The multimap and multiset Types296</p><p>10.5.1 Adding and Removing Elements296</p><p>10.5.2 Finding Elements in a multimap or multiset296</p><p>10.6 Using Containers:Text-Query Program299</p><p>10.6.1 Design of the Query Program300</p><p>10.6.2 TextQuery Class301</p><p>10.6.3 Using the TextQuery Class302</p><p>10.6.4 Writing the Member Functions304</p><p>Chapter 11 Generic Algorithms（新增评注18条）307</p><p>11.1 Overview308</p><p>11.2 A First Look at the Algorithms311</p><p>11.2.1 Read-Only Algorithms311</p><p>11.2.2 Algorithms that Write Container Elements313</p><p>11.2.3 Algorithms that Reorder Container Elements315</p><p>11.3 Revisiting Iterators319</p><p>11.3.1 Insert Iterators319</p><p>11.3.2 iostream Iterators320</p><p>11.3.3 Reverse Iterators324</p><p>11.3.4 const Iterators327</p><p>11.3.5 The Five Iterator Categories327</p><p>11.4 Structure of Generic Algorithms330</p><p>11.4.1 Algorithm Parameter Patterns330</p><p>11.4.2 Algorithm Naming Conventions331</p><p>11.5 Container-Specific Algorithms332</p><p>Part Ⅲ Classes and Data Abstraction335</p><p>Chapter 12 Classes（新增评注26条）337</p><p>12.1 Class Definitions and Declarations338</p><p>12.1.1 Class Definitions:A Recap338</p><p>12.1.2 Data Abstraction and Encapsulation339</p><p>12.1.3 More on Class Definitions341</p><p>12.1.4 Class Declarations versus Definitions344</p><p>12.1.5 Class Objects345</p><p>12.2 The Implicit this Pointer346</p><p>12.3 Class Scope349</p><p>12.3.1 Name Lookup in Class Scope351</p><p>12.4 Constructors355</p><p>12.4.1 The Constructor Initializer357</p><p>12.4.2 Default Arguments and Constructors360</p><p>12.4.3 The Default Constructor361</p><p>12.4.4 Implicit Class-Type Conversions363</p><p>12.4.5 Explicit Initialization of Class Members365</p><p>12.5 Friends366</p><p>12.6 static Class Members368</p><p>12.6.1 static Member Functions369</p><p>12.6.2 static Data Members370</p><p>Chapter 13 Copy Control（新增评注30条）373</p><p>13.1 The Copy Constructor374</p><p>13.1.1 The Synthesized Copy Constructor377</p><p>13.1.2 Defining Our Own Copy Constructor377</p><p>13.1.3 Preventing Copies378</p><p>13.2 The Assignment Operator379</p><p>13.3 The Destructor380</p><p>13.4 A Message-Handling Example382</p><p>13.5 Managing Pointer Members387</p><p>13.5.1 Defining Smart Pointer Classes389</p><p>13.5.2 Defining Valuelike Classes393</p><p>Chapter 14 Overloaded Operations and Conversions（新增评注31条）395</p><p>14.1 Defining an Overloaded Operator396</p><p>14.1.1 Overloaded Operator Design399</p><p>14.2 Input and Output Operators402</p><p>14.2.1 Overloading the Output Operator&lt;&lt;402</p><p>14.2.2 Overloading the Input Operator&gt;&gt;404</p><p>14.3 Arithmetic and Relational Operators405</p><p>14.3.1 Equality Operators406</p><p>14.3.2 Relational Operators407</p><p>14.4 Assignment Operators408</p><p>14.5 Subscript Operator409</p><p>14.6 Member Access Operators410</p><p>14.7 Increment and Decrement Operators413</p><p>14.8 Call Operator and Function Objects416</p><p>14.8.1 Using Function Objects with Library Algorithms417</p><p>14.8.2 Library-Defined Function Objects418</p><p>14.8.3 Function Adaptors for Function Objects419</p><p>14.9 Conversions and Class Types420</p><p>14.9.1 Why Conversions Are Useful421</p><p>14.9.2 Conversion Operators421</p><p>14.9.3 Argument Matching and Conversions424</p><p>14.9.4 Overload Resolution and Class Arguments427</p><p>14.9.5 Overloading,Conversions,and Operators430</p><p>Part Ⅳ Object-Oriented and Generic Programming435</p><p>Chapter 15 Object-Oriented Programming（新增评注56条）437</p><p>15.1 OOP:An Overview438</p><p>15.2 Defining Base and Derived Classes439</p><p>15.2.1 Defining a Base Class440</p><p>15.2.2 protected Members441</p><p>15.2.3 Derived Classes442</p><p>15.2.4 virtual and Other Member Functions445</p><p>15.2.5 Public,Private,and Protected Inheritance448</p><p>15.2.6 Friendship and Inheritance452</p><p>15.2.7 Inheritance and Static Members452</p><p>15.3 Conversions and Inheritance453</p><p>15.3.1 Derived-to-Base Conversions453</p><p>15.3.2 Conversions from Base to Derived455</p><p>15.4 Constructors and Copy Control456</p><p>15.4.1 Base-Class Constructors and Copy Control456</p><p>15.4.2 Derived-Class Constructors456</p><p>15.4.3 Copy Control and Inheritance459</p><p>15.4.4 Virtual Destructors462</p><p>15.4.5 Virtuals in Constructors and Destructors463</p><p>15.5 Class Scope under Inheritance464</p><p>15.5.1 Name Lookup Happens at CompileTime464</p><p>15.5.2 Name Collisions and Inheritance465</p><p>15.5.3 Scope and Member Functions466</p><p>15.5.4 Virtual Functions and Scope467</p><p>15.6 Pure Virtual Functions468</p><p>15.7 Containers and Inheritance469</p><p>15.8 Handle Classes and Inheritance470</p><p>15.8.1 A Pointerlike Handle471</p><p>15.8.2 Cloning an Unknown Type473</p><p>15.8.3 Using the Handle475</p><p>15.9 Text Queries Revisited478</p><p>15.9.1 An Object-Oriented Solution479</p><p>15.9.2 A Valuelike Handle480</p><p>15.9.3 The Query_base Class482</p><p>15.9.4 The Query Handle Class483</p><p>15.9.5 The Derived Classes485</p><p>15.9.6 The eval Functions487</p><p>Chapter 16 Templates and Generic Programming（新增评注31条）491</p><p>16.1 Template Definitions492</p><p>16.1.1 Defining a Function Template492</p><p>16.1.2 Defining a Class Template494</p><p>16.1.3 Template Parameters495</p><p>16.1.4 Template Type Parameters497</p><p>16.1.5 Nontype Template Parameters499</p><p>16.1.6 Writing Generic Programs500</p><p>16.2 Instantiation501</p><p>16.2.1 Template Argument Deduction503</p><p>16.2.2 Function-Template Explicit Arguments506</p><p>16.3 Template Compilation Models508</p><p>16.4 Class Template Members511</p><p>16.4.1 Class-Template Member Functions513</p><p>16.4.2 Template Arguments for Nontype Parameters517</p><p>16.4.3 Friend Declarations in Class Templates517</p><p>16.4.4 Queue and Queue Item Friend Declarations520</p><p>16.4.5 Member Templates522</p><p>16.4.6 The Complete Queue Class524</p><p>16.4.7 static Members of Class Templates525</p><p>16.5 A Generic Handle Class526</p><p>16.5.1 Defining the Handle Class527</p><p>16.5.2 Using the Handle528</p><p>16.6 Template Specializations530</p><p>16.6.1 Specializing a Function Template531</p><p>16.6.2 Specializing a Class Template533</p><p>16.6.3 Specializing Members but Not the Class535</p><p>16.6.4 Class-Template Partial Specializations536</p><p>16.7 Overloading and Function Templates537</p><p>Part Ⅴ Advanced Topics541</p><p>Chapter 17 Tools for Large Programs（新增评注37条）543</p><p>17.1 Exception Handling544</p><p>17.1.1 Throwing an Exception of Class Type545</p><p>17.1.2 Stack Unwinding546</p><p>17.1.3 Catching an Exception548</p><p>17.1.4 Rethrow549</p><p>17.1.5 The Catch-All Handler550</p><p>17.1.6 Function Try Blocks and Constructors550</p><p>17.1.7 Exception Class Hierarchies551</p><p>17.1.8 Automatic Resource Deallocation553</p><p>17.1.9 The auto_ptr Class555</p><p>17.1.10 Exception Specifications559</p><p>17.1.11 Function Pointer Exception Specifications562</p><p>17.2 Namespaces563</p><p>17.2.1 Namespace Definitions563</p><p>17.2.2 Nested Namespaces567</p><p>17.2.3 Unnamed Namespaces568</p><p>17.2.4 Using Namespace Members569</p><p>17.2.5 Classes,Namespaces,and Scope573</p><p>17.2.6 Overloading and Namespaces575</p><p>17.2.7 Namespaces and Templates578</p><p>17.3 Multiple and Virtual Inheritance578</p><p>17.3.1 Multiple Inheritance578</p><p>17.3.2 Conversions and Multiple Base Classes581</p><p>17.3.3 Copy Control for Multiply Derived Classes583</p><p>17.3.4 Class Scope under Multiple Inheritance583</p><p>17.3.5 Virtual Inheritance586</p><p>17.3.6 Virtual Base Class Declaration587</p><p>17.3.7 Special Initialization Semantics589</p><p>Chapter 18 Specialized Tools and Techniques（新增评注22条）593</p><p>18.1 Optimizing Memory Allocation594</p><p>18.1.1 Memory Allocation in C++594</p><p>18.1.2 The allocator Class595</p><p>18.1.3 operator new and operator delete Functions598</p><p>18.1.4 Placement new Expressions600</p><p>18.1.5 Explicit Destructor Invocation601</p><p>18.1.6 Class Specific new and delete601</p><p>18.1.7 A Memory-Allocator Base Class603</p><p>18.2 Run-Time Type Identification608</p><p>18.2.1 The dynamic_cast Operator609</p><p>18.2.2 The typeid Operator611</p><p>18.2.3 Using RTTI612</p><p>18.2.4 The type_info Class614</p><p>18.3 Pointer to Class Member615</p><p>18.3.1 Declaring a Pointer to Member615</p><p>18.3.2 Using a Pointer to Class Member617</p><p>18.4 Nested Classes620</p><p>18.4.1 A Nested-Class Implementation620</p><p>18.4.2 Name Lookup in Nested Class Scope623</p><p>18.5 Union:A Space-Saving Class625</p><p>18.6 Local Classes627</p><p>18.7 Inherently Nonportable Features629</p><p>18.7.1 Bit-fields629</p><p>18.7.2 volatile Qualifier630</p><p>18.7.3 Linkage Directives:extern&quot;C&quot;632</p><p>Appendix A The Library635</p><p>A.1 Library Names and Headers636</p><p>A.2 A Brief Tour of the Algorithms637</p><p>A.2.1 Algorithms to Find an Object637</p><p>A.2.2 Other Read-Only Algorithms638</p><p>A.2.3 Binary-Search Algorithms639</p><p>A.2.4 Algorithms that Write Container Elements639</p><p>A.2.5 Partitioning and Sorting Algorithms641</p><p>A.2.6 General Reordering Operations643</p><p>A.2.7 Permutation Algorithms644</p><p>A.2.8 Set Algorithms for Sorted Sequences645</p><p>A.2.9 Minimum and Maximum Values646</p><p>A.2.10 Numeric Algorithms646</p><p>A.3 The IO Library Revisited648</p><p>A.3.1 Format State648</p><p>A.3.2 Many Manipulators Change the Format State648</p><p>A.3.3 Controlling Output Formats649</p><p>A.3.4 Controlling Input Formatting654</p><p>A.3.5 Unformatted Input/Output Operations655</p><p>A.3.6 Single-Byte Operations655</p><p>A.3.7 Multi-Byte Operations656</p><p>A.3.8 Random Access to a Stream658</p><p>A.3.9 Reading and Writing to the Same File660</p><p></p></div></div><div class="d-rt"><h3>热门推荐</h3><ul><li><a href="/book/2018923.html">2018923.html</a></li><li><a href="/book/2815588.html">2815588.html</a></li><li><a href="/book/446155.html">446155.html</a></li><li><a href="/book/763159.html">763159.html</a></li><li><a href="/book/163708.html">163708.html</a></li><li><a href="/book/2113228.html">2113228.html</a></li><li><a href="/book/2116837.html">2116837.html</a></li><li><a href="/book/224130.html">224130.html</a></li><li><a href="/book/1786245.html">1786245.html</a></li><li><a href="/book/586268.html">586268.html</a></li></ul></div></div><div id="footer"><p>Copyright&nbsp;&copy;&nbsp;2025&nbsp;&nbsp;<a href="/list/">最新更新</a></p><p>请使用FDM BitComet qBittorrent uTorrent等BT下载工具，下载本站电子书资源！首推Free Download Manager下载软件。文件页数>标注页数[分册图书除外]</p></div></body></html>