<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><script type="text/javascript" src="https://file.bkxsj.com/skin/book/js/sk.js"></script><meta name="robots" content="index,follow"><title>UNITY 3D SHABERLAB开发实战详解 第2版[PDF|Epub|txt|kindle电子书版本网盘下载]-灵感之桥</title><meta name="Keywords" content="UNITY 3D SHABERLAB开发实战详解 第2版"/><meta name="description" content="UNITY 3D SHABERLAB开发实战详解 第2版pdf下载文件大小为72MB,PDF页数为353页"/><meta http-equiv="X-UA-Compatible" content="IE=9; IE=8; IE=7; IE=EDGE;chrome=1"><link type="image/x-icon" rel="shortcut icon" href="https://www.shukui.net/skin/book/images/favicon.ico"><link type="text/css" rel="stylesheet" href="https://www.shukui.net/skin/book/css/style.css"><style>#main .d-main {margin-left: 0;width: 620px;}.down-btn {animation: myShake 2.5s linear .15s infinite}@keyframes myShake {0%, 66% {transform: translateZ(0)}67%, 73.6%, 83.6%, 93.6%, to {animation-timing-function: cubic-bezier(.215, .61, .355, 1);transform: translateZ(0)}80.3%, 81.4% {animation-timing-function: cubic-bezier(.755, .05, .855, .06);transform: translate3d(0, -4px, 0)}90.3% {animation-timing-function: cubic-bezier(.755, .05, .855, .06);transform: translate3d(0, -2px, 0)}97% {transform: translate3d(0, -.5px, 0)}}.copylink-btn {margin-right: 20px;}.copymd5-btn {margin-bottom: 25px;margin-left: 10px;}</style></head><body><div id="header"><div class="inner"><div class="logo"><a href="/"><img width="103" height="25" alt="灵感之桥"src="https://www.shukui.net/skin/book/images/logo.png"></a></div><div class="search"><form action="/so/search.php" target="_blank"><input type="text" autocomplete="off" id="bdcsMain" name="q" placeholder="书名 / 作者 / 出版社 / ISBN"class="inp-txt"><select class="inp-select" id="datasource" onchange="selectDatasource(this)"><option value="so">主库</option><option value="s">从库</option></select><input type="submit" value="搜索" class="inp-btn"></form></div></div></div><div id="main"><div class="d-main"><div class="tit"><h3>图书介绍</h3></div><h1 class="book-name">UNITY 3D SHABERLAB开发实战详解 第2版PDF|Epub|txt|kindle电子书版本网盘下载</h1><div class="d-info"><div class="b-thumb"><img src="https://www.shukui.net/cover/30/30979013.jpg" alt="UNITY 3D SHABERLAB开发实战详解 第2版"></div><div class="b-info"><ul><li>郭浩瑜编著 著</li><li>出版社： 北京：人民邮电出版社</li><li>ISBN：9787115386243</li><li>出版时间：2015</li><li>标注页数：323页</li><li>文件大小：72MB</li><li>文件页数：353页</li><li>主题词：游戏程序－程序设计</li></ul></div></div><div class="tit"><h3>PDF下载</h3></div><div></br><a style="color:red;" rel="external nofollow" href="https://www.kjlm.net/ebook/886292.html"target="_blank"><b>点此进入-本书在线PDF格式电子书下载【推荐-云解压-方便快捷】直接下载PDF格式图书。移动端-PC端通用</a></b></br><a class="down-btn" rel="external nofollow" href="https://down.trackerbk.com/bt/02/30979013.torrent"target="_blank">种子下载</a>[BT下载速度快]温馨提示：（请使用BT下载软件FDM进行下载）<a rel="nofollow" href="https://www.freedownloadmanager.org/zh/" target="_blank">软件下载地址页</a><a class="down-btn" rel="external nofollow" href="https://down.p2spdb.com/02/30979013.rar" target="_blank">直链下载</a>[便捷但速度慢]&nbsp;&nbsp;<a style="color:red;" rel="external nofollow" href="https://pdfyl.ertongbook.com/20/30979013.pdf" target="_blank"><b>[在线试读本书]</b></a>&nbsp;&nbsp;<b> <a style="color:red;" rel="external nofollow" href="https://web.jyjl.org/index/recovery.html" target="_blank">[在线获取解压码]</a></b><div class="copymd5-btn"><a href="javascript:copyToClip('b75fe8a501107d1a517332cf5d9a8499')">点击复制MD5值：b75fe8a501107d1a517332cf5d9a8499</a></div></div><div class="tit"><h3>下载说明</h3></div><div style="margin:20px 10px"><h2>UNITY 3D SHABERLAB开发实战详解 第2版PDF格式电子书版下载</h2>下载的文件为RAR压缩包。需要使用解压软件进行解压得到PDF格式图书。<br><br><div class="copymd5-btn"><a href="javascript:copyToClip('magnet:?xt=urn:btih:RX6G6JQ2LJW7PBBEDNUSCQM7ICDMHIWK')">点击复制85GB完整离线版磁力链接到迅雷FDM等BT下载工具进行下载</a>&nbsp;&nbsp;<a rel="nofollow" target="_blank">详情点击-查看共享计划</a></div>建议使用BT下载工具Free Download Manager进行下载,简称FDM(免费,没有广告,支持多平台）。本站资源全部打包为BT种子。所以需要使用专业的BT下载软件进行下载。如BitComet qBittorrent uTorrent等BT下载工具。迅雷目前由于本站不是热门资源。不推荐使用！后期资源热门了。安装了迅雷也可以迅雷进行下载！<br><br><b>（文件页数 要大于 标注页数，上中下等多册电子书除外）</b><br><br><p style="color:red;"> <b>注意：本站所有压缩包均有解压码：</b> <a rel="nofollow" target="_blank"><b>点击下载压缩包解压工具</b></a></p></div><div class="tit"><h3>图书目录</h3></div><div id="book-contents"><p>第1篇初识庐山真面目——Unity 3D Shader2</p><p>第1章 虚拟世界的“魔法”——Shader（着色器）的概念和在3D游戏中的作用2</p><p>1.1 Shader的概念2</p><p>1.1.1 虚拟世界中的光明和色彩2</p><p>1.1.2 游戏开发人员的终点2</p><p>1.1.3 Shader（着色器）简史2</p><p>1.2 Shader的实例化3</p><p>1.3 Shader的实现语言3</p><p>1.3.1 GPU上的编程3</p><p>1.3.2 Unity中的着色器编程3</p><p>第2章 Unity中Shader（着色器）的形态4</p><p>2.1 Unity通过ShaderLab来组织Shader4</p><p>2.1.1 关键字Shader4</p><p>2.1.2 使用SubShader组织Shader的不同实现4</p><p>2.1.3 SubShader的重要标签4</p><p>2.1.4 SubShader中的Pass块5</p><p>2.1.5 Pass块的标签及其名字的意义5</p><p>2.1.6 使用FallBack保证Shader的广泛适应性6</p><p>2.2 Unity的ShaderLab所支持的Shader编程语言6</p><p>2.3 Unity中Shader的3种形态6</p><p>2.3.1 固定管线6</p><p>2.3.2 可编程Shader7</p><p>2.3.3 ShaderLab的骄傲：Surface Shader8</p><p>2.4 Shader的数据接口：属性和uniform变量8</p><p>2.4.1 在Properties块中定义属性8</p><p>2.4.2 通过图形界面操作属性9</p><p>2.4.3 通过脚本操控属性9</p><p>2.4.4 矩阵：不能在属性块定义的变量10</p><p>2.4.5 在Cg代码中使用属性10</p><p>第3章 Shader（着色器）中用到的各种空间概念11</p><p>3.1 模型空间11</p><p>3.1.1 为什么用模型空间11</p><p>3.1.2 在脚本和Shader中进出模型空间11</p><p>3.2 世界坐标空间11</p><p>3.2.1 统一表达：世界坐标空间11</p><p>3.2.2 在脚本和Shader中进出世界坐标空间12</p><p>3.3 视空间12</p><p>3.3.1 渲染的需要：视空间12</p><p>3.3.2 在脚本和Shader中进出视空间12</p><p>3.4 空间的一块：视锥体12</p><p>3.5 剪切空间13</p><p>3.5.1 投影13</p><p>3.5.2 脚本和Shader中的投影矩阵13</p><p>3.5.3 验证NDC14</p><p>3.6 NDC之后14</p><p>3.6.1 NDC之后发生的事情14</p><p>第4章 基本的光照模型16</p><p>4.1 光源对物体照明的分类16</p><p>4.1.1 间接照明16</p><p>4.1.2 直接照明16</p><p>4.2 照明的计算方式：光照模型16</p><p>4.2.1 漫反射和Lambert16</p><p>4.2.2 镜面高光和Phong17</p><p>4.2.3 半角向量和BlinnPhong18</p><p>第2篇让你的应用更炫彩——Unity中的照明20</p><p>第5章 第一个被执行的Pass20</p><p>5.1 不同的LightMode被选择的顺序20</p><p>5.1.1 渲染路径和Pass的LightMode标签20</p><p>5.1.2 设计可以检测渲染路径的材质20</p><p>5.1.3 设计便于检测渲染路径的场景23</p><p>5.1.4 VertexLit渲染路径下Pass的执行23</p><p>5.1.5 Forward渲染路径下Pass的执行23</p><p>5.1.6 Deferred渲染路径下Pass的执行23</p><p>5.1.7 不同渲染路径下的Pass执行规则总结24</p><p>5.2 3个渲染路径之外24</p><p>5.2.1 LightMode的其他值24</p><p>5.2.2 设计检测用的材质24</p><p>5.2.3 Always类型的Pass在3种渲染路径下的执行26</p><p>5.2.4 LightMode的默认值及其在3种渲染路径下的执行27</p><p>第6章 VertexLit渲染路径28</p><p>6.1 顶点照明28</p><p>6.1.1 什么是顶点照明28</p><p>6.1.2 存取光源的变量28</p><p>6.2 顶点照明和Unity存放光源的第一种方式29</p><p>6.2.1 用于调试输出的材质29</p><p>6.2.2 设计用于检测的场景29</p><p>6.2.3 在Vertex Pass中的检测结果30</p><p>6.2.4 无效数据30</p><p>6.3 顶点照明和Unity存放光源的第二种方式31</p><p>6.3.1 用于调试输出的材质31</p><p>6.3.2 设计用于检测的场景32</p><p>6.3.3 在VertexPass中的检测结果32</p><p>6.4 顶点照明和Unity存放光源的第三种方式33</p><p>6.4.1 Unity为Vertex Pass准备的光源33</p><p>6.4.2 设计用于检测的场景33</p><p>6.4.3 顶点照明中的点光源33</p><p>6.4.4 计算顶点照明的ShadeVertexLights函数34</p><p>6.4.5 顶点照明中的Pixel光源34</p><p>6.4.6 顶点照明中的平行光35</p><p>6.4.7 顶点照明中的灯光信息小结37</p><p>6.4.8 一个顶点照明的实现例子37</p><p>第7章 Forward渲染路径39</p><p>7.1 渲染物体——ForwardBase和ForwardAdd39</p><p>7.1.1 设计检测用的场景和材质39</p><p>7.1.2 ForwardBase和ForwardAdd的表现41</p><p>7.2 Forward渲染路径下的重要光源41</p><p>7.2.1 设计检测用的材质41</p><p>7.2.2 不存在Pixel光源时的情况42</p><p>7.2.3 存在Pixel平行光时的情况42</p><p>7.2.4 存在Pixel点光源时的情况42</p><p>7.2.5 有多种类型的Pixel光源时的情况43</p><p>7.2.6 Forward渲染路径下的Pixel光源小结43</p><p>7.3 重要光源在ForwardAdd内的执行43</p><p>7.3.1 设计用来检测Pixel光源的材质43</p><p>7.3.2 设计检测用的场景46</p><p>7.3.3 检测结果：ForwardAdd如何被执行46</p><p>7.4 ForwardBase和Unity存放光源的第一种方式47</p><p>7.4.1 设计检测用的材质47</p><p>7.4.2 第一种方式内的Vertex点光源48</p><p>7.4.3 第一种方式内的平行光48</p><p>7.4.4 第一种方式内的重要Pixel点光源48</p><p>7.4.5 只有ForwardBase时的情况总结49</p><p>7.4.6 ForwardAdd对ForwardBase内光源的影响49</p><p>7.4.7 有ForwardAdd时存放光源数据第一种方式的总结51</p><p>7.5 ForwardAdd和Unity存放光源的第一种方式51</p><p>7.5.1 设计检测用的材质51</p><p>7.5.2 设计检测用的场景52</p><p>7.5.3 ForwardAdd内的Pixel光源52</p><p>7.5.4 ForwardAdd内的平行光53</p><p>7.5.5 数组变量unity_4LightPos的使用情况分析53</p><p>7.6 Forward渲染路径和Unity存放光源的第三种方式53</p><p>7.6.1 检测ForwardBase内情况的材质53</p><p>7.6.2 检测结果：第三种方式不包含对ForwardBase有效的数据54</p><p>7.6.3 检测结果：第三种方式不包含对ForwardAdd有效的数据54</p><p>7.7 Forward渲染路径总结55</p><p>7.7.1 Forward渲染路径下材质的适应性55</p><p>7.7.2 Unity如何为Forward渲染路径设置光源55</p><p>第8章 基于光照贴图的烘焙照明56</p><p>8.1 单光照贴图和VertexLit渲染路径56</p><p>8.1.1 测试烘焙的场景56</p><p>8.1.2 烘焙场景中使用的材质57</p><p>8.1.3 烘焙的前提：静态物体57</p><p>8.1.4 如何在烘焙中使用自发光材质57</p><p>8.1.5 烘焙之后静态物体和非静态物体的实时照明59</p><p>8.1.6 应用光照贴图到VertexLit渲染路径下的材质中59</p><p>8.1.7 通过自己的材质改变实时光源对烘焙后物体的照明61</p><p>8.2 在效果和性能间进行权衡62</p><p>8.2.1 影响全局的Resolution选项62</p><p>8.2.2 影响单个物体的Scale In Lightmap选项63</p><p>8.3 单光照贴图和Forward渲染路径64</p><p>8.3.1 单光照贴图在VertexLit和Forward下面的不同表现64</p><p>8.3.2 准备可应用于烘焙的自发光材质64</p><p>8.3.3 在ForwardBase内计算光照贴图66</p><p>8.3.4 Forward渲染路径下烘焙之后的实时照明67</p><p>8.4 单光照贴图在Deferred渲染路径下的实时阴影69</p><p>8.5 双光照贴图和Deferred渲染路径69</p><p>8.5.1 全局GI、间接照明以及双光照贴图69</p><p>8.5.2 混合双光照贴图和实时照明69</p><p>8.5.3 观察混合过程71</p><p>8.5.4 双光照贴图的使用限制72</p><p>8.6 双光照贴图和Forward渲染路径73</p><p>8.7 方向光照贴图和Forward渲染路径73</p><p>8.7.1 烘焙后的凹凸问题73</p><p>8.7.2 方向光照贴图（Direction Lightmaps）和凹凸贴图74</p><p>第9章 基于LightProbes的照明76</p><p>9.1 初识LightProbes76</p><p>9.1.1 LightProbes照明的优点76</p><p>9.1.2 检测LightProbes照明的场景76</p><p>9.1.3 使用Light Probe Group进行管理78</p><p>9.1.4 烘焙场景光照信息到LightProbes中78</p><p>9.1.5 对比Light Probes照明和实时照明79</p><p>9.2 放置LightProbes的注意事项79</p><p>9.2.1 必须形成一个体积79</p><p>9.2.2 单个Light Probe必须处于采样光源的照射范围79</p><p>9.3 动态更新LightProbes80</p><p>9.3.1 跟新数据的注意事项80</p><p>9.3.2 更改不同通道的Coefficient80</p><p>9.4 照明采样的Archor Override81</p><p>9.4.1 基于线性插值的采样81</p><p>9.4.2 改变默认的插值位置81</p><p>9.5 LightProbes照明和阴影82</p><p>9.5.1 LightProbes和光照贴图的异同82</p><p>9.5.2 烘焙阴影时可能会犯的错误82</p><p>9.5.3 将静态物体的阴影烘焙到Light Probe上83</p><p>9.5.4 LightProbes照明和实时阴影的混合84</p><p>9.6 烘焙一个色彩丰富的场景84</p><p>9.7 在自己的材质中使用LightProbes85</p><p>9.7.1 为Forward渲染路径的材质计算LightProbes86</p><p>9.7.2 使用ShadeSH9函数87</p><p>9.7.3 在一个Surface Shader中进行计算87</p><p>第3篇使应用更逼真——Shadows（阴影）90</p><p>第10章 平面阴影90</p><p>10.1 平行光对平面的投影90</p><p>10.1.1 对平行光投影的考虑90</p><p>10.1.2 进出阴影接受平面的矩阵90</p><p>10.1.3 使用三角形相似计算阴影91</p><p>10.2 点光源对平面的投影92</p><p>10.3 阴影的淡出93</p><p>10.3.1 有效利用计算平面阴影过程中的数据93</p><p>10.3.2 潜在的问题93</p><p>第11章 球体阴影94</p><p>11.1 平行光对球体的投影94</p><p>11.1.1 投影球体的信息94</p><p>11.1.2 使用相似三角形计算投影94</p><p>11.2 阴影的淡入／淡出95</p><p>11.3 点光源对球体的投影96</p><p>第12章 体积阴影97</p><p>12.1 将顶点沿某一方向挤出97</p><p>12.1.1 在Vertex函数中操作97</p><p>12.1.2 判断顶点是向光还是背光97</p><p>12.2 从Volumes中找到阴影区域98</p><p>12.2.1 两次挤出98</p><p>12.2.2 计算出阴影区域99</p><p>12.2.3 渲染阴影99</p><p>12.2.4 需要注意的问题100</p><p>第13章 阴影映射101</p><p>13.1 灯光空间和相机空间101</p><p>13.1.1 观察两个空间101</p><p>13.1.2 两个视角的Z深度101</p><p>13.1.3 渲染Z深度的材质101</p><p>13.2 投射Z深度102</p><p>13.2.1 准备灯光视角的投影矩阵102</p><p>13.2.2 在材质中计算投影后的Z深度103</p><p>13.3 比较Z深度105</p><p>13.3.1 比较Z深度的材质105</p><p>13.3.2 Z精度引起的问题106</p><p>13.3.3 增加Z的精度106</p><p>13.3.4 对Z值进行偏移107</p><p>第14章 内置的阴影109</p><p>14.1 投射阴影109</p><p>14.1.1 使用ShadowCaster投射阴影109</p><p>14.1.2 ShadowCaster里都做了什么110</p><p>14.1.3 写一个自己的ShadowCaster110</p><p>14.1.4 改变ShadowCaster的行为111</p><p>14.1.5 阴影和FallBack机制112</p><p>14.2 接受阴影113</p><p>14.3 Surface Shader和阴影114</p><p>14.3.1 Surface Shader的阴影和Fallback114</p><p>14.3.2 Surface Shader里的灯光参数和阴影114</p><p>14.3.3 Surface Shader对Forward渲染路径下阴影的支持114</p><p>第4篇Unity中的各种Shader118</p><p>第15章 Pass的通用指令开关118</p><p>15.1 使用LOD在运行时决定材质118</p><p>15.1.1 材质的LOD118</p><p>15.1.2 运行时设定单个材质的LOD118</p><p>15.1.3 设定全局所有材质的LOD119</p><p>15.1.4 Unity内置的LOD层级120</p><p>15.2 渲染队列120</p><p>15.2.1 标签队列和渲染顺序120</p><p>15.2.2 渲染队列和ZTest判断122</p><p>15.2.3 Unity中内置的渲染队列122</p><p>15.2.4 一个利用渲染队列的例子122</p><p>15.3 透明的产生122</p><p>15.3.1 Alpha检测和8种比较条件122</p><p>15.3.2 动态生成AlphaTest的材质122</p><p>15.3.3 动态生成Shader的内容124</p><p>15.3.4 结合AlphaTest和Blend操作124</p><p>15.4 混合操作125</p><p>15.4.1 什么是混合（Blend）操作125</p><p>15.4.2 动态生成测试用的材质125</p><p>15.4.3 生成Shader的代码127</p><p>15.4.4 检测不同的混合操作127</p><p>15.4.5 BlendOp选项128</p><p>15.4.6 动态生成带BlendOp选项的材质128</p><p>15.4.7 生成Shader的代码129</p><p>15.4.8 检测BlendOp操作130</p><p>15.4.9 两个使用Blend生成的效果130</p><p>15.5 使用通道遮罩（ColorMask）132</p><p>15.5.1 ColorMask的作用132</p><p>15.5.2 检测ColorMask132</p><p>15.5.3 一个使用ColorMask的例子133</p><p>15.6 ZTest（深度测试）134</p><p>15.6.1 存取场景的ZTest134</p><p>15.6.2 RenderType标签和生成ZTest的关联134</p><p>15.6.3 内置RenderType的值135</p><p>15.6.4 Forward渲染路径下的ZTest136</p><p>15.6.5 Deferred渲染路径下的ZTest137</p><p>15.7 对Z深度的偏移138</p><p>15.7.1 干预正常ZTest的手段138</p><p>15.7.2 动态改变Offset的参数138</p><p>15.7.3 观察Offset在不同应用条件下的表现139</p><p>15.8 面的剔除操作140</p><p>15.9 自动贴图坐标的生成140</p><p>15.9.1 ObjectLinear和等价的Cg代码141</p><p>15.9.2 EyeLinear和等价的Cg代码142</p><p>15.9.3 SphereMap和等价的Cg代码142</p><p>15.9.4 CubeReflect和等价的Cg代码143</p><p>15.9.5 CubeNormal和等价的Cg代码143</p><p>15.10 抓屏操作144</p><p>15.10.1 如何使用GrabPass144</p><p>15.10.2 一个模拟曲面反射的例子145</p><p>15.11 Fog（雾效）146</p><p>15.11.1 Fog和Unity的3种实现146</p><p>15.11.2 材质中对Fog的控制146</p><p>15.11.3 实现自己的Fog147</p><p>15.12 Stencil（蒙版）149</p><p>15.12.1 Stencil测试、Z深度和Alpha测试149</p><p>15.12.2 使用Stencil测试改变渲染结果149</p><p>15.12.3 综合使用Stencil和Queue150</p><p>第16章 固定管线152</p><p>16.1 Unity中固定管线的基本形态152</p><p>16.1.1 固定管线基本形态152</p><p>16.1.2 与照明相关的Material块153</p><p>16.1.3 处理纹理的SetTexture块153</p><p>16.1.4 基本形态的另一种写法153</p><p>16.1.5 Combine语句153</p><p>16.2 使用顶点色154</p><p>16.2.1 使用ColorMaterial154</p><p>16.2.2 使用Bind154</p><p>16.3 在固定管线中使用光照贴图155</p><p>16.4 嵌套Cg代码155</p><p>第17章 Surface Shader157</p><p>17.1 Surface Shader的适应性157</p><p>17.1.1 一个分析策略157</p><p>17.1.2 VertexLit渲染路径的检测材质157</p><p>17.1.3 Forward渲染路径的检测材质158</p><p>17.1.4 测试用的场景159</p><p>17.1.5 检测结果：不独立支持VertexLit渲染路径159</p><p>17.1.6 检测结果：对Forward渲染路径的有条件支持159</p><p>17.2 Surface Shader和Deferred渲染路径160</p><p>17.2.1 设计检测的策略和材质160</p><p>17.2.2 检测结果：Surface Shader对Deferred渲染路径的支持条件162</p><p>17.3 Forward渲染路径下的Surface Shader163</p><p>17.3.1 Cg代码完全体163</p><p>17.3.2 最简形式的等价Cg代码164</p><p>17.3.3 Cg代码对光照贴图的支持169</p><p>17.3.4 一个检测生成的ForwardBase场景170</p><p>17.3.5 自动生成的ForwardAdd171</p><p>17.3.6 参数noambient和novertexlights174</p><p>17.3.7 参数approxview和halfasview174</p><p>17.3.8 Forward渲染路径下的透明和混合模式参数175</p><p>17.3.9 加强Forward渲染路径下效果的参数177</p><p>17.4 Deferred渲染路径下的Surface Shader180</p><p>17.4.1 自动生成的PrePassBase和PrePassFinal180</p><p>17.4.2 PrePassBase都做了什么183</p><p>17.4.3 LightBuffer里面的东西185</p><p>17.4.4 计算LightBuffer所使用的材质186</p><p>17.4.5 PrePassFinal的工作191</p><p>17.4.6 FallBack和Surface Shader的阴影192</p><p>17.4.7 精简用的参数193</p><p>17.4.8 Vertex、finalcolor函数和addshadow选项194</p><p>17.4.9 Deferred模式下的材质透明194</p><p>17.4.10 decal参数195</p><p>第18章 凹凸材质196</p><p>18.1 切空间196</p><p>18.2 凹凸贴图196</p><p>18.2.1 计算到切空间的矩阵196</p><p>18.2.2 Unity中法线贴图的压缩格式197</p><p>18.2.3 使用切空间矩阵的另一种方法197</p><p>18.2.4 Unity对切空间计算的支持198</p><p>18.2.5 解压缩法线贴图的函数199</p><p>18.2.6 在切空间中计算高光199</p><p>18.2.7 Surface Shader和切空间200</p><p>18.3 Parallax Mapping（视差映射）200</p><p>18.3.1 Parallax Mapping及其别名200</p><p>18.3.2 一个使用灰度图来偏移UV的材质201</p><p>18.3.3 结合法线贴图202</p><p>18.3.4 用视角来决定UV偏移203</p><p>18.3.5 一个完整的实现203</p><p>18.4 Relief Mapping（地势映射）204</p><p>18.4.1 Parallax Mapping的极限和Relief Mapping的面世204</p><p>18.4.2 Relief Mapping的算法205</p><p>18.4.3 一个完整的实现206</p><p>第19章 卡通材质209</p><p>19.1 描边209</p><p>19.1.1 沿法线挤出轮廓209</p><p>19.1.2 容易产生的问题210</p><p>19.1.3 在视空间中挤出211</p><p>19.1.4 顶点位置的另一个含义212</p><p>19.1.5 调和法线和顶点方向213</p><p>19.1.6 判断顶点的指向213</p><p>19.1.7 不仅仅是轮廓214</p><p>19.1.8 通过Z偏移来描边216</p><p>19.2 卡通着色217</p><p>19.2.1 对光照进行离散化217</p><p>19.2.2 使用2D贴图重新映射光照219</p><p>第20章 镜面材质221</p><p>20.1 镜像一个相机221</p><p>20.1.1 镜子里的世界和我的计划221</p><p>20.1.2 在脚本中对位置和角度进行镜像221</p><p>20.2 使用镜像相机来渲染、投影222</p><p>20.2.1 镜面材质的工作：采样被投影的渲染结果222</p><p>20.2.2 脚本的工作：渲染镜像相机和设置投影矩阵223</p><p>20.3 镜像相机的近剪切平面和倾斜矩阵224</p><p>20.3.1 调节近剪切平面224</p><p>20.3.2 使用倾斜矩阵微调视锥体224</p><p>第21章 透明和半透明材质225</p><p>21.1 什么是半透明材质225</p><p>21.2 用简单来表达复杂225</p><p>21.3 透明材质226</p><p>第22章 体积雾229</p><p>22.1 距离的表达：相对于背景的体积雾229</p><p>22.1.1 需要计算的东西229</p><p>22.1.2 使用一个Pass来完成所有的计算229</p><p>22.1.3 黑色的雾效230</p><p>22.2 厚度的表达：物体形体的体积雾231</p><p>22.2.1 必须计算的两个数据231</p><p>22.2.2 在Unity中使用一个Pass来完成所有计算231</p><p>第23章 Wrap Model新解234</p><p>23.1 一个可调节的Wrap光照模型234</p><p>23.2 另一种实现途径234</p><p>23.2.1 基于不同构想的Wrap234</p><p>23.2.2 实现这种构想235</p><p>23.2.3 进一步的变通235</p><p>第24章 面积光236</p><p>24.1 线光源236</p><p>24.1.1 点、线、面236</p><p>24.1.2 如何理解一个线光源236</p><p>24.1.3 通过脚本传递线光源的几何信息236</p><p>24.1.4 计算线光源的照明237</p><p>24.1.5 线光源的辐射方向238</p><p>24.1.6 线光源的衰减238</p><p>24.2 面积光源239</p><p>24.2.1 面积光和线光源的不同239</p><p>24.2.2 通过脚本设定面积光的几何特性239</p><p>24.2.3 计算面积光240</p><p>24.2.4 和默认照明的整合242</p><p>第25章 体积光243</p><p>25.1 体积光和体积阴影243</p><p>25.1.1 什么是体积光243</p><p>25.1.2 体积光和体积阴影的关系243</p><p>25.2 实现体积光243</p><p>25.2.1 在Shader中表现体积光243</p><p>25.2.2 脚本的帮助244</p><p>第26章 材质替代渲染246</p><p>26.1 相机（Camera）和渲染消息246</p><p>26.1.1 相机的渲染消息发送顺序246</p><p>26.1.2 物体的渲染消息发送顺序247</p><p>26.1.3 相机和物体的渲染消息先后顺序248</p><p>26.1.4 存在两个相机时的渲染消息248</p><p>26.1.5 最后能改变Cull操作结果的地方249</p><p>26.1.6 最后能设置材质数据的地方249</p><p>26.2 相机（Camera）的渲染方法250</p><p>26.2.1 Render方法250</p><p>26.2.2 RenderWithShader方法251</p><p>26.3 如何使用RenderWithShader方法253</p><p>26.3.1 标签值不同的5个Shader253</p><p>26.3.2 调用RenderWithShader方法的脚本254</p><p>26.3.3 替换用的5个材质255</p><p>26.3.4 检测RenderWithShader方法的效果256</p><p>26.3.5 使用SubShader组织替代材质257</p><p>26.3.6 如何设置替代材质的属性257</p><p>26.3.7 将结果输出到屏幕上258</p><p>26.4 SetReplacementShader和ResetReplacementShader259</p><p>第27章 后期效果260</p><p>27.1 Graphics的两个方法260</p><p>27.1.1 与相机渲染方法的不同之处260</p><p>27.1.2 Blit方法的简单示例260</p><p>27.1.3 使用BlitMultiTap方法进行多重采样262</p><p>27.2 一个简单的调色265</p><p>27.2.1 调色用的脚本265</p><p>27.2.2 调色用的材质266</p><p>27.2.3 更高效的做法267</p><p>27.3 景深269</p><p>27.3.1 用于模糊图像的材质269</p><p>27.3.2 进行纵横两次模糊操作270</p><p>27.3.3 进行混合操作的脚本271</p><p>27.3.4 进行混合操作的材质271</p><p>27.3.5 提供一个可调节参数272</p><p>27.4 轮廓检测273</p><p>27.4.1 用脚本索要场景的Z深度和法线273</p><p>27.4.2 在材质中进行边缘检测273</p><p>27.5 扭曲275</p><p>27.5.1 通过UV操作扭曲图像275</p><p>27.5.2 限定扭曲的区域276</p><p>27.5.3 使用物体来做遮罩276</p><p>27.6 运动模糊279</p><p>27.6.1 如何记录运动轨迹279</p><p>27.6.2 实现运动模糊的材质279</p><p>27.6.3 用于完成整个过程的脚本280</p><p>27.6.4 通过Alpha和帧的混合操作实现运动模糊281</p><p>27.7 噪波281</p><p>27.7.1 根据Z深度来混合噪波282</p><p>27.7.2 根据明暗程度来混合噪波282</p><p>27.8 色彩的溢出283</p><p>27.8.1 色彩溢出的算法考量284</p><p>27.8.2 实现色彩溢出的采样计算284</p><p>第28章 地形286</p><p>28.1 地表的材质286</p><p>28.1.1 地面纹理的控制贴图286</p><p>28.1.2 如何自定义地表材质287</p><p>28.1.3 如何使用更多的纹理贴图288</p><p>28.2 花草的材质288</p><p>28.2.1 非Billboard类型花草的材质289</p><p>28.2.2 Terrain引擎传入的数据290</p><p>28.2.3 Billboard类型花草的材质290</p><p>28.2.4 自定义Detail Mesh的材质291</p><p>28.3 树木的材质291</p><p>28.3.1 树木的2D Billboard材质291</p><p>28.3.2 3D形态树木的材质292</p><p>28.3.3 应用Unity计算的Occlusion294</p><p>第29章 投影296</p><p>29.1 Unity的Projector296</p><p>29.1.1 Projector中的材质被执行的顺序296</p><p>29.1.2 如何写Projector使用的材质296</p><p>29.1.3 控制投影淡进淡出的矩阵297</p><p>29.2 实现自己的投影298</p><p>29.2.1 设定投影矩阵的脚本298</p><p>29.2.2 采样投影的材质299</p><p>29.2.3 直接投影到屏幕上300</p><p>29.2.4 模拟GUITexture301</p><p>29.3 模拟粒子的广告牌效果302</p><p>29.3.1 使用材质将物体面向相机302</p><p>29.3.2 保持旋转角度303</p><p>第30章 分割（Clip）一个物体305</p><p>30.1 分割一个物体的思路305</p><p>30.1.1 我们需要什么样的信息305</p><p>30.1.2 脚本的帮助305</p><p>30.1.3 在Shader中剪切一个物体305</p><p>第5篇Shader的组织和优化308</p><p>第31章 Shader的组织和复用308</p><p>31.1 cginc文件308</p><p>31.1.1 Unity的UnityCG.cginc文件308</p><p>31.1.2 定义自己的cginc文件308</p><p>31.1.3 使用自定义的cginc文件309</p><p>31.2 通过UsePass来复用310</p><p>31.2.1 定义自己要复用的Pass310</p><p>31.2.2 复用这些Pass311</p><p>31.3 定义自己的Shader关键字311</p><p>31.3.1 使用关键字改变Shader的行为311</p><p>31.3.2 定义自己的Shader关键字311</p><p>31.4 使用multi_compilee编译Shader的多个版本312</p><p>31.4.1 使用multi_compile实现多次编译312</p><p>31.4.2 在脚本中选择Shader的版本312</p><p>31.4.3 使用自定义的材质编辑器313</p><p>31.4.4 关于MaterialEditor314</p><p>31.5 Unity对DX11支持所带来的问题314</p><p>第32章 你必须知道的渲染概念316</p><p>32.1 逐顶点计算和逐像素计算316</p><p>32.1.1 逐顶点计算316</p><p>32.1.2 逐像素计算316</p><p>32.1.3 如何在这两个概念中取舍316</p><p>32.2 Draw Call的指标意义316</p><p>32.2.1 Draw Call的概念316</p><p>32.2.2 正确理解Draw Call对你开发应用的意义316</p><p>32.2.3 Batching的概念和Unity为优化Draw Call所做的工作317</p><p>32.2.4 优化Draw Call317</p><p>32.3 利用渲染队列的技巧317</p><p>32.3.1 渲染队列的概念317</p><p>32.3.2 设置RenderQueue的技巧317</p><p>第33章 基于渲染路径的优化318</p><p>33.1 VertexLit渲染路径下的优化318</p><p>33.1.1 VertexLit渲染路径的特点318</p><p>33.1.2 合理的光照计算318</p><p>33.2 Forward渲染路径下的优化318</p><p>33.2.1 Forward渲染路径的特点318</p><p>33.2.2 合理的光照计算318</p><p>33.3 Deferred渲染路径下的优化319</p><p>33.3.1 Deferred渲染路径的特点319</p><p>33.3.2 合理的灯光布局319</p><p>第34章 移动平台上的优化320</p><p>34.1 移动平台的特点320</p><p>34.2 一些指令的运算速度概念320</p><p>34.3 几何复杂度的考量320</p><p>34.4 贴图的问题321</p><p>34.5 数据类型的使用方式321</p><p>34.6 变量的使用322</p><p>34.7 慎用后期效果322</p><p>34.8 慎用透明效果322</p><p>附录 相关资源323</p><p></p></div></div><div class="d-rt"><h3>热门推荐</h3><ul><li><a href="/book/1020236.html">1020236.html</a></li><li><a href="/book/2659628.html">2659628.html</a></li><li><a href="/book/3570397.html">3570397.html</a></li><li><a href="/book/2971842.html">2971842.html</a></li><li><a href="/book/3790298.html">3790298.html</a></li><li><a href="/book/2733475.html">2733475.html</a></li><li><a href="/book/291971.html">291971.html</a></li><li><a href="/book/2867203.html">2867203.html</a></li><li><a href="/book/1209836.html">1209836.html</a></li><li><a href="/book/3638342.html">3638342.html</a></li></ul></div></div><div id="footer"><p>Copyright&nbsp;&copy;&nbsp;2025&nbsp;&nbsp;<a href="/list/">最新更新</a></p><p>请使用FDM BitComet qBittorrent uTorrent等BT下载工具，下载本站电子书资源！首推Free Download Manager下载软件。文件页数>标注页数[分册图书除外]</p></div></body></html>