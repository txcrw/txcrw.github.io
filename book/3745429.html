<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><script type="text/javascript" src="https://file.bkxsj.com/skin/book/js/sk.js"></script><meta name="robots" content="index,follow"><title>JavaScript征途[PDF|Epub|txt|kindle电子书版本网盘下载]-灵感之桥</title><meta name="Keywords" content="JavaScript征途"/><meta name="description" content="JavaScript征途pdf下载文件大小为283MB,PDF页数为852页"/><meta http-equiv="X-UA-Compatible" content="IE=9; IE=8; IE=7; IE=EDGE;chrome=1"><link type="image/x-icon" rel="shortcut icon" href="https://www.shukui.net/skin/book/images/favicon.ico"><link type="text/css" rel="stylesheet" href="https://www.shukui.net/skin/book/css/style.css"><style>#main .d-main {margin-left: 0;width: 620px;}.down-btn {animation: myShake 2.5s linear .15s infinite}@keyframes myShake {0%, 66% {transform: translateZ(0)}67%, 73.6%, 83.6%, 93.6%, to {animation-timing-function: cubic-bezier(.215, .61, .355, 1);transform: translateZ(0)}80.3%, 81.4% {animation-timing-function: cubic-bezier(.755, .05, .855, .06);transform: translate3d(0, -4px, 0)}90.3% {animation-timing-function: cubic-bezier(.755, .05, .855, .06);transform: translate3d(0, -2px, 0)}97% {transform: translate3d(0, -.5px, 0)}}.copylink-btn {margin-right: 20px;}.copymd5-btn {margin-bottom: 25px;margin-left: 10px;}</style></head><body><div id="header"><div class="inner"><div class="logo"><a href="/"><img width="103" height="25" alt="灵感之桥"src="https://www.shukui.net/skin/book/images/logo.png"></a></div><div class="search"><form action="/so/search.php" target="_blank"><input type="text" autocomplete="off" id="bdcsMain" name="q" placeholder="书名 / 作者 / 出版社 / ISBN"class="inp-txt"><select class="inp-select" id="datasource" onchange="selectDatasource(this)"><option value="so">主库</option><option value="s">从库</option></select><input type="submit" value="搜索" class="inp-btn"></form></div></div></div><div id="main"><div class="d-main"><div class="tit"><h3>图书介绍</h3></div><h1 class="book-name">JavaScript征途PDF|Epub|txt|kindle电子书版本网盘下载</h1><div class="d-info"><div class="b-thumb"><img src="https://www.shukui.net/cover/8/34939130.jpg" alt="JavaScript征途"></div><div class="b-info"><ul><li>朱印宏著 著</li><li>出版社： 北京：电子工业出版社</li><li>ISBN：9787121090868</li><li>出版时间：2009</li><li>标注页数：819页</li><li>文件大小：283MB</li><li>文件页数：852页</li><li>主题词：JAVA语言－程序设计</li></ul></div></div><div class="tit"><h3>PDF下载</h3></div><div></br><a style="color:red;" rel="external nofollow" href="https://www.kjlm.net/ebook/3745435.html"target="_blank"><b>点此进入-本书在线PDF格式电子书下载【推荐-云解压-方便快捷】直接下载PDF格式图书。移动端-PC端通用</a></b></br><a class="down-btn" rel="external nofollow" href="https://down.trackerbk.com/bt/10/34939130.torrent"target="_blank">种子下载</a>[BT下载速度快]温馨提示：（请使用BT下载软件FDM进行下载）<a rel="nofollow" href="https://www.freedownloadmanager.org/zh/" target="_blank">软件下载地址页</a><a class="down-btn" rel="external nofollow" href="https://down.p2spdb.com/10/34939130.rar" target="_blank">直链下载</a>[便捷但速度慢]&nbsp;&nbsp;<a style="color:red;" rel="external nofollow" href="https://pdfyl.ertongbook.com/86/34939130.pdf" target="_blank"><b>[在线试读本书]</b></a>&nbsp;&nbsp;<b> <a style="color:red;" rel="external nofollow" href="https://web.jyjl.org/index/recovery.html" target="_blank">[在线获取解压码]</a></b><div class="copymd5-btn"><a href="javascript:copyToClip('9ad83c352367aba51a132e1f65f01859')">点击复制MD5值：9ad83c352367aba51a132e1f65f01859</a></div></div><div class="tit"><h3>下载说明</h3></div><div style="margin:20px 10px"><h2>JavaScript征途PDF格式电子书版下载</h2>下载的文件为RAR压缩包。需要使用解压软件进行解压得到PDF格式图书。<br><br><div class="copymd5-btn"><a href="javascript:copyToClip('magnet:?xt=urn:btih:RX6G6JQ2LJW7PBBEDNUSCQM7ICDMHIWK')">点击复制85GB完整离线版磁力链接到迅雷FDM等BT下载工具进行下载</a>&nbsp;&nbsp;<a rel="nofollow" target="_blank">详情点击-查看共享计划</a></div>建议使用BT下载工具Free Download Manager进行下载,简称FDM(免费,没有广告,支持多平台）。本站资源全部打包为BT种子。所以需要使用专业的BT下载软件进行下载。如BitComet qBittorrent uTorrent等BT下载工具。迅雷目前由于本站不是热门资源。不推荐使用！后期资源热门了。安装了迅雷也可以迅雷进行下载！<br><br><b>（文件页数 要大于 标注页数，上中下等多册电子书除外）</b><br><br><p style="color:red;"> <b>注意：本站所有压缩包均有解压码：</b> <a rel="nofollow" target="_blank"><b>点击下载压缩包解压工具</b></a></p></div><div class="tit"><h3>图书目录</h3></div><div id="book-contents"><p>第1篇 壮志从戎3</p><p>第1章 与初学者谈谈JavaScript学习3</p><p>1.1 学之初，你应该清楚的几个概念3</p><p>1.1.1 B/S和C/S3</p><p>1.1.2 RWC和RIA4</p><p>1.1.3 结构、行为和表现4</p><p>1.2 审视JavaScript语言特性5</p><p>1.2.1 JavaScript是一门灵活的脚本语言5</p><p>1．过程化设计6</p><p>2．定义原型方法6</p><p>3．封装原型方法6</p><p>4．造车不如设计标准7</p><p>5．方法接龙7</p><p>6．实例体验8</p><p>1.2.2 JavaScript是基于对象的语言8</p><p>1．万物皆为对象8</p><p>2．奇怪的指针9</p><p>3．灵活的用法9</p><p>1.2.3 JavaScript是函数式语言10</p><p>1．八面玲珑的函数10</p><p>2．函数的作用域11</p><p>3．奇怪的函数闭包11</p><p>4．函数的上下文对象11</p><p>1.3 JavaScript语言风云录12</p><p>1.3.1 JavaScript寻根12</p><p>1.3.2 三国志——JavaScript、JScript和ECMAScript13</p><p>1.3.3 一个好汉三个帮——客户端的JavaScript实现14</p><p>1．DOM15</p><p>2．BOM15</p><p>1.3.4 春秋五霸——令人生畏的浏览器混战和兼容16</p><p>1．Mozilla16</p><p>2．IE16</p><p>3．Safari17</p><p>4．Opera17</p><p>5．Chrome17</p><p>6．浏览器兼容方法17</p><p>1.4 JavaScript运行环境18</p><p>1.4.1 宿主环境18</p><p>1.4.2 执行期环境19</p><p>1.5 JavaScript解析机制19</p><p>1.5.1 预编译19</p><p>1.5.2 执行期22</p><p>1.6 JavaScript执行顺序23</p><p>1.6.1 按HTML文档流顺序执行JavaScript代码23</p><p>1.6.2 预编译与执行顺序的关系24</p><p>1.6.3 按块执行JavaScript代码25</p><p>1.6.4 借助事件机制改变JavaScript执行顺序26</p><p>1.6.5 JavaScript输出脚本的执行顺序26</p><p>1.7 JavaScript应用范围29</p><p>1.7.1 客户端的JavaScript29</p><p>1.7.2 服务器端的JavaScript30</p><p>1.7.3 其他环境的JavaScript30</p><p>1.8 JavaScript开发工具箱30</p><p>1.8.1 关于Web浏览器30</p><p>1.8.2 关于JavaScript编辑器31</p><p>1.8.3 关于JavaScript测试和调试工具31</p><p>1．浏览器的错误控制平台31</p><p>2．Firebug33</p><p>3．HttpWatch33</p><p>4．Web Developer Toolbar34</p><p>5．JavaScript Debuger34</p><p>第2章 Hello，World——JavaScript开发初体验35</p><p>2.1 杨辉三角——第一个JavaScript程序35</p><p>2.1.1 万物皆有规律——问题分析37</p><p>2.1.2 递归算法设计38</p><p>2.1.3 优化算法设计39</p><p>2.1.4 输出杨辉三角39</p><p>2.2 在网页中嵌入JavaScript脚本40</p><p>2.2.1 使用script元素嵌入脚本40</p><p>1．设置脚本类型41</p><p>2．导入外部脚本文件41</p><p>3．设置脚本的字符编码42</p><p>4．设置脚本延迟执行42</p><p>5．设置脚本在服务器端执行42</p><p>2.2.2 探析外部脚本文件42</p><p>1．导入外部脚本文件43</p><p>2．何时使用外部JavaScript脚本文件44</p><p>2.2.3 注意JavaScript脚本文件的关联性44</p><p>2.2.4 使用接口技术解决JavaScript文件冲突45</p><p>2.2.5 JavaScript文件与CSS文件导入和执行冲突46</p><p>2.2.6 ＜script＞标签在文档中的位置48</p><p>2.2.7 杞人忧天——隐藏JavaScript脚本49</p><p>2.2.8 关注细节——使用noscript元素49</p><p>2.3 纠正编码习惯50</p><p>2.3.1 JavaScript编码基本规范51</p><p>1．JavaScript文件规范51</p><p>2．代码缩进51</p><p>3．代码长度51</p><p>4．代码注释51</p><p>5．变量声明52</p><p>6．函数声明52</p><p>7．标识符命名52</p><p>8．语句53</p><p>9．标签53</p><p>2.3.2 思路梳理器——写好注释53</p><p>1．单行注释53</p><p>2．多行注释54</p><p>2.3.3 留白的艺术——格式化代码55</p><p>1．使用空行分隔代码块55</p><p>2．空格是代码稀释剂55</p><p>3．嵌套与缩进55</p><p>4．换行缩进56</p><p>5．大括号的位置56</p><p>6．空结构的格式56</p><p>7．单句结构的格式56</p><p>2.4 程序调试57</p><p>2.4.1 简单的手工调试57</p><p>2.4.2 使用1st JavaScript Editor调试器进行调试58</p><p>1．逐步调试59</p><p>2．断点60</p><p>3．观察60</p><p>2.4.3 使用Microsoft Script Debugger进行调试61</p><p>2.4.4 异常处理63</p><p>1．异常处理的基本结构64</p><p>2．异常处理中的兼容问题64</p><p>3．打扫战场66</p><p>第2篇 沙场秋点兵69</p><p>第3章 运筹帷幄——俯瞰JavaScript语法体系69</p><p>3.1 JavaScript语言词法基础69</p><p>3.1.1 从字符编码开始接触JavaScript语言70</p><p>3.1.2 认识JavaScript的实词和虚词概念71</p><p>3.1.3 对大小写比较敏感的实词72</p><p>3.1.4 实词类型73</p><p>1．标识符73</p><p>2．直接量74</p><p>3．保留字74</p><p>3.1.5 虚词类型74</p><p>1．无意义的分隔符75</p><p>2．有意义的分隔符75</p><p>3．注释76</p><p>3.2 JavaScript语言句法基础77</p><p>3.2.1 认识句法三要素：词、句和段77</p><p>1．段落77</p><p>2．句子78</p><p>3．词语78</p><p>3.2.2 点号——逻辑域定位符79</p><p>3.2.3 逗号——连续运算符80</p><p>3.2.4 分号——语句分隔符81</p><p>3.2.5 冒号——逻辑声明符82</p><p>3.2.6 大括号——逻辑域分隔符82</p><p>3.2.7 中括号——有序列表分隔符84</p><p>3.2.8 小括号——强制运算符或逻辑分隔符85</p><p>第4章 JavaScript血液系统——数据、数据类型和变量89</p><p>4.1 从数据到类型89</p><p>4.1.1 数据的本质89</p><p>4.1.2 柔弱的JavaScript语言90</p><p>4.1.3 JavaScript的基本数据类型91</p><p>4.1.4 数之源——值类型和引用类型92</p><p>4.1.5 原始值和引用值的操作本质93</p><p>1．使用原始值93</p><p>2．使用引用值94</p><p>4.2 值类型数据96</p><p>4.2.1 线性思维的符号——数值96</p><p>1．数值直接量96</p><p>2．八进制和十六进制数值97</p><p>3．数值运算97</p><p>4．特殊数值98</p><p>4.2.2 形象思维的颜料——字符串99</p><p>1．字符串直接量99</p><p>2．转义序列100</p><p>3．字符串操作100</p><p>4.2.3 逻辑思维的卵细胞——布尔型101</p><p>4.2.4 空无道人——null101</p><p>4.2.5 人之初——undefined102</p><p>4.3 引用类型数据103</p><p>4.3.1 有序数据结构——数组104</p><p>1．数组意象104</p><p>2．第一次接触数组105</p><p>4.3.2 离散数据结构——对象105</p><p>1．对象意象106</p><p>2．第一次接触对象106</p><p>4.3.3 魔兽数据——函数108</p><p>1．函数意象108</p><p>2．大话函数演绎之路108</p><p>3．探究奇特的函数解析机制110</p><p>4.4 数据类型检测和转换112</p><p>4.4.1 数据类型检测113</p><p>1．使用typeof运算符113</p><p>2．使用constructor属性113</p><p>3．框架窗口的数组类型问题114</p><p>4．设计更安全的数据类型检测方法115</p><p>4.4.2 值类型数据的自动转换117</p><p>4.4.3 引用型数据的自动转换118</p><p>1．对象在逻辑运算环境中的特殊情况118</p><p>2．对象在数值运算环境中的特殊情况118</p><p>3．数组在数值运算环境中的特殊情况119</p><p>4．对象在模糊运算环境中的情况处理119</p><p>4.4.4 把值转换为字符串120</p><p>1．使用加号运算符120</p><p>2．圆滑的加号运算符122</p><p>3．使用toString（）方法122</p><p>4．数字转换为字符串的模式问题122</p><p>5．数字转换为字符串的位数问题123</p><p>4.4.5 把值转换为数字124</p><p>1．使用parseInt（）函数124</p><p>2．使用parseFloat（）函数125</p><p>3．使用乘号运算符125</p><p>4.4.6 把值转换为布尔值125</p><p>1．使用双重逻辑非运算符125</p><p>2．使用Boolean（）构造函数转换126</p><p>4.4.7 装箱和拆箱126</p><p>1．从值到引用——装箱126</p><p>2．从引用到值——拆箱127</p><p>4.4.8 数据类型的强制转换128</p><p>4.5 使用变量129</p><p>4.5.1 声明变量129</p><p>1．变量声明的方法129</p><p>2．3种变量命名法130</p><p>4.5.2 丑陋的JavaScript变量131</p><p>1．陋习一：变量没有类型131</p><p>2．陋习二：变量可以重复声明131</p><p>3．陋习三：变量可以隐式声明132</p><p>4．陋习四：变量的灰色潜规则132</p><p>4.5.3 不可跨越的门槛——变量的作用域133</p><p>1．变量优先级问题133</p><p>2．局部作用域的嵌套134</p><p>3．利用函数作用域实现技术封装134</p><p>4．变量的解析过程135</p><p>5．被JavaScript忽略的块级作用域136</p><p>6．函数闭包的作用域136</p><p>4.5.4 圈里圈外——属性与变量137</p><p>1．全局变量是全局对象的属性137</p><p>2．局部变量是调用对象的属性138</p><p>4.5.5 变量的作用域链138</p><p>4.5.6 变量的垃圾回收139</p><p>第5章 JavaScript肌肉系统——运算符、表达式141</p><p>5.1 说说运算符和表达式141</p><p>5.1.1 语言实际上就是数据和运算的交流工具141</p><p>5.1.2 运算符是运算的解码器142</p><p>5.1.3 走入运算符的童话世界143</p><p>5.1.4 领略运算符的魔法法则144</p><p>5.1.5 运算的人性化，还是随意性146</p><p>5.1.6 警惕运算符的副作用147</p><p>5.1.7 表达式是运算的最小逻辑单元148</p><p>5.1.8 优化表达式的思维品质148</p><p>5.2 天人合一——位运算符151</p><p>5.2.1 位运算是整数的逐位运算151</p><p>5.2.2 探秘二进制数运算奥秘151</p><p>5.2.3 逻辑位运算153</p><p>5.2.4 移位运算155</p><p>5.3 童年无忌——算术运算符157</p><p>5.3.1 加法的特殊运算157</p><p>5.3.2 减法的特殊运算158</p><p>5.3.3 乘法的特殊运算159</p><p>5.3.4 除法的特殊运算159</p><p>5.3.5 取模的特殊运算160</p><p>5.3.6 取反运算160</p><p>5.3.7 心脏起搏器——递增和递减160</p><p>5.4 离散思维——字符串运算符161</p><p>5.5 真真假假论乾坤——逻辑运算符161</p><p>5.5.1 逻辑与运算162</p><p>5.5.2 逻辑或运算符164</p><p>5.5.3 逻辑非运算符166</p><p>5.5.4 逻辑思维训练166</p><p>5.6 货比三家——关系运算符168</p><p>5.6.1 大小关系检测168</p><p>5.6.2 包含关系检测169</p><p>5.6.3 等值关系检测170</p><p>5.7 复制数据——赋值运算符172</p><p>5.8 对象操作运算符174</p><p>5.8.1 女娲造人——new运算符174</p><p>5.8.2 垃圾回收站—delete运算符175</p><p>5.8.3 I/O接口——存取运算符177</p><p>1．中括号运算符177</p><p>2．点号运算符178</p><p>5.8.4 光盘驱动器——函数调用运算符179</p><p>5.9 其他运算符180</p><p>5.9.1 迷你版分支逻辑——条件运算符180</p><p>5.9.2 期待与收获——逗号运算符181</p><p>5.9.3 俯首甘为孺子牛——void运算符182</p><p>5.9.4 身份验证——类型检测运算符183</p><p>第6章 JavaScript神经骨骼系统——语句、结构185</p><p>6.1 从表达式到语句185</p><p>6.1.1 什么是句子186</p><p>6.1.2 两面性——表达式、表达式语句188</p><p>6.1.3 群居性——复合语句189</p><p>6.1.4 形影相随——句子、结构190</p><p>6.1.5 不被执行的——声明语句191</p><p>6.1.6 语句占位符——空语句193</p><p>6.2 分支结构193</p><p>6.2.1 if语句193</p><p>6.2.2 if结构嵌套194</p><p>1．错误的嵌套194</p><p>2．正确的嵌套195</p><p>6.2.3 else if语句195</p><p>6.2.4 预防if结构嵌套的主观性196</p><p>6.2.5 if结构中容易躲藏的Bug197</p><p>6.2.6 switch语句198</p><p>6.2.7 悟透default从句用法200</p><p>6.2.8 恰当选用if结构和switch结构202</p><p>6.2.9 分支结构中逻辑顺序的优化204</p><p>6.3 循环结构205</p><p>6.3.1 while语句205</p><p>6.3.2 do/while语句207</p><p>6.3.3 for语句207</p><p>6.3.4 for/in语句209</p><p>6.3.5 灵活使用for/in结构210</p><p>6.3.6 如何正确选用while和for结构212</p><p>1．从语义性角度比较212</p><p>2．从思维模式角度比较212</p><p>3．从达成目标角度比较214</p><p>6.3.7 优化循环结构和提高循环效率215</p><p>1．优化结构215</p><p>2．避免不必要的重复操作216</p><p>3．妥善定义循环变量216</p><p>6.4 结构的逻辑干预216</p><p>6.4.1 有序思维的锚点——标签语句217</p><p>6.4.2 跳出往后执行——break语句218</p><p>6.4.3 继续重新执行——continue语句220</p><p>6.5 逻辑异常处理222</p><p>6.5.1 剖析异常和异常种类222</p><p>6.5.2 知法犯法——throw语句223</p><p>6.5.3 异常处理器——try/catch/finally语句223</p><p>6.6 函数体结构225</p><p>6.6.1 惰性气体——function语句225</p><p>6.6.2 函数输出接口——return语句227</p><p>6.7 临时作用域结构——with语句228</p><p>第3篇 初战告捷233</p><p>第7章 盒子里的魔术——透视JavaScript函数233</p><p>7.1 认识函数233</p><p>7.1.1 函数是一段代码块234</p><p>7.1.2 函数是一类数据234</p><p>7.1.3 函数是一种对象234</p><p>7.2 定义JavaScript函数235</p><p>7.2.1 克隆结构——构造函数235</p><p>7.2.2 复杂结构的常量——函数直接量237</p><p>7.2.3 定义嵌套函数238</p><p>7.3 函数定义方法比较239</p><p>7.3.1 函数作用域的比较239</p><p>7.3.2 解析机制的比较240</p><p>7.3.3 兼容性和灵活性比较241</p><p>7.4 探析函数基本用法242</p><p>7.4.1 函数返回值242</p><p>7.4.2 调用函数243</p><p>7.4.3 函数的生命周期244</p><p>7.4.4 函数的作用域245</p><p>7.5 深入函数的参数246</p><p>7.5.1 认识函数的形参和实参247</p><p>7.5.2 参数管理器——Arguments对象248</p><p>7.5.3 回调函数——callee属性揭秘249</p><p>7.5.4 Arguments对象在实践中灵活应用250</p><p>7.6 使用函数对象251</p><p>7.6.1 获取函数形参个数251</p><p>7.6.2 灵敏的指针——有趣的this关键字252</p><p>7.6.3 双刃剑——正确使用this关键字253</p><p>7.6.4 自定义函数属性和方法255</p><p>7.6.5 储钱罐——巧用函数的属性实现蓄能256</p><p>7.6.6 谁的属性和方法—this与函数属性和方法的混合使用257</p><p>7.6.7 动态调用函数——诡异的call（）和apply（）方法258</p><p>7.6.8 更改指针——call（）和apply（）方法高级应用260</p><p>7.7 数据寄存器——闭包函数262</p><p>7.7.1 认识闭包262</p><p>7.7.2 分析闭包结构的基本特性263</p><p>1．自闭特性263</p><p>2．包裹特性263</p><p>7.7.3 闭包的基本应用264</p><p>第8章 大象也有形——把握JavaScript对象267</p><p>8.1 初识对象267</p><p>8.1.1 什么是对象268</p><p>8.1.2 对象是如何出生的268</p><p>8.2 对象类型269</p><p>8.2.1 本地对象269</p><p>8.2.2 内置对象270</p><p>8.2.3 宿主对象270</p><p>8.3 对象基本操作270</p><p>8.3.1 创建对象271</p><p>8.3.2 引用对象271</p><p>8.3.3 销毁对象272</p><p>8.4 对象的属性和方法272</p><p>8.4.1 定义对象的属性273</p><p>8.4.2 访问对象的属性273</p><p>8.4.3 设置和删除对象属性274</p><p>8.4.4 对象的方法275</p><p>8.5 对象的作用域276</p><p>8.5.1 公共作用域276</p><p>8.5.2 私有作用域277</p><p>8.5.3 静态作用域277</p><p>8.5.4 变形怪杰——作用域中的this278</p><p>8.6 构造对象、实例对象和原型对象279</p><p>8.6.1 构造对象279</p><p>1．构造对象的属性280</p><p>2．构造对象的方法280</p><p>8.6.2 实例对象281</p><p>1．实例对象的属性281</p><p>2．实例对象的方法282</p><p>8.6.3 原型对象282</p><p>1．认识原型对象282</p><p>2．原型属性与实例属性之间的关系284</p><p>3．通过原型方法扩展内置对象功能285</p><p>8.7 构造器285</p><p>8.7.1 引用构造器——constructor属性285</p><p>8.7.2 构造器的原型继承286</p><p>8.7.3 根据构造器判定对象类型287</p><p>8.8 对象基本方法和应用287</p><p>8.8.1 对象的字符串标志——toString（）方法288</p><p>8.8.2 对象的值——valueOf（）方法289</p><p>8.8.3 检测私有属性——hasOwnProperty（）方法290</p><p>8.8.4 检测枚举属性——propertyIsEnumerable（）方法291</p><p>8.8.5 检测原型对象——isPrototypeOf（）方法293</p><p>8.9 探析JavaScript核心对象294</p><p>8.9.1 大象无形——Global对象294</p><p>8.9.2 数学专家——Math对象295</p><p>8.9.3 时间管理——Date对象298</p><p>1．获取本地系统的当前时间298</p><p>2．通过多选参数来创建指定的时间对象298</p><p>3．通过一个时间格式的字符串来创建指定的时间对象298</p><p>4．通过传递一个毫秒数来创建指定的时间对象298</p><p>第9章 有序世界的信使——操作数组301</p><p>9.1 透视数据集合301</p><p>9.1.1 数据集合的类型301</p><p>9.1.2 特殊数集——哈希表302</p><p>9.2 定义数组303</p><p>9.3 数组基本操作304</p><p>9.3.1 存取数组元素304</p><p>9.3.2 能够自由伸缩的数组305</p><p>9.3.3 数组的大小306</p><p>9.3.4 对象与数组306</p><p>9.3.5 暗度陈仓——定义多维数组308</p><p>9.4 数组方法及其应用309</p><p>9.4.1 检索数组元素309</p><p>9.4.2 添加和删除元素309</p><p>1．push（）和pop（）方法310</p><p>2．unshift（）和shift（）方法310</p><p>3．模拟队列数据结构的操作311</p><p>4．粘连数组的concat（）方法311</p><p>9.4.3 子数组操作312</p><p>1．删除和插入元素集合——splice（）方法312</p><p>2．截取子数组——slice（）方法313</p><p>9.4.4 数组排序314</p><p>1．颠倒顺序——reverse（）方法314</p><p>2．数组排序——sort（）方法314</p><p>9.4.5 奇思妙想——更有趣的数组排序315</p><p>1．根据奇偶性质排列数组316</p><p>2．不区分大小写排序字符串316</p><p>3．把浮点数和整数分开排列317</p><p>9.4.6 数组与字符串相互转换317</p><p>1．字符串通用转换——toString（）方法317</p><p>2．本地字符串转换——toLocalString（）方法318</p><p>3．更灵活的字符串转换——join（）方法318</p><p>4．把字符串转换为数组——split（）方法318</p><p>9.5 灵活使用数组及其方法扩展319</p><p>9.5.1 神奇的数组下标319</p><p>1．文本下标319</p><p>2．二维数组下标320</p><p>3．对象下标321</p><p>9.5.2 扩展数组的基本方法321</p><p>9.5.3 为数组扩展通用迭代器322</p><p>9.5.4 利用数组迭代器扩展数组方法324</p><p>1．动态改变数组中每个元素的值324</p><p>2．过滤数组元素325</p><p>第10章 变相怪杰——驾驭字符串327</p><p>10.1 伤心字符串：使用值还是使用引用327</p><p>10.1.1 思考是发现问题的钥匙327</p><p>10.1.2 直击字符串操作的真相328</p><p>10.1.3 字符串是如何进行比较的330</p><p>10.2 创建字符串330</p><p>10.2.1 定义字符串直接量330</p><p>10.2.2 构造字符串331</p><p>10.2.3 使用字符编码创建字符串332</p><p>10.3 使用字符串333</p><p>10.3.1 获取字符串的字符和字节长度333</p><p>10.3.2 连接字符串335</p><p>10.3.3 查找字符串335</p><p>1．获取指定位置的字符——charAt（）和charCodeAt（）方法335</p><p>2．查找子字符串的位置——indexOf（）和lastIndexOf（）方法336</p><p>3．匹配字符串——search（）和match（）方法337</p><p>10.3.4 截取子字符串339</p><p>1．根据长度截取子字符串——substr（）方法339</p><p>2．根据起止下标截取子字符串——sfice（）和substring（）方法339</p><p>10.3.5 编辑字符串340</p><p>1．替换子字符串——replace（）方法340</p><p>2．字符串大小写转换342</p><p>10.3.6 暗藏玄机——replace（）方法深层技术探讨342</p><p>10.3.7 比较字符串344</p><p>10.3.8 把字符串转换为数组345</p><p>10.3.9 字符串的类型和值346</p><p>10.3.10 格式化字符串方法347</p><p>10.4 String对象扩展及用法348</p><p>10.4.1 模拟VBScript字符串处理函数348</p><p>1．截取字符串左侧指定数目的字符——left（）方法348</p><p>2．截取字符串右侧指定数目的字符——right（）方法349</p><p>3．清除字符串首尾的空格——trim（）方法349</p><p>4．清除字符串左侧空格——ITrim（）方法350</p><p>5．清除字符串右侧空格——rTrim（）方法350</p><p>10.4.2 检测特殊字符351</p><p>10.4.3 提高字符串连接操作效率352</p><p>10.5 字符串加密和解密352</p><p>10.5.1 JavaScript预定义编码和解码方法352</p><p>1．字符串常规编码和解码——eseape（）和unescape（）方法353</p><p>2．URI字符串编码和解码——encodeURI（）和decodeURI（）方法353</p><p>3．URI组件编码和解码——encodeURIComponent（）和decodeURIComponent（）方法354</p><p>10.5.2 Unicode编码355</p><p>10.5.3 Unicode解码355</p><p>10.5.4 自定义加密和解密方法356</p><p>第11章 灵异的牧羊犬——使用正则表达式操纵字符串359</p><p>11.1 第六感觉——认识正则表达式359</p><p>11.1.1 什么是正则表达式359</p><p>11.1.2 正则表达式的发展历史360</p><p>11.2 定义正则表达式361</p><p>11.2.1 使用RegExp对象构造正则表达式361</p><p>11.2.2 定义正则表达式直接量363</p><p>11.3 正则表达式基本语法——字符类364</p><p>11.3.1 认识普通字符和元字符364</p><p>11.3.2 字符直接量364</p><p>1．用ASCII码表示364</p><p>2．用Unicode编码表示365</p><p>11.3.3 定义简单字符类366</p><p>11.3.4 定义反义字符类366</p><p>11.3.5 定义字符范围类367</p><p>11.3.6 预定义字符类368</p><p>11.4 正则表达式基本语法——重复类数量词369</p><p>11.4.1 简单重复性匹配369</p><p>11.4.2 贪婪匹配371</p><p>1．？、｛n｝和｛n，m｝重复类371</p><p>2．＊、＋和｛n，｝重复类372</p><p>11.4.3 惰性匹配372</p><p>11.4.4 支配匹配373</p><p>11.5 高级匹配模式374</p><p>11.5.1 分组374</p><p>11.5.2 分组的应用价值375</p><p>11.5.3 引用376</p><p>11.5.4 非引用型分组377</p><p>11.5.5 选择378</p><p>11.5.6 声明380</p><p>11.5.7 边界380</p><p>11.5.8 锚记382</p><p>11.5.9 标志382</p><p>11.6 操作RegExp对象383</p><p>11.6.1 实例属性383</p><p>11.6.2 静态属性384</p><p>11.6.3 正则表达式的方法386</p><p>1．灵活的匹配操盘手——exec（）方法386</p><p>2．匹配验证——test（）方法387</p><p>11.6.4 比较各种模式匹配的方法388</p><p>第4篇 直捣黄龙393</p><p>第12章 BOM——探访客户的秘密393</p><p>12.1 认识浏览器对象模型（BOM）393</p><p>12.2 客户端全局对象——Window395</p><p>12.2.1 全局作用域396</p><p>12.2.2 Window对象的生命周期396</p><p>12.2.3 人机交互——学习JavaScript第一步397</p><p>12.2.4 控制弹出窗口398</p><p>12.2.5 框架之间的通信399</p><p>1．窗口不等于框架400</p><p>2．框架之间相互访问方式400</p><p>3．框架之间JavaScript交互400</p><p>12.3 检测客户浏览器信息——Navigator对象401</p><p>12.3.1 了解常用浏览器检测方法402</p><p>1．特征检测法402</p><p>2．字符串检测法402</p><p>12.3.2 检测浏览器类型和版本403</p><p>12.3.3 检测客户端操作系统404</p><p>12.4 客户端导航——Location和History对象405</p><p>12.4.1 全球定位仪——Location对象405</p><p>12.4.2 浏览简史——History对象407</p><p>1．使用JavaScript访问历史记录407</p><p>2．使用JavaScript访问帧的历史记录408</p><p>12.5 窗口大小控制——Screen和Window对象408</p><p>12.5.1 屏幕大小——Screen对象408</p><p>12.5.2 窗口大小——Window对象409</p><p>12.6 0级文档对象模型——Document对象410</p><p>12.6.1 认识文档对象——Document410</p><p>12.6.2 0级文档对象模型及其读写规则411</p><p>12.6.3 动态生成文档412</p><p>第13章 DOM——控制文档结构的模型415</p><p>13.1 认识DOM415</p><p>13.1.1 DOM发展概述415</p><p>1．DOM 0级416</p><p>2．DOM 1级416</p><p>3．DOM 2级416</p><p>4．DOM 3级417</p><p>13.1.2 检测浏览器对DOM规范支持程度417</p><p>13.1.3 DOM核心419</p><p>13.1.4 DOM节点420</p><p>13.2 操作DOM文档422</p><p>13.2.1 HTML DOM加载过程及其处理422</p><p>13.2.2 DOM文档支持的遍历指针424</p><p>1．childNodes425</p><p>2．firstChild和lastChild425</p><p>3．parentNode425</p><p>4．nextSibling和previousSibling426</p><p>5．documentElement426</p><p>13.2.3 文档遍历中的空格Bug及其清除426</p><p>13.2.4 实现一个简单的文档遍历427</p><p>13.2.5 扩展遍历指针函数428</p><p>1．扩展firstChild和lastChild指针函数429</p><p>2．扩展parentNode指针函数429</p><p>3．扩展nextSibling和previousSibling指针函数429</p><p>13.2.6 通过原型继承扩展DOM元素的方法430</p><p>13.2.7 增加文档内容433</p><p>13.3 操作DOM节点435</p><p>13.3.1 获取节点435</p><p>1．使用getElementByld（）方法435</p><p>2．使用getElementByTagName（）方法436</p><p>13.3.2 创建节点437</p><p>1．创建节点的基本用法437</p><p>2．创建DOM元素的通用方法438</p><p>13.3.3 复制节点439</p><p>13.3.4 插入节点440</p><p>1．使用appendChild（）方法440</p><p>2．使用insertBefore（）方法442</p><p>13.3.5 删除节点442</p><p>1．删除节点的基本用法443</p><p>2．封装删除节点的方法443</p><p>3．封装删除所有子节点的方法444</p><p>13.3.6 替换节点444</p><p>13.4 操作元素的属性445</p><p>13.4.1 获取节点属性446</p><p>13.4.2 设置节点属性447</p><p>13.4.3 删除节点属性448</p><p>13.4.4 存取JavaScript属性449</p><p>13.5 操作元素的内容449</p><p>13.5.1 获取元素包含的文本449</p><p>13.5.2 获取元素包含的HTML信息450</p><p>第14章 Event——JavaScript事件驱动模型453</p><p>14.1 认识JavaScript事件453</p><p>14.1.1 你未必理解的事件概念453</p><p>14.1.2 事件驱动模型454</p><p>14.1.3 事件处理和监听函数455</p><p>14.1.4 多线程与异步回调456</p><p>14.2 事件流及其传播456</p><p>14.2.1 事件传播过程457</p><p>14.2.2 冒泡型事件流457</p><p>14.2.3 捕获型事件流459</p><p>14.2.4 DOM标准事件流460</p><p>14.3 DOM 0级事件模型460</p><p>14.3.1 原始事件的处理方式460</p><p>14.3.2 斫石取火——定义事件461</p><p>14.3.3 直接调用——事件处理函数之趣463</p><p>14.3.4 冷落的返回值——事件处理函数之痕464</p><p>14.3.5 隐形的参数——事件处理函数之谜465</p><p>14.3.6 再说this——事件处理函数之惑466</p><p>14.3.7 身在曹营心在汉——事件处理函数之域467</p><p>14.4 DOM 2级事件模型469</p><p>14.4.1 认识DOM 2级事件模型469</p><p>1．事件模块与接口470</p><p>2．DOM 2级事件模型的工作机制470</p><p>3．Event接口470</p><p>4．UIEvent接口471</p><p>5．MouseEvent接口471</p><p>6．MutationEvent接口471</p><p>14.4.2 绑定和销毁事件471</p><p>1．绑定事件472</p><p>2．销毁事件473</p><p>14.4.3 为对象注册多个事件处理函数473</p><p>14.4.4 兼容0级事件模型的处理方法474</p><p>14.4.5 兼容IE的事件处理方法475</p><p>14.5 IE事件模型475</p><p>14.5.1 认识IE事件模型475</p><p>14.5.2 绑定和销毁事件476</p><p>1．绑定事件476</p><p>2．销毁事件476</p><p>3．事件处理函数中的this477</p><p>4．绑定多个事件477</p><p>14.5.3 设计可兼容的Event对象478</p><p>14.6 事件类型478</p><p>14.6.1 事件类型概述479</p><p>14.6.2 鼠标事件481</p><p>1．鼠标点击事件类型482</p><p>2．鼠标移动事件类型482</p><p>3．鼠标经过事件类型484</p><p>4．鼠标来源485</p><p>5．鼠标定位486</p><p>6．封装并应用鼠标定位设计方案487</p><p>7．在元素内部定位鼠标指针488</p><p>8．鼠标按键489</p><p>9．鼠标事件响应顺序489</p><p>14.6.3 键盘事件490</p><p>1．认识键盘事件的属性490</p><p>2．ctrlKey和shiftKey属性491</p><p>3．keyCode和charCode属性491</p><p>4．键盘事件响应顺序493</p><p>14.6.4 页面事件493</p><p>1．页面初始化——load事件类型494</p><p>2．load事件类型的特殊引用495</p><p>3．在页面初始化之前执行脚本——DOMContentLoaded事件类型496</p><p>4．页面卸载——unload事件类型498</p><p>5．更人性化的页面卸载——beforeunload事件类型499</p><p>6．窗口重置——resize事件类型499</p><p>7．文档移动——scroll事件类型500</p><p>8．错误捕获——error事件类型500</p><p>14.6.5 UI事件501</p><p>1．获取焦点——focus事件类型501</p><p>2．失去焦点——blur事件类型501</p><p>14.6.6 表单事件501</p><p>1．选择文本——select事件类型502</p><p>2．监测表单元素值变化——change事件类型502</p><p>3．提交表单——submit事件类型503</p><p>4．重置表单——reset事件类型504</p><p>第15章 CSS——设计HTML动态效果507</p><p>15.1 DOM 2级样式控制模型507</p><p>15.1.1 CSSStyleSheet接口508</p><p>15.1.2 CSSStyleRule接口508</p><p>15.1.3 CSSStyleDeclaration接口509</p><p>15.2 DOM 0级样式控制模型510</p><p>15.2.1 style对象510</p><p>15.2.2 使用style对象读写行内样式516</p><p>1．读取样式的属性值和属性名516</p><p>2．设置样式的属性值516</p><p>3．移除样式声明517</p><p>4．检测声明中是否附加！important关键字517</p><p>5．内行样式设置实战517</p><p>15.2.3 styleSheets集合519</p><p>15.2.4 访问CSS样式表521</p><p>15.2.5 读写CSS规则522</p><p>15.2.6 访问最终样式525</p><p>1．IE的最终样式525</p><p>2．DOM的最终样式526</p><p>15.2.7 修改CSS样式的方法比较526</p><p>1．关于修改class样式527</p><p>2．关于修改id样式527</p><p>15.3 尺寸528</p><p>15.3.1 从CSS样式表中抽取元素尺寸528</p><p>15.3.2 把抽取的尺寸转化为实际值529</p><p>15.3.3 使用offsetWidth和offsetHeight获取元素的尺寸531</p><p>15.3.4 超越offsetWidth和offsetHeight的缺陷532</p><p>15.3.5 更复杂的元素尺寸534</p><p>15.3.6 可视区域外滚动尺寸537</p><p>15.3.7 浏览器窗口的尺寸538</p><p>15.4 位置539</p><p>15.4.1 获取元素在浏览器窗口中的位置540</p><p>15.4.2 获取元素相对父元素的位置543</p><p>15.4.3 获取元素相对包含块的位置543</p><p>15.4.4 设置元素的偏移位置544</p><p>15.4.5 设置元素的相对位置544</p><p>15.4.6 获取鼠标指针的页面位置545</p><p>15.4.7 获取鼠标指针在元素内的位置546</p><p>15.4.8 获取页面滚动条的位置548</p><p>15.4.9 设置页面滚动条的位置549</p><p>15.5 显示和隐藏549</p><p>15.5.1 元素的可见性550</p><p>15.5.2 显示和隐藏功能封装550</p><p>15.5.3 设置和获取元素的透明度551</p><p>15.6 动画552</p><p>15.6.1 定时器553</p><p>1．setTimeout（）方法553</p><p>2．setInterval（）方法555</p><p>3．正确选用setTimeout（）和setInterval（）方法555</p><p>15.6.2 滑动556</p><p>15.6.3 渐隐渐显557</p><p>第5篇 飞鸿传书561</p><p>第16章 Cookie——用户信息存储、交互与安全561</p><p>16.1 Cookie概述561</p><p>16.1.1 Cookie回眸561</p><p>16.1.2 Cookie信息的结构562</p><p>16.2 存取Cookie信息563</p><p>16.2.1 写入Cookie信息563</p><p>16.2.2 设置Cookie有效期563</p><p>16.2.3 设置Cookie的域和路径564</p><p>16.2.4 设置Cookie安全传输565</p><p>16.2.5 完善写入的Cookie信息565</p><p>16.2.6 读取Cookie信息566</p><p>16.2.7 修改和删除Cookie信息567</p><p>16.2.8 Cookie的局限性及其突破567</p><p>16.2.9 探测浏览器是否启用Cookie569</p><p>16.3 Cookie封装与应用569</p><p>16.3.1 Cookie封装569</p><p>16.3.2 Cookie应用：打字测试游戏571</p><p>第17章 XML和JSON——JavaScriDt数据处理模式575</p><p>17.1 更通用的数据——XML575</p><p>17.1.1 认识XML575</p><p>17.1.2 XML文档结构概述576</p><p>17.1.3 声明577</p><p>17.1.4 处理指令577</p><p>17.1.5 注释578</p><p>17.1.6 标记和元素578</p><p>17.1.7 XML属性579</p><p>17.2 XML DOM文档对象模型580</p><p>17.2.1 认识XML DOM文档对象模型580</p><p>17.2.2 读取XML数据582</p><p>17.3 IE对XML的支持584</p><p>17.3.1 创建XML DOM对象584</p><p>17.3.2 加载XML数据585</p><p>1．设置加载模式585</p><p>2．跟踪异步加载状态585</p><p>17.3.3 数据加载错误处理586</p><p>17.4 Mozilla对XML的支持587</p><p>17.4.1 创建XML DOM对象587</p><p>17.4.2 加载XML数据588</p><p>17.4.3 读取XML数据589</p><p>1．自定义方法模拟text属性的功能589</p><p>2．自定义方法模拟xml属性的功能589</p><p>17.5 XML数据导航器——XPath590</p><p>17.5.1 XPath基本语法590</p><p>17.5.2 IE对XPath的支持592</p><p>17.5.3 Mozilla对XPath的支持593</p><p>17.6 更敏捷的数据——JSON595</p><p>17.6.1 JSON简介595</p><p>17.6.2 深入JSON数据内核598</p><p>1．数据的无序结构——对象598</p><p>2．数据的有序结构——数组598</p><p>3．数据的内容——值599</p><p>第18章 Ajax——JavaScript通信接口与异步交互引擎601</p><p>18.1 网络那点事儿——浓缩的HTTP601</p><p>18.1.1 HTTP请求602</p><p>18.1.2 HTTP响应604</p><p>18.2 暗度陈仓——从隐藏框架说起605</p><p>18.2.1 隐藏框架605</p><p>18.2.2 异步交互与回调处理608</p><p>18.2.3 使用iframe处理异步交互611</p><p>18.3 巧连环——JSONP与跨域异步交互613</p><p>18.3.1 小聪明大智慧—＜script＞标签背后的故事613</p><p>18.3.2 动态控制script元素实现可控异步通信615</p><p>18.3.3 script异步通信的参数传递616</p><p>18.3.4 script异步通信的响应数据类型620</p><p>18.3.5 JSONP异步通信协议623</p><p>18.3.6 JSONP的安全问题625</p><p>18.4 Ajax——更高效的异步通信接口626</p><p>18.4.1 认识XMLHttpRequest对象627</p><p>18.4.2 定义XMLHttpRequest对象628</p><p>18.4.3 建立XMLHttpRequest请求连接629</p><p>18.5 Request——发送请求630</p><p>18.5.1 发送GET请求630</p><p>18.5.2 发送POST请求631</p><p>18.5.3 把数据转换为串行字符串633</p><p>1．传输名／值对信息633</p><p>2．传输有序数据列表633</p><p>18.6 State——异步状态监测634</p><p>18.6.1 跟踪Ajax异步通信状态634</p><p>18.6.2 中止异步请求636</p><p>18.7 Response——获取响应信息636</p><p>18.7.1 XML637</p><p>18.7.2 HTML638</p><p>18.7.3 Code639</p><p>18.7.4 JSON640</p><p>18.7.5 Text641</p><p>18.7.6 获取和设置头部消息641</p><p>18.8 Ajax通信功能封装和应用642</p><p>18.8.1 封装异步请求函数642</p><p>18.8.2 使用Ajax改进Tab显示643</p><p>第6篇 壮士凯旋651</p><p>第19章 可视化思维——深入JavaScript面向对象编程651</p><p>19.1 书非借不能读也——说类651</p><p>19.1.1 类与对象651</p><p>19.1.2 类成员：属性、方法和事件652</p><p>19.1.3 类的基本特性：继承、封装和多态652</p><p>19.2 定义JavaScript类653</p><p>19.2.1 小老板为什么能年挣百万——工厂模式653</p><p>19.2.2 拿来主义——构造函数模式655</p><p>19.2.3 遗传栽培法——原型模式657</p><p>19.2.4 杂交栽培法——构造函数原型模式658</p><p>19.2.5 滴灌法——动态原型模式660</p><p>19.3 契约书——JavaScript接口661</p><p>19.3.1 新版黔驴技穷——大话接口661</p><p>19.3.2 签订契约书——接口的本质663</p><p>19.3.3 大道理简单化——JavaScript接口实现方法一665</p><p>19.3.4 孔明点灯——JavaScript接口实现方法二667</p><p>19.3.5 鸡肋还是鸡翅——JavaScript接口选用之惑670</p><p>19.4 JavaScript继承机制——原型（prototype）671</p><p>19.4.1 认识prototype671</p><p>19.4.2 剪不断理还乱——辨析泛类、类型、原型和对象实例672</p><p>19.4.3 形似神异——构造类的原型和本地特性674</p><p>19.4.4 四大皆空——关于类的唯空论676</p><p>19.4.5 原型属性的基本操作和应用技巧678</p><p>1．利用原型为对象设置默认值679</p><p>2．利用原型间接实现本地数据备份680</p><p>3．利用原型设置只读属性680</p><p>4．利用原型进行批量复制682</p><p>19.4.6 定义静态原型方法683</p><p>19.4.7 prototype原型域及原型链683</p><p>19.4.8 prototype的副作用685</p><p>19.5 JavaScript基因图谱——继承686</p><p>19.5.1 认识JavaScript的继承机制686</p><p>19.5.2 原型继承688</p><p>19.5.3 类继承的源起689</p><p>19.5.4 类继承的设计模式690</p><p>19.5.5 深入理解类继承中call（）和apply（）角色693</p><p>19.5.6 封装类继承机制695</p><p>19.5.7 实例继承696</p><p>19.5.8 复制继承698</p><p>19.5.9 克隆继承699</p><p>19.5.10 混合继承699</p><p>19.5.11 多重继承701</p><p>19.5.12 掺元类702</p><p>19.6 类的封装704</p><p>19.6.1 类的被动封装705</p><p>19.6.2 类的主动封装706</p><p>19.6.3 定义类的静态方法和属性708</p><p>19.7 类的多态710</p><p>19.7.1 方法的重载和覆盖711</p><p>1．重载711</p><p>2．覆盖711</p><p>19.7.2 类的多态712</p><p>19.8 善始善终——类的构造和析构713</p><p>19.8.1 构造714</p><p>19.8.2 动态构造715</p><p>19.8.3 析构716</p><p>19.9 类的抽象化——超类、子类和元类717</p><p>19.9.1 超类和子类717</p><p>19.9.2 元类718</p><p>第20章 卜算子——深入JavaScript函数式编程721</p><p>20.1 JavaScript函数式编程概述721</p><p>20.1.1 函数是第一型721</p><p>20.1.2 函数是运算元722</p><p>20.1.3 函数是数据闭包723</p><p>20.2 表达式运算724</p><p>20.2.1 实现连续运算的常用方法724</p><p>20.2.2 尝试把所有命令式语句转换为连续运算727</p><p>20.2.3 表达式中的函数728</p><p>20.2.4 函数的惰性与非惰性求值730</p><p>20.2.5 函数调用栈732</p><p>20.3 递归运算734</p><p>20.3.1 认识递归735</p><p>20.3.2 猜一猜，算一算——递归算法演示736</p><p>20.3.3 递归算法738</p><p>20.3.4 递归模型738</p><p>1．问题的定义是递归的738</p><p>2．问题所涉及的数据结构是递归的739</p><p>3．问题的解法满足递归的性质740</p><p>20.3.5 Hanoi（汉诺）塔算法740</p><p>20.3.6 尾递归算法742</p><p>20.3.7 Fibonacci（斐波那契）数列744</p><p>20.3.8 递归算法的优化746</p><p>20.4 高处不胜寒——破解函数域之惑747</p><p>20.4.1 我是谁——JavaScript执行环境与函数解析机制747</p><p>20.4.2 我从哪来——词法作用域与执行作用域749</p><p>20.4.3 寻找迷失的远方——作用域链751</p><p>20.4.4 我又在哪里——调用对象753</p><p>20.5 天宫之旅——函数闭包754</p><p>20.5.1 从圈外看闭包754</p><p>20.5.2 从圈内看函数闭包755</p><p>20.5.3 解剖闭包结构——认识闭包标识符系统757</p><p>20.5.4 覆盖还是层叠——关于闭包函数的作用域问题759</p><p>20.5.5 生存还是毁灭——关于闭包函数的生存周期问题760</p><p>20.5.6 辨析函数与闭包762</p><p>20.5.7 奇怪的不等式——函数、调用、引用和实例763</p><p>20.5.8 梦里花落知多少——闭包函数与函数实例765</p><p>20.5.9 剪不断理还乱——闭包函数与调用对象769</p><p>20.5.10 保护闭包数据的独立性771</p><p>20.5.11 始祖鸟——构造函数闭包773</p><p>20.5.12 想你所想——函数式编程中闭包的应用价值774</p><p>20.5.13 一起联想——函数式编程中闭包的桥梁作用776</p><p>20.5.14 预防中毒——闭包的副作用779</p><p>20.6 我是谁？——彻底研究this782</p><p>20.6.1 who is this——确认this的身份783</p><p>1．this代表当前对象783</p><p>2．this代表当前作用域对象784</p><p>20.6.2 what is this——this的本质786</p><p>1．闭包的破坏性787</p><p>2．call（）和apply（）方法的破坏性788</p><p>3．异步调用的破坏性788</p><p>20.6.3 where is this——在哪儿使用this788</p><p>1．函数的引用和调用788</p><p>2．call（）和apply（）789</p><p>3．原型继承790</p><p>4．异步调用之事件处理函数791</p><p>5．异步调用之定时器792</p><p>20.6.4 how to do this——this应对策略792</p><p>1．预防this多变的基本原则792</p><p>2．把this作为参数值793</p><p>3．设计静态的this指针793</p><p>4．设计静态的this扩展方法794</p><p>第21章 流水不腐——深入JavaScript动态化编程797</p><p>21.1 使用eval（）方法动态执行语句797</p><p>21.1.1 动态值、表达式和语句797</p><p>21.1.2 对象和函数直接量的歧义问题799</p><p>21.1.3 eval全局执行域及其兼容方法800</p><p>21.1.4 eval当前执行域802</p><p>21.2 动态调用函数802</p><p>21.2.1 函数调用方法及执行效率比较802</p><p>1．使用小括号运算符调用函数803</p><p>2．使用new运算符调用函数803</p><p>3．使用call（）和apply（）方法调用函数804</p><p>4．使用定时器调用函数804</p><p>5．使用事件处理函数调用函数805</p><p>21.2.2 函数的调用对象805</p><p>21.2.3 动态调用中的this指针808</p><p>21.2.4 在动态调用中实现继承810</p><p>21.2.5 动态调用中易迷失的this指针810</p><p>21.2.6 嵌套函数调用中的副作用812</p><p>21.3 动态重写814</p><p>21.3.1 重写原型对象814</p><p>21.3.2 重写构造器816</p><p>21.3.3 重写方法818</p><p></p></div></div><div class="d-rt"><h3>热门推荐</h3><ul><li><a href="/book/460285.html">460285.html</a></li><li><a href="/book/1491606.html">1491606.html</a></li><li><a href="/book/3058829.html">3058829.html</a></li><li><a href="/book/1543275.html">1543275.html</a></li><li><a href="/book/961931.html">961931.html</a></li><li><a href="/book/506159.html">506159.html</a></li><li><a href="/book/3427591.html">3427591.html</a></li><li><a href="/book/1686693.html">1686693.html</a></li><li><a href="/book/1259613.html">1259613.html</a></li><li><a href="/book/2365329.html">2365329.html</a></li></ul></div></div><div id="footer"><p>Copyright&nbsp;&copy;&nbsp;2025&nbsp;&nbsp;<a href="/list/">最新更新</a></p><p>请使用FDM BitComet qBittorrent uTorrent等BT下载工具，下载本站电子书资源！首推Free Download Manager下载软件。文件页数>标注页数[分册图书除外]</p></div></body></html>