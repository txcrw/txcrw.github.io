<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><script type="text/javascript" src="https://file.bkxsj.com/skin/book/js/sk.js"></script><meta name="robots" content="index,follow"><title>Thinking in C++ Volume 2: Practical Programming = C++编程思想 第2卷 实用编程技术 （英文版）[PDF|Epub|txt|kindle电子书版本网盘下载]-灵感之桥</title><meta name="Keywords" content="Thinking in C++ Volume 2: Practical Programming = C++编程思想 第2卷 实用编程技术 （英文版）"/><meta name="description" content="Thinking in C++ Volume 2: Practical Programming = C++编程思想 第2卷 实用编程技术 （英文版）pdf下载文件大小为81MB,PDF页数为823页"/><meta http-equiv="X-UA-Compatible" content="IE=9; IE=8; IE=7; IE=EDGE;chrome=1"><link type="image/x-icon" rel="shortcut icon" href="https://www.shukui.net/skin/book/images/favicon.ico"><link type="text/css" rel="stylesheet" href="https://www.shukui.net/skin/book/css/style.css"><style>#main .d-main {margin-left: 0;width: 620px;}.down-btn {animation: myShake 2.5s linear .15s infinite}@keyframes myShake {0%, 66% {transform: translateZ(0)}67%, 73.6%, 83.6%, 93.6%, to {animation-timing-function: cubic-bezier(.215, .61, .355, 1);transform: translateZ(0)}80.3%, 81.4% {animation-timing-function: cubic-bezier(.755, .05, .855, .06);transform: translate3d(0, -4px, 0)}90.3% {animation-timing-function: cubic-bezier(.755, .05, .855, .06);transform: translate3d(0, -2px, 0)}97% {transform: translate3d(0, -.5px, 0)}}.copylink-btn {margin-right: 20px;}.copymd5-btn {margin-bottom: 25px;margin-left: 10px;}</style></head><body><div id="header"><div class="inner"><div class="logo"><a href="/"><img width="103" height="25" alt="灵感之桥"src="https://www.shukui.net/skin/book/images/logo.png"></a></div><div class="search"><form action="/so/search.php" target="_blank"><input type="text" autocomplete="off" id="bdcsMain" name="q" placeholder="书名 / 作者 / 出版社 / ISBN"class="inp-txt"><select class="inp-select" id="datasource" onchange="selectDatasource(this)"><option value="so">主库</option><option value="s">从库</option></select><input type="submit" value="搜索" class="inp-btn"></form></div></div></div><div id="main"><div class="d-main"><div class="tit"><h3>图书介绍</h3></div><h1 class="book-name">Thinking in C++ Volume 2: Practical Programming = C++编程思想 第2卷 实用编程技术 （英文版）PDF|Epub|txt|kindle电子书版本网盘下载</h1><div class="d-info"><div class="b-thumb"><img src="https://www.shukui.net/cover/14/33942001.jpg" alt="Thinking in C++ Volume 2: Practical Programming = C++编程思想 第2卷 实用编程技术 （英文版）"></div><div class="b-info"><ul><li>Bruce Eckel ; Chuck Allison 著</li><li>出版社： China Machine Press</li><li>ISBN：7111121880</li><li>出版时间：2002</li><li>标注页数：802页</li><li>文件大小：81MB</li><li>文件页数：823页</li><li>主题词：C语言－程序设计－英文</li></ul></div></div><div class="tit"><h3>PDF下载</h3></div><div></br><a style="color:red;" rel="external nofollow" href="https://www.kjlm.net/ebook/3005784.html"target="_blank"><b>点此进入-本书在线PDF格式电子书下载【推荐-云解压-方便快捷】直接下载PDF格式图书。移动端-PC端通用</a></b></br><a class="down-btn" rel="external nofollow" href="https://down.trackerbk.com/bt/50/33942001.torrent"target="_blank">种子下载</a>[BT下载速度快]温馨提示：（请使用BT下载软件FDM进行下载）<a rel="nofollow" href="https://www.freedownloadmanager.org/zh/" target="_blank">软件下载地址页</a><a class="down-btn" rel="external nofollow" href="https://down.p2spdb.com/50/33942001.rar" target="_blank">直链下载</a>[便捷但速度慢]&nbsp;&nbsp;<a style="color:red;" rel="external nofollow" href="https://pdfyl.ertongbook.com/69/33942001.pdf" target="_blank"><b>[在线试读本书]</b></a>&nbsp;&nbsp;<b> <a style="color:red;" rel="external nofollow" href="https://web.jyjl.org/index/recovery.html" target="_blank">[在线获取解压码]</a></b><div class="copymd5-btn"><a href="javascript:copyToClip('9ce5585b72c0c8ac41122316368f8189')">点击复制MD5值：9ce5585b72c0c8ac41122316368f8189</a></div></div><div class="tit"><h3>下载说明</h3></div><div style="margin:20px 10px"><h2>Thinking in C++ Volume 2: Practical Programming = C++编程思想 第2卷 实用编程技术 （英文版）PDF格式电子书版下载</h2>下载的文件为RAR压缩包。需要使用解压软件进行解压得到PDF格式图书。<br><br><div class="copymd5-btn"><a href="javascript:copyToClip('magnet:?xt=urn:btih:RX6G6JQ2LJW7PBBEDNUSCQM7ICDMHIWK')">点击复制85GB完整离线版磁力链接到迅雷FDM等BT下载工具进行下载</a>&nbsp;&nbsp;<a rel="nofollow" target="_blank">详情点击-查看共享计划</a></div>建议使用BT下载工具Free Download Manager进行下载,简称FDM(免费,没有广告,支持多平台）。本站资源全部打包为BT种子。所以需要使用专业的BT下载软件进行下载。如BitComet qBittorrent uTorrent等BT下载工具。迅雷目前由于本站不是热门资源。不推荐使用！后期资源热门了。安装了迅雷也可以迅雷进行下载！<br><br><b>（文件页数 要大于 标注页数，上中下等多册电子书除外）</b><br><br><p style="color:red;"> <b>注意：本站所有压缩包均有解压码：</b> <a rel="nofollow" target="_blank"><b>点击下载压缩包解压工具</b></a></p></div><div class="tit"><h3>图书目录</h3></div><div id="book-contents"><p>Preface1</p><p>What’s new in the second edition2</p><p>What’s in Volume 2 of this book3</p><p>How to get Volume 23</p><p>Prerequisites3</p><p>Learning C＋＋4</p><p>Goals5</p><p>Chapters7</p><p>Exercises12</p><p>Exercise solutions12</p><p>Source code12</p><p>Language standards14</p><p>Language support15</p><p>The book’s CD ROM15</p><p>CD ROMs，seminars，and consulting16</p><p>Errors16</p><p>About the cover17</p><p>Book design and production18</p><p>Acknowledgements19</p><p>1：Introduction to Objects21</p><p>The progress of abstraction22</p><p>An object has an interface25</p><p>The hidden implementation28</p><p>Reusing the implementation29</p><p>Inheritance：reusing the interface31</p><p>Is-a vs.is-like-a relationships35</p><p>Interchangeable objects with polymorphism37</p><p>Creating and destroying objects41</p><p>Exception handling：dealing with errors43</p><p>Analysis and design44</p><p>Phase 0：Make a plan47</p><p>Phase 1：What a we making？48</p><p>Phase 2：How will we build it？52</p><p>Phase 3：Build the core56</p><p>Phase 4：Iterate the use cases57</p><p>Phase 5：Evolution58</p><p>Plans pay off60</p><p>Extreme programming61</p><p>Write tests first61</p><p>Pair programming63</p><p>Why C＋＋ succeeds64</p><p>A better C65</p><p>You’re already on the learning curve65</p><p>Efficiency66</p><p>Systems are easier to express and understand66</p><p>Maximal leverage with libraries67</p><p>Source-code reuse with templates67</p><p>Error handling67</p><p>Programming in the large68</p><p>Strategies for transition68</p><p>Guidelines69</p><p>Management obstacles71</p><p>Summary73</p><p>2：Making ＆ Using Objects75</p><p>The process of language translation76</p><p>Interpreters77</p><p>Compilers77</p><p>The compilation process79</p><p>Tools for separate compilation80</p><p>Declarations vs.definitions81</p><p>Linking87</p><p>Using libraries88</p><p>Your first C＋＋ program90</p><p>Using the lostreams class90</p><p>Namespaces91</p><p>Fundamentals of program structure93</p><p>“Hello，world！”94</p><p>Running the compiler95</p><p>More about iostreams96</p><p>Character array concatenation96</p><p>Reading input97</p><p>Calling other programs98</p><p>Introducing strings98</p><p>Reading and writing files100</p><p>Introducing vector102</p><p>Summary108</p><p>Exercises109</p><p>3：The C in C＋＋111</p><p>Creating functions112</p><p>Function return values115</p><p>Using the C function library116</p><p>Creating your own braries with the librarian117</p><p>Controlling execution117</p><p>True and false117</p><p>if-else118</p><p>while119</p><p>do-while120</p><p>for121</p><p>The break and continue keywords122</p><p>switch123</p><p>Using and misusing goto125</p><p>Recursion126</p><p>Introduction to operators127</p><p>Precedence127</p><p>Auto increment and decrement128</p><p>Introduction to data types129</p><p>Basic built-in types129</p><p>bool，true，＆ false131</p><p>Specifiers132</p><p>Introduction to pointers133</p><p>Modifying the outside object137</p><p>Introduction to C＋＋ references140</p><p>Pointers and references as modifiers141</p><p>Scoping143</p><p>Defining variables on the fly145</p><p>Specifying storage allocation147</p><p>Global variables147</p><p>Local variables149</p><p>static149</p><p>extem151</p><p>Constants153</p><p>volatile155</p><p>Operators and their use156</p><p>Assignment156</p><p>Mathematical operators156</p><p>Relational operators158</p><p>Logical operators158</p><p>Bitwise operators159</p><p>Shift operators160</p><p>Unary operators163</p><p>The ternary operator164</p><p>The comma operator165</p><p>Common pitfalls when using operators166</p><p>Casting operators166</p><p>C＋＋ explicit casts167</p><p>sizeof - an operator by itself172</p><p>The asm keyword173</p><p>Explicit operators173</p><p>Composite type creation174</p><p>Aliasing names with typedef174</p><p>Combining variables with struct175</p><p>Clarifying programs with enum179</p><p>Saving memory with union181</p><p>Arrays182</p><p>Debugging hints193</p><p>Debugging flags194</p><p>Turning variables and expressions into strings196</p><p>The C assert（ ） macro197</p><p>Function addresses198</p><p>Defining a function pointer198</p><p>Complicated declarations ＆ definitions199</p><p>Using a function pointer200</p><p>Arrays of pointers to functions201</p><p>Make：managing separate compilation202</p><p>Make activities204</p><p>Makefiles in this book207</p><p>An example makefile208</p><p>Summary210</p><p>Exercises210</p><p>4：Data Abstraction217</p><p>A tiny C-like library219</p><p>Dynamic storage allocation223</p><p>Bad guesses227</p><p>What’s wrong？229</p><p>The basic object230</p><p>What’s an object？238</p><p>Abstract data typing239</p><p>Object details240</p><p>Header file etiquette241</p><p>Importance of header files242</p><p>The multiple-declaration problem244</p><p>The preprocessor directives #define，#ifdef，and #endif245</p><p>A standard for header files246</p><p>Namespaces in headers247</p><p>Using headers in projects248</p><p>Nested structures248</p><p>Global scope resolution253</p><p>Summary253</p><p>Exercises254</p><p>5：Hiding the Implementation259</p><p>Setting limits260</p><p>C＋＋ access control261</p><p>protected263</p><p>Friends263</p><p>Nested friends266</p><p>Is it pure？269</p><p>Object layout269</p><p>The class270</p><p>Modifying Stash to use access control273</p><p>Modifying Stack to use access control274</p><p>Handle classes275</p><p>Hiding the implementation276</p><p>Reducing recompilation276</p><p>Summary279</p><p>Exercises280</p><p>6：Initialization ＆Cleanup283</p><p>Guaranteed initialization with the constructor285</p><p>Guaranteed cleanup with the destructor287</p><p>Elimination of the definition block289</p><p>for loops291</p><p>Storage allocation292</p><p>Stash with constructors and destructors294</p><p>Stack with constructors ＆ destructors298</p><p>Aggregate initialization301</p><p>Default constructors304</p><p>Summary305</p><p>Exercises306</p><p>7：Function Overloading ＆ Default Arguments309</p><p>More name decoration311</p><p>Overloading on return values312</p><p>Type-safe linkage313</p><p>Overloading example314</p><p>unions318</p><p>Default arguments321</p><p>Placeholder arguments323</p><p>Choosing overloading vs.default arguments324</p><p>Summary329</p><p>Exercises330</p><p>8：Constants333</p><p>Value substitution334</p><p>const in header files335</p><p>Safety consts336</p><p>Aggregates337</p><p>Differences with C338</p><p>Pointers340</p><p>Pointer to const340</p><p>const pointer341</p><p>Assignment and pe checking343</p><p>Function arguments ＆ return values344</p><p>Passing by const value344</p><p>Returning by const value345</p><p>passing and returning addresses349</p><p>Classes352</p><p>const in classes353</p><p>Compile-time constants in classes356</p><p>const objects ＆member functions359</p><p>volatile365</p><p>Summary367</p><p>Exercises367</p><p>9：Inline Functions371</p><p>Preprocessor pitfalls372</p><p>Macros and access376</p><p>Inline functions377</p><p>Inlines inside classes378</p><p>Access functions379</p><p>Stash ＆ Stack with inlines385</p><p>Inlines ＆the compiler390</p><p>Limitations390</p><p>Forward references391</p><p>Hidden activities in constructors ＆destructors392</p><p>Reducing clutter393</p><p>More preprocessor features395</p><p>Token pasting396</p><p>Improved error checking396</p><p>Summary400</p><p>Exercises400</p><p>10：Name Control405</p><p>Static elements from C406</p><p>static variables inside functions406</p><p>Controlling linkage412</p><p>Other storage class specifiers414</p><p>Namespaces414</p><p>Creating a namespace415</p><p>Using a namespace417</p><p>The use of namespaces422</p><p>Static members in C＋＋423</p><p>Defining storage for static data members424</p><p>Nested and local classes428</p><p>static member functions429</p><p>Static initialization dependency432</p><p>What to do434</p><p>Alternate linkage specifications442</p><p>Summary443</p><p>Exercises443</p><p>11：References ＆ the Copy-Constructor449</p><p>Pointers in C＋＋450</p><p>References in C＋＋451</p><p>References in functions452</p><p>Argument-passing guidelines455</p><p>The copy-constructor455</p><p>Passing ＆ returning by value455</p><p>Copy-construction462</p><p>Default copy-constructor468</p><p>Altematives to copy-construction471</p><p>Pointers to members473</p><p>Functions475</p><p>Summary478</p><p>Exercises479</p><p>12：Operator Overloading485</p><p>Warning ＆reassurance486</p><p>Syntax487</p><p>Overloadable operators488</p><p>Unary operators489</p><p>Binary operators493</p><p>Arguments ＆return values505</p><p>Unusual operators508</p><p>Operators you can’t overload517</p><p>Non-member operators518</p><p>Basic guidelines520</p><p>Overloading assignment521</p><p>Behavior of operator=522</p><p>Automatic type conversion533</p><p>Constructor conversion534</p><p>Operator conversion535</p><p>Type conversion example538</p><p>Pitfalls in automatic type conversion539</p><p>Summary542</p><p>Exercises542</p><p>13：Dynamic Object Creation547</p><p>Object creation549</p><p>C’s approach to the heap550</p><p>operator new552</p><p>operator delete553</p><p>A simple example553</p><p>Memory manager overhead554</p><p>Early examples redesigned555</p><p>delete void* is probably a bug555</p><p>Cleanup responsibility with pointers557</p><p>Stash for pointers558</p><p>new ＆ delete for arrays563</p><p>Making a pointer more like an array564</p><p>Running out of storage565</p><p>Overloading new ＆ delete566</p><p>Overloading global new ＆ delete568</p><p>Overloading new ＆ delete for a class570</p><p>Overloading new ＆ delete for arrays573</p><p>Constructor calls576</p><p>placement new ＆ delete577</p><p>Summary580</p><p>Exercises580</p><p>14：Inheritance ＆ Composition583</p><p>Composition syntax584</p><p>Inheritance syntax586</p><p>The constructor initializer list588</p><p>Member object initialization589</p><p>Built-in types in the initializer list589</p><p>Combining composition ＆ inheritance591</p><p>Order of constructor ＆destructor calls592</p><p>Name hiding595</p><p>Functions that don’t automatically inherit600</p><p>Inheritance and static member functions604</p><p>Choosing composition vs.inheritance604</p><p>Subtyping606</p><p>private inheritance609</p><p>protected610</p><p>protected inheritance611</p><p>Operator overloading ＆ inheritance612</p><p>Multiple inheritance613</p><p>Incremental development614</p><p>Upcasting615</p><p>Why “upcasting？”617</p><p>Upcasting and the copy-constructor617</p><p>Composition vs.inheritance （revisited）620</p><p>Pointer ＆ reference upcasting622</p><p>A crisis622</p><p>Summary623</p><p>Exercises623</p><p>15：Polymorphism ＆Virtual Functions627</p><p>Evolution of C＋＋programmers628</p><p>Upcasting629</p><p>The problem631</p><p>Function call binding631</p><p>virtual functions632</p><p>Extensibility633</p><p>How C＋＋ implements late binding636</p><p>Storing type information637</p><p>Picturing virtual functions639</p><p>Under the hood642</p><p>Installing the vpointer643</p><p>Objects are different644</p><p>Why virtual functions？645</p><p>Abstract base classes and pure virtual functions646</p><p>Pure virtual definitions651</p><p>Inheritance and the VTABLE652</p><p>Object slicing655</p><p>Overloading ＆overriding658</p><p>Variant return type660</p><p>virtual functions ＆constructors662</p><p>Order of constructor calls663</p><p>Behavior of virtual functions inside constructors664</p><p>Destructors and virtual destructors665</p><p>Pure virtual destructors668</p><p>Virtuals in destructors670</p><p>Creating an object-based hierarchy671</p><p>Operator overloading675</p><p>Downcasting678</p><p>Summary681</p><p>Exercises682</p><p>16：Introduction to Templates689</p><p>Containers690</p><p>The need for containers692</p><p>Overview of templates693</p><p>The template solution696</p><p>Template syntax697</p><p>Non-inline function definitions699</p><p>IntStack as a template701</p><p>Constants in templates703</p><p>Stack and Stash as templates705</p><p>Templatized pointer Stash707</p><p>Turning ownership on and off713</p><p>Holding objects by value716</p><p>Introducing iterators719</p><p>Stack with iterators728</p><p>PStash with iterators732</p><p>Why iterators？738</p><p>Function templates742</p><p>Summary743</p><p>Exercises744</p><p>A：Coding Style747</p><p>B：Programming Guidelines759</p><p>C：Recommended Reading775</p><p>C776</p><p>General C＋＋776</p><p>My own list of tooks777</p><p>Depth ＆dark corners778</p><p>Analysis ＆ design779</p><p>Index783</p><p></p></div></div><div class="d-rt"><h3>热门推荐</h3><ul><li><a href="/book/1917855.html">1917855.html</a></li><li><a href="/book/2543654.html">2543654.html</a></li><li><a href="/book/603187.html">603187.html</a></li><li><a href="/book/103315.html">103315.html</a></li><li><a href="/book/392048.html">392048.html</a></li><li><a href="/book/3009191.html">3009191.html</a></li><li><a href="/book/680298.html">680298.html</a></li><li><a href="/book/1938217.html">1938217.html</a></li><li><a href="/book/550388.html">550388.html</a></li><li><a href="/book/22451.html">22451.html</a></li></ul></div></div><div id="footer"><p>Copyright&nbsp;&copy;&nbsp;2025&nbsp;&nbsp;<a href="/list/">最新更新</a></p><p>请使用FDM BitComet qBittorrent uTorrent等BT下载工具，下载本站电子书资源！首推Free Download Manager下载软件。文件页数>标注页数[分册图书除外]</p></div></body></html>