<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><script type="text/javascript" src="https://file.bkxsj.com/skin/book/js/sk.js"></script><meta name="robots" content="index,follow"><title>汇编语言艺术 影印版[PDF|Epub|txt|kindle电子书版本网盘下载]-灵感之桥</title><meta name="Keywords" content="汇编语言艺术 影印版"/><meta name="description" content="汇编语言艺术 影印版pdf下载文件大小为409MB,PDF页数为909页"/><meta http-equiv="X-UA-Compatible" content="IE=9; IE=8; IE=7; IE=EDGE;chrome=1"><link type="image/x-icon" rel="shortcut icon" href="https://www.shukui.net/skin/book/images/favicon.ico"><link type="text/css" rel="stylesheet" href="https://www.shukui.net/skin/book/css/style.css"><style>#main .d-main {margin-left: 0;width: 620px;}.down-btn {animation: myShake 2.5s linear .15s infinite}@keyframes myShake {0%, 66% {transform: translateZ(0)}67%, 73.6%, 83.6%, 93.6%, to {animation-timing-function: cubic-bezier(.215, .61, .355, 1);transform: translateZ(0)}80.3%, 81.4% {animation-timing-function: cubic-bezier(.755, .05, .855, .06);transform: translate3d(0, -4px, 0)}90.3% {animation-timing-function: cubic-bezier(.755, .05, .855, .06);transform: translate3d(0, -2px, 0)}97% {transform: translate3d(0, -.5px, 0)}}.copylink-btn {margin-right: 20px;}.copymd5-btn {margin-bottom: 25px;margin-left: 10px;}</style></head><body><div id="header"><div class="inner"><div class="logo"><a href="/"><img width="103" height="25" alt="灵感之桥"src="https://www.shukui.net/skin/book/images/logo.png"></a></div><div class="search"><form action="/so/search.php" target="_blank"><input type="text" autocomplete="off" id="bdcsMain" name="q" placeholder="书名 / 作者 / 出版社 / ISBN"class="inp-txt"><select class="inp-select" id="datasource" onchange="selectDatasource(this)"><option value="so">主库</option><option value="s">从库</option></select><input type="submit" value="搜索" class="inp-btn"></form></div></div></div><div id="main"><div class="d-main"><div class="tit"><h3>图书介绍</h3></div><h1 class="book-name">汇编语言艺术 影印版PDF|Epub|txt|kindle电子书版本网盘下载</h1><div class="d-info"><div class="b-thumb"><img src="https://www.shukui.net/cover/15/30963384.jpg" alt="汇编语言艺术 影印版"></div><div class="b-info"><ul><li>RandallHyde著 著</li><li>出版社： 北京：清华大学出版社</li><li>ISBN：7302104352</li><li>出版时间：2005</li><li>标注页数：891页</li><li>文件大小：409MB</li><li>文件页数：909页</li><li>主题词：汇编语言－程序设计－高等学校－教材－英文</li></ul></div></div><div class="tit"><h3>PDF下载</h3></div><div></br><a style="color:red;" rel="external nofollow" href="https://www.kjlm.net/ebook/872741.html"target="_blank"><b>点此进入-本书在线PDF格式电子书下载【推荐-云解压-方便快捷】直接下载PDF格式图书。移动端-PC端通用</a></b></br><a class="down-btn" rel="external nofollow" href="https://down.trackerbk.com/bt/02/30963384.torrent"target="_blank">种子下载</a>[BT下载速度快]温馨提示：（请使用BT下载软件FDM进行下载）<a rel="nofollow" href="https://www.freedownloadmanager.org/zh/" target="_blank">软件下载地址页</a><a class="down-btn" rel="external nofollow" href="https://down.p2spdb.com/02/30963384.rar" target="_blank">直链下载</a>[便捷但速度慢]&nbsp;&nbsp;<a style="color:red;" rel="external nofollow" href="https://pdfyl.ertongbook.com/20/30963384.pdf" target="_blank"><b>[在线试读本书]</b></a>&nbsp;&nbsp;<b> <a style="color:red;" rel="external nofollow" href="https://web.jyjl.org/index/recovery.html" target="_blank">[在线获取解压码]</a></b><div class="copymd5-btn"><a href="javascript:copyToClip('a197d1448d47dfd8daeb6e0e4551c095')">点击复制MD5值：a197d1448d47dfd8daeb6e0e4551c095</a></div></div><div class="tit"><h3>下载说明</h3></div><div style="margin:20px 10px"><h2>汇编语言艺术 影印版PDF格式电子书版下载</h2>下载的文件为RAR压缩包。需要使用解压软件进行解压得到PDF格式图书。<br><br><div class="copymd5-btn"><a href="javascript:copyToClip('magnet:?xt=urn:btih:RX6G6JQ2LJW7PBBEDNUSCQM7ICDMHIWK')">点击复制85GB完整离线版磁力链接到迅雷FDM等BT下载工具进行下载</a>&nbsp;&nbsp;<a rel="nofollow" target="_blank">详情点击-查看共享计划</a></div>建议使用BT下载工具Free Download Manager进行下载,简称FDM(免费,没有广告,支持多平台）。本站资源全部打包为BT种子。所以需要使用专业的BT下载软件进行下载。如BitComet qBittorrent uTorrent等BT下载工具。迅雷目前由于本站不是热门资源。不推荐使用！后期资源热门了。安装了迅雷也可以迅雷进行下载！<br><br><b>（文件页数 要大于 标注页数，上中下等多册电子书除外）</b><br><br><p style="color:red;"> <b>注意：本站所有压缩包均有解压码：</b> <a rel="nofollow" target="_blank"><b>点击下载压缩包解压工具</b></a></p></div><div class="tit"><h3>图书目录</h3></div><div id="book-contents"><p>1 HELLO,WORLD OF ASSEMBLY LANGUAGE1</p><p>1.1 Chapter Overview1</p><p>1.2 The Anatomy of an HLA Program2</p><p>1.3 Running Your First HLA Program4</p><p>1.4 Some Basic HLA Data Declarations5</p><p>1.5 Boolean Values7</p><p>1.6 Character Values8</p><p>1.7 An Introduction to the Intel 80x86 CPU Family8</p><p>1.7.1 The Memory Subsystem11</p><p>1.8 Some Basic Machine Instructions14</p><p>1.9 Some Basic HLA Control Structures18</p><p>1.9.1 Boolean Expressions in HLA Statements18</p><p>1.9.2 The HLA IF..THEN..ELSEIF..ELSE..ENDIF Statement20</p><p>1.9.3 Conjunction,Disjunction,and Negation in Boolean Expressions22</p><p>1.9.4 The WHILE..ENDWHILE Statement25</p><p>1.9.5 The FOR..ENDFOR Statement25</p><p>1.9.6 The REPEAT..UNTILStatement26</p><p>1.9.7 The BREAK and BREAKIF Statements27</p><p>1.9.8 The FOREVER..ENDFOR Statement28</p><p>1.9.9 The TRY..EXCEPT1ON..ENDTRYStatement28</p><p>1.10 Introduction to the HLA Standard Library32</p><p>1.10.1 Predefined Constants in the STDIO Module33</p><p>1.10.2 Standard In and Standard Out34</p><p>1.10.3 The stdout.newln Routine34</p><p>1.10.4 The stdout.putiX Routines34</p><p>1.10.5 The stdout.putiXSize Routines35</p><p>1.10.6 The stdout.put Routine36</p><p>1.10.7 The stdin.getc Routine38</p><p>1.10.8 The stdin.getiX Routines39</p><p>1.10.9 The stdin.readLn and stdin.flushlnput Routines40</p><p>1.10.10 The stdin.get Routine41</p><p>1.11 Additional Details About TRY..ENDTRY42</p><p>1.11.1 Nesting TRY..ENDTRY Statements43</p><p>1.11.2 The UNPROTECTED Clause in a TRY..ENDTRY Statement45</p><p>1.11.3 The ANYEXCEPTION Clause in a TRY..ENDTRY Statement48</p><p>1.11.4 Registers and the TRY..ENDTRY Statement48</p><p>1.12 High Level Assembly Language vs.Low Level Assembly50</p><p>1.13 For More Information51</p><p>2 DATA REPRESENTATION53</p><p>2.1 Chapter Overview53</p><p>2.2 Numbering Systems54</p><p>2.2.1 A Review of the Decimal System54</p><p>2.2.2 The Binary Numbering System54</p><p>2.2.3 Binary Formats56</p><p>2.3 The Hexadecimal Numbering System57</p><p>2.4 Data Organization59</p><p>2.4.1 Bits59</p><p>2.4.2 Nibbles60</p><p>2.4.3 Bytes61</p><p>2.4.4 Words62</p><p>2.4.5 Double Words63</p><p>2.4.6 Quad Words and Long Words64</p><p>2.5 Arithmetic Operations on Binary and Hexadecimal Numbers65</p><p>2.6 A Note About Numbers vs.Representation66</p><p>2.7 Logical Operations on Bits69</p><p>2.8 Logical Operations on Binary Numbers and Bit Strings71</p><p>2.9 Signed and Unsigned Numbers73</p><p>2.10 Sign Extension,Zero Extension,Contraction,and Saturation78</p><p>2.11 Shifts and Rotates82</p><p>2.12 Bit Fields and Packed Data87</p><p>2.13 An Introduction to Floating Point Arithmetic92</p><p>2.13.1 IEEE Floating Point Formats95</p><p>2.13.2 HLA Support for Floating Point Values99</p><p>2.14 Binary Coded Decimal(BCD)Representation102</p><p>2.15 Characters104</p><p>2.15.1 The ASCII Character Encoding104</p><p>2.15.2 HLA Support for ASCII Characters108</p><p>2.16 The Unicode Character Set112</p><p>2.17 For More Information113</p><p>3 MEMORY ACCESS AND ORGANIZATION115</p><p>3.1 Chapter Overview115</p><p>3.2 The 80x86 Addressing Modes115</p><p>3.2.1 80x86 Register Addressing Modes116</p><p>3.2.2 80x86 32-Bit Memory Addressing Modes117</p><p>3.3 Run-Time Memory Organization124</p><p>3.3.1 The Code Section125</p><p>3.3.2 The Static Sections127</p><p>3.3.3 The Read-Only Data Section128</p><p>3.3.4 The Storage Section129</p><p>3.3.5 The @NOSTORAGE Attribute129</p><p>3.3.6 The Var Section130</p><p>3.3.7 Organization of Declaration Sections Within Your Programs131</p><p>3.4 How HLA Allocates Memory for Variables132</p><p>3.5 HLA Support for Data Alignment133</p><p>3.6 Address Expressions136</p><p>3.7 Type Coercion139</p><p>3.8 Register Type Coercion141</p><p>3.9 The Stack Segment and the PUSH and POP Instructions142</p><p>3.9.1 The Basic PUSH Instruction142</p><p>3.9.2 The Basic POP Instruction144</p><p>3.9.3 Preserving Registers with the PUSH and POP Instructions146</p><p>3.9.4 The Stack Is a LIFO Data Structure146</p><p>3.9.5 Other PUSH and POP Instructions149</p><p>3.9.6 Removing Data from the Stack Without Popping It150</p><p>3.9.7 Accessing Data You've Pushed on the Stack Without Popping It153</p><p>3.10 Dynamic Memory Allocation and the Heap Segment154</p><p>3.11 The INC and DEC Instructions159</p><p>3.12 Obtaining the Address of a Memory Object159</p><p>3.13 For More Information160</p><p>4 CONSTANTS,VARIABLES,AND DATA TYPES160</p><p>4.1 Chapter Overview161</p><p>4.2 Some Additional Instructions:INTMUL,BOUND,INTO162</p><p>4.3 The TBYTE Data Types166</p><p>4.4 HLA Constant and Value Declarations167</p><p>4.4.1 Constant Types170</p><p>4.4.2 String and Character Literal Constants171</p><p>4.4.3 String and Text Constants in the CONST Section174</p><p>4.4.4 Constant Expressions175</p><p>4.4.5 Multiple CONST Sections and Their Order in an HLA Program178</p><p>4.4.6 The HLA VAL Section178</p><p>4.4.7 Modifying VAL Objects at Arbitrary Points in Your Programs179</p><p>4.5 The HLA TYPE Section180</p><p>4.6 ENUM and HLA Enumerated Data Types181</p><p>4.7 Pointer Data Types182</p><p>4.7.1 Using Pointers in Assembly Language184</p><p>4.7.2 Declaring Pointers in HLA185</p><p>4.7.3 Pointer Constants and Pointer Constant Expressions185</p><p>4.7.4 Pointer Variables and Dynamic Memory Allocation187</p><p>4.7.5 Common Pointer Problems188</p><p>4.8 The HLA Standard Library CHARS.HHF Module192</p><p>4.9 Composite Data Types195</p><p>4.10 Character Strings195</p><p>4.11 HLA Strings198</p><p>4.12 Accessing the Characters Within a String204</p><p>4.13 The HLA String Module and Other String-Related Routines206</p><p>4.14 In-Memory Conversions219</p><p>4.15 Character Sets220</p><p>4.16 Character Set Implementation in HLA221</p><p>4.17 HLA Character Set Constants and Character Set Expressions223</p><p>4.18 The IN Operator in HLA HLL Boolean Expressions224</p><p>4.19 Character Set Support in the HLA Standard Library225</p><p>4.20 Using Character Sets in Your HLA Programs229</p><p>4.21 Arrays230</p><p>4.22 Declaring Arrays in Your HLA Programs231</p><p>4.23 HLA Array Constants232</p><p>4.24 Accessing Elements of a Single Dimension Array233</p><p>4.24.1 Sorting an Array of Values235</p><p>4.25 Multidimensional Arrays237</p><p>4.25.1 Row Major Ordering238</p><p>4.25.2 Column Major Ordering242</p><p>4.26 Allocating Storage for Multidimensional Arrays243</p><p>4.27 Accessing Multidimensional Array Elements in Assembly Language245</p><p>4.28 Large Arrays and MASM(Windows Programmers Only)246</p><p>4.29 Records247</p><p>4.30 Record Constants249</p><p>4.31 Arrays of Records250</p><p>4.32 Arrays/Records as Record Fields251</p><p>4.33 Controlling Field Offsets Within a Record255</p><p>4.34 Aligning Fields Within a Record256</p><p>4.35 Pointers to Records257</p><p>4.36 Unions259</p><p>4.37 Anonymous Unions262</p><p>4.38 Variant Types262</p><p>4.39 Union Constants263</p><p>4.40 Namespaces264</p><p>4.41 Dynamic Arrays in Assembly Language268</p><p>4.42 HLA Standard Library Array Support270</p><p>4.43 For More Information273</p><p>5 PROCEDURES AND UNITS275</p><p>5.1 Chapter Overview275</p><p>5.2 Procedures276</p><p>5.3 Saving the State of the Machine278</p><p>5.4 Prematurely Returning from a Procedure282</p><p>5.5 Local Variables283</p><p>5.6 Other Local and Global Symbol Types289</p><p>5.7 Parameters289</p><p>5.7.1 Pass by Value290</p><p>5.7.2 Pass by Reference293</p><p>5.8 Functions and Function Results296</p><p>5.8.1 Returning Function Results297</p><p>5.8.2 Instruction Composition in HLA298</p><p>5.8.3 The HLA @RETURNS Option in Procedures301</p><p>5.9 Recursion303</p><p>5.10 Forward Procedures307</p><p>5.11 Low Level Procedures and the CALL Instruction308</p><p>5.12 Procedures and the Stack311</p><p>5.13 Activation Records314</p><p>5.14 The Standard Entry Sequence317</p><p>5.15 The Standard Exit Sequence318</p><p>5.16 Low Level Implementation of Automatic(Local)Variables320</p><p>5.17 Low Level Parameter Implementation322</p><p>5.17.1 Passing Parameters in Registers322</p><p>5.17.2 Passing Parameters in the Code Stream325</p><p>5.17.3 Passing Parameters on the Stack328</p><p>5.18 Procedure Pointers350</p><p>5.19 Procedure Parameters354</p><p>5.20 Untyped Reference Parameters355</p><p>5.21 Managing Large Programs356</p><p>5.22 The #INCLUDE Directive357</p><p>5.23 Ignoring Duplicate #INCLUDE Operations358</p><p>5.24 UNITs and the EXTERNAL Directive359</p><p>5.24.1 Behavior of the EXTERNAL Directive364</p><p>5.24.2 Header Files in HLA365</p><p>5.25 Namespace Pollution366</p><p>5.26 For More Information369</p><p>6 ARITHMETIC371</p><p>6.1 Chapter Overview371</p><p>6.2 80x86 Integer Arithmetic Instructions371</p><p>6.2.1 The MUL and IMUL Instructions371</p><p>6.2.2 The DIV and IDIV Instructions375</p><p>6.2.3 The CMP Instruction378</p><p>6.2.4 The SETcc Instructions382</p><p>6.2.5 The TEST Instruction384</p><p>6.3 Arithmetic Expressions385</p><p>6.3.1 Simple Assignments386</p><p>6.3.2 Simple Expressions387</p><p>6.3.3 Complex Expressions389</p><p>6.3.4 Commutative Operators395</p><p>6.4 Logical(Boolean)Expressions396</p><p>6.5 Machine and Arithmetic Idioms398</p><p>6.5.1 Multiplying Without MUL,IMUL,or INTMUL398</p><p>6.5.2 Division Without DIV or IDIV400</p><p>6.5.3 Implementing Modulo-N Counters with AND400</p><p>6.5.4 Careless Use of Machine Idioms401</p><p>6.6 Floating Point Arithmetic401</p><p>6.6.1 FPU Registers402</p><p>6.6.2 FPU Data Types408</p><p>6.6.3 The FPU Instruction Set410</p><p>6.6.4 FPU Data Movement Instructions410</p><p>6.6.5 Conversions412</p><p>6.6.6 Arithmetic Instructions414</p><p>6.6.7 Comparison Instructions420</p><p>6.6.8 Constant Instructions422</p><p>6.6.9 Transcendental Instructions422</p><p>6.6.10 Miscellaneous Instructions424</p><p>6.6.11 Integer Operations426</p><p>6.7 Converting Floating Point Expressions to Assembly Language426</p><p>6.7.1 Converting Arithmetic Expressions to Postfix Notation428</p><p>6.7.2 Converting Postfix Notation to Assembly Language430</p><p>6.8 HLA Standard Library Support for Floating Point Arithmetic431</p><p>6.8.1 The stdin.getf and fileio.getf Functions431</p><p>6.8.2 Trigonometric Functions in the HLA Math Library432</p><p>6.8.3 Exponential and Logarithmic Functions in the HLA Math Library433</p><p>6.9 Putting It All Together434</p><p>7 LOW LEVEL CONTROL STRUCTURES434</p><p>7.1 Chapter Overview435</p><p>7.2 Low Level Control Structures435</p><p>7.3 Statement Labels436</p><p>7.4 Unconditional Transfer of Control(JMP)438</p><p>7.5 The Conditional Jump Instructions441</p><p>7.6 &quot;Medium Level&quot; Control Structures:JT and JF444</p><p>7.7 Implementing Common Control Structures in Assembly Language445</p><p>7.8 Introduction to Decisions445</p><p>7.8.1 IF..THEN..ELSE Sequences447</p><p>7.8.2 Translating HLA IF Statements into Pure Assembly Language451</p><p>7.8.3 Implementing Complex IF Statements Using Complete Boolean Evaluation456</p><p>7.8.4 Short-Circuit Boolean Evaluation457</p><p>7.8.5 Short-Circuit vs.Complete Boolean Evaluation459</p><p>7.8.6 Efficient Implementation of IF Statements in Assembly Language461</p><p>7.8.7 SWITCH/CASE Statements466</p><p>7.9 State Machines and Indirect Jumps477</p><p>7.10 Spaghetti Code480</p><p>7.11 Loops481</p><p>7.11.1 WHILE Loops482</p><p>7.11.2 REPEAT..UNTILLoops483</p><p>7.11.3 FOREVER..ENDFOR Loops484</p><p>7.11.4 FOR Loops485</p><p>7.11.5 The BREAK and CONTINUE Statements486</p><p>7.11.6 Register Usage and Loops490</p><p>7.12 Performance Improvements491</p><p>7.12.1 Moving the Termination Condition to the End of a Loop492</p><p>7.12.2 Executing the Loop Backward494</p><p>7.12.3 Loop Invariant Computations495</p><p>7.12.4 Unraveling Loops496</p><p>7.12.5 Induction Variables498</p><p>7.13 Hybrid Control Structures in HLA499</p><p>7.14 For More Information501</p><p>8 FILES503</p><p>8.1 Chapter Overview503</p><p>8.2 File Organization503</p><p>8.2.1 Files as Lists of Records504</p><p>8.2.2 Binary vs.Text Files506</p><p>8.3 Sequential Files508</p><p>8.4 Random Access Files516</p><p>8.5 ISAM(Indexed Sequential Access Method)Files520</p><p>8.6 Truncating a File524</p><p>8.7 For More Information525</p><p>9 ADVANCED ARITHMETIC527</p><p>9.1 Chapter Overview527</p><p>9.2 Multiprecision Operations528</p><p>9.2.1 HLA Standard Library Support for Extended Precision Operations528</p><p>9.2.2 Multiprecision Addition Operations531</p><p>9.2.3 Multiprecision Subtraction Operations534</p><p>9.2.4 Extended Precision Comparisons535</p><p>9.2.5 Extended Precision Multiplication539</p><p>9.2.6 Extended Precision Division543</p><p>9.2.7 Extended Precision NEG Operations553</p><p>9.2.8 Extended Precision AND Operations555</p><p>9.2.9 Extended Precision OR Operations555</p><p>9.2.10 Extended Precision XOR Operations556</p><p>9.2.11 Extended Precision NOT Operations556</p><p>9.2.12 Extended Precision Shift Operations556</p><p>9.2.13 Extended Precision Rotate Operations560</p><p>9.2.14 Extended Precision I/O561</p><p>9.3 Operating on Different-Sized Operands582</p><p>9.4 Decimal Arithmetic584</p><p>9.4.1 Literal BCD Constants585</p><p>9.4.2 The 80x86 DAA and DAS Instructions586</p><p>9.4.3 The 80x86 AAA,AAS,AAM,and AAD Instructions588</p><p>9.4.4 Packed Decimal Arithmetic Using the FPU589</p><p>9.5 Tables591</p><p>9.5.1 Function Computation via Table Look-Up592</p><p>9.5.2 Domain Conditioning597</p><p>9.5.3 Generating Tables598</p><p>9.5.4 Table Look-Up Performance601</p><p>9.6 For More Information602</p><p>10 MACROS AND THE HLA COMPILE TIME LANGUAGE602</p><p>10.1 Chapter Overview603</p><p>10.2 Introduction to the Compile Time Language(CTL)603</p><p>10.3 The #PRINT and #ERROR Statements605</p><p>10.4 Compile Time Constants and Variables607</p><p>10.5 Compile Time Expressions and Operators607</p><p>10.6 Compile Time Functions610</p><p>10.6.1 Type Conversion Compile Time Functions611</p><p>10.6.2 Numeric Compile Time Functions612</p><p>10.6.3 Character Classification Compile Time Functions613</p><p>10.6.4 Compile Time String Functions613</p><p>10.6.5 Compile Time Pattern Matching Functions614</p><p>10.6.6 Compile Time Symbol Information615</p><p>10.6.7 Miscellaneous Compile Time Functions616</p><p>10.6.8 Compile Time Type Conversions of TEXT Objects617</p><p>10.7 Conditional Compilation(Compile Time Decisions)618</p><p>10.8 Repetitive Compilation(Compile Time Loops)623</p><p>10.9 Macros(Compile Time Procedures)627</p><p>10.9.1 Standard Macros627</p><p>10.9.2 Macro Parameters629</p><p>10.9.3 Local Symbols in a Macro636</p><p>10.9.4 Macros as Compile Time Procedures639</p><p>10.9.5 Simulating Function Overloading with Macros640</p><p>10.10 Writing Compile Time &quot;Programs&quot;646</p><p>10.10.1 Constructing Data Tables at Compile Time646</p><p>10.10.2 Unrolling Loops651</p><p>10.11 Using Macros in Different Source Files653</p><p>10.12 For More Information653</p><p>11 BIT MANIPULATION655</p><p>11.1 Chapter Overview655</p><p>11.2 What Is Bit Data,Anyway?656</p><p>11.3 Instructions That Manipulate Bits657</p><p>11.4 The Carry Flag as a Bit Accumulator665</p><p>11.5 Packing and Unpacking Bit Strings666</p><p>11.6 Coalescing Bit Sets and Distributing Bit Strings669</p><p>11.7 Packed Arrays of Bit Strings671</p><p>11.8 Searching for a Bit673</p><p>11.9 Counting Bits676</p><p>11.10 Reversing a Bit String679</p><p>11.11 Merging Bit Strings681</p><p>11.12 Extracting Bit Strings682</p><p>11.13 Searching for a Bit Pattern683</p><p>11.14 The HLA Standard Library Bits Module684</p><p>11.15 For More Information687</p><p>12 THE STRING INSTRUCTIONS687</p><p>12.1 Chapter Overview689</p><p>12.2 The 80x86 String Instructions690</p><p>12.2.1 How the String Instructions Operate690</p><p>12.2.2 The REP/REPE/REPZ and REPNZ/REPNE Prefixes691</p><p>12.2.3 The Direction Flag692</p><p>12.2.4 The MOVS Instruction694</p><p>12.2.5 The CMPS Instruction700</p><p>12.2.6 The SCAS Instruction703</p><p>12.2.7 The STOS Instruction704</p><p>12.2.8 The LODS Instruction705</p><p>12.2.9 Building Complex String Functions from LODS and STOS705</p><p>12.3 Performance of the 80x86 String Instructions706</p><p>12.4 For More Information707</p><p>13 THE MMX INSTRUCTION SET709</p><p>13.1 Chapter Overview709</p><p>13.2 Determining Whether a CPU Supports the MMX Instruction Set710</p><p>13.3 The MMX Programming Environment711</p><p>13.3.1 The MMX Registers711</p><p>13.3.2 The MMX Data Types713</p><p>13.4 The Purpose of the MMX Instruction Set714</p><p>13.5 Saturation Arithmetic and Wrap-Around Mode714</p><p>13.6 MMX Instruction Operands715</p><p>13.7 MMX Technology Instructions717</p><p>13.7.1 MMX Data Transfer Instructions718</p><p>13.7.2 MMX Conversion Instructions718</p><p>13.7.3 MMX Packed Arithmetic Instructions723</p><p>13.7.4 MMX Logical Instructions726</p><p>13.7.5 MMX Comparison Instructions727</p><p>13.7.6 MMX Shift Instructions731</p><p>13.7.7 The EMMS Instruction733</p><p>13.8 The MMX Programming Paradigm734</p><p>13.9 For More Information745</p><p>14 CLASSES AND OBJECTS747</p><p>14.1 Chapter Overview747</p><p>14.2 General Principles748</p><p>14.3 Classes in HLA750</p><p>14.4 Objects753</p><p>14.5 Inheritance755</p><p>14.6 Overriding756</p><p>14.7 Virtual Methods vs.Static Procedures757</p><p>14.8 Writing Class Methods and Procedures759</p><p>14.9 Object Implementation764</p><p>14.9.1 Virtual Method Tables767</p><p>14.9.2 Object Representation with Inheritance769</p><p>14.10 Constructors and Object Initialization773</p><p>14.10.1 Dynamic Object Allocation Within the Constructor775</p><p>14.10.2 Constructors and Inheritance777</p><p>14.10.3 Constructor Parameters and Procedure Overloading781</p><p>14.11 Destructors782</p><p>14.12 HLA's &quot;_initialize_&quot; and &quot;_finalize_&quot; Strings783</p><p>14.13 Abstract Methods789</p><p>14.14 Run-Time Type Information(RTTI)792</p><p>14.15 Calling Base Class Methods794</p><p>14.16 For More Information795</p><p>15 MIXED LANGUAGE PROGRAMMING797</p><p>15.1 Chapter Overview797</p><p>15.2 Mixing HLA and MASM/Gas Code in the Same Program798</p><p>15.2.1 In-Line(MASM/Gas)Assembly Code in Your HLA Programs798</p><p>15.2.2 Linking MASM/Gas-Assembled Modules with HLA Modules801</p><p>15.3 Programming in Delphi/Kylix and HLA805</p><p>15.3.1 Linking HLA Modules with Delphi/Kylix Programs806</p><p>15.3.2 Register Preservation810</p><p>15.3.3 Function Results811</p><p>15.3.4 Calling Conventions817</p><p>15.3.5 Pass by Value,Reference,CONST,and OUT in Kylix823</p><p>15.3.6 Scalar Data Type Correspondence Between Delphi/Kylix and HLA825</p><p>15.3.7 Passing String Data Between Delphi/Kylix and HLA Code826</p><p>15.3.8 Passing Record Data Between HLA and Kylix829</p><p>15.3.9 Passing Set Data Between Delphi/Kylix and HLA833</p><p>15.3.10 Passing Array Data Between HLA and Delphi/Kylix834</p><p>15.3.11 Referencing Delphi/Kylix Objects from HLA Code834</p><p>15.4 Programming in C/C++ and HLA837</p><p>15.4.1 Linking HLA Modules with C/C++ Programs839</p><p>15.4.2 Register Preservation842</p><p>15.4.3 Function Results842</p><p>15.4.4 Calling Conventions842</p><p>15.4.5 Pass by Value and Reference in C/C++847</p><p>15.4.6 Scalar Data Type Correspondence Between C/C++ and HLA847</p><p>15.4.7 Passing String Data Between C/C++ and HLA Code849</p><p>15.4.8 Passing Record/Structure Data Between HLA and C/C++849</p><p>15.4.9 Passing Array Data Between HLA and C/C++851</p><p>15.5 For More Information852</p><p>A ASCII CHARACTER SET853</p><p>B THE 80X86 INSTRUCTION SET857</p><p>INDEX889</p><p></p></div></div><div class="d-rt"><h3>热门推荐</h3><ul><li><a href="/book/294199.html">294199.html</a></li><li><a href="/book/469831.html">469831.html</a></li><li><a href="/book/2224999.html">2224999.html</a></li><li><a href="/book/1466881.html">1466881.html</a></li><li><a href="/book/1075242.html">1075242.html</a></li><li><a href="/book/3130140.html">3130140.html</a></li><li><a href="/book/2375926.html">2375926.html</a></li><li><a href="/book/376899.html">376899.html</a></li><li><a href="/book/2308046.html">2308046.html</a></li><li><a href="/book/2728375.html">2728375.html</a></li></ul></div></div><div id="footer"><p>Copyright&nbsp;&copy;&nbsp;2025&nbsp;&nbsp;<a href="/list/">最新更新</a></p><p>请使用FDM BitComet qBittorrent uTorrent等BT下载工具，下载本站电子书资源！首推Free Download Manager下载软件。文件页数>标注页数[分册图书除外]</p></div></body></html>