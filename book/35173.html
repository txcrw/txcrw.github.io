<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><script type="text/javascript" src="https://file.bkxsj.com/skin/book/js/sk.js"></script><meta name="robots" content="index,follow"><title>深入解析Android 5.0系统[PDF|Epub|txt|kindle电子书版本网盘下载]-灵感之桥</title><meta name="Keywords" content="深入解析Android 5.0系统"/><meta name="description" content="深入解析Android 5.0系统pdf下载文件大小为114MB,PDF页数为725页"/><meta http-equiv="X-UA-Compatible" content="IE=9; IE=8; IE=7; IE=EDGE;chrome=1"><link type="image/x-icon" rel="shortcut icon" href="https://www.shukui.net/skin/book/images/favicon.ico"><link type="text/css" rel="stylesheet" href="https://www.shukui.net/skin/book/css/style.css"><style>#main .d-main {margin-left: 0;width: 620px;}.down-btn {animation: myShake 2.5s linear .15s infinite}@keyframes myShake {0%, 66% {transform: translateZ(0)}67%, 73.6%, 83.6%, 93.6%, to {animation-timing-function: cubic-bezier(.215, .61, .355, 1);transform: translateZ(0)}80.3%, 81.4% {animation-timing-function: cubic-bezier(.755, .05, .855, .06);transform: translate3d(0, -4px, 0)}90.3% {animation-timing-function: cubic-bezier(.755, .05, .855, .06);transform: translate3d(0, -2px, 0)}97% {transform: translate3d(0, -.5px, 0)}}.copylink-btn {margin-right: 20px;}.copymd5-btn {margin-bottom: 25px;margin-left: 10px;}</style></head><body><div id="header"><div class="inner"><div class="logo"><a href="/"><img width="103" height="25" alt="灵感之桥"src="https://www.shukui.net/skin/book/images/logo.png"></a></div><div class="search"><form action="/so/search.php" target="_blank"><input type="text" autocomplete="off" id="bdcsMain" name="q" placeholder="书名 / 作者 / 出版社 / ISBN"class="inp-txt"><select class="inp-select" id="datasource" onchange="selectDatasource(this)"><option value="so">主库</option><option value="s">从库</option></select><input type="submit" value="搜索" class="inp-btn"></form></div></div></div><div id="main"><div class="d-main"><div class="tit"><h3>图书介绍</h3></div><h1 class="book-name">深入解析Android 5.0系统PDF|Epub|txt|kindle电子书版本网盘下载</h1><div class="d-info"><div class="b-thumb"><img src="https://www.shukui.net/cover/39/30041176.jpg" alt="深入解析Android 5.0系统"></div><div class="b-info"><ul><li>刘超著 著</li><li>出版社： 北京：人民邮电出版社</li><li>ISBN：9787115384560</li><li>出版时间：2015</li><li>标注页数：709页</li><li>文件大小：114MB</li><li>文件页数：725页</li><li>主题词：移动终端－应用程序－程序设计</li></ul></div></div><div class="tit"><h3>PDF下载</h3></div><div></br><a style="color:red;" rel="external nofollow" href="https://www.kjlm.net/ebook/35173.html"target="_blank"><b>点此进入-本书在线PDF格式电子书下载【推荐-云解压-方便快捷】直接下载PDF格式图书。移动端-PC端通用</a></b></br><a class="down-btn" rel="external nofollow" href="https://down.trackerbk.com/bt/00/30041176.torrent"target="_blank">种子下载</a>[BT下载速度快]温馨提示：（请使用BT下载软件FDM进行下载）<a rel="nofollow" href="https://www.freedownloadmanager.org/zh/" target="_blank">软件下载地址页</a><a class="down-btn" rel="external nofollow" href="https://down.p2spdb.com/00/30041176.rar" target="_blank">直链下载</a>[便捷但速度慢]&nbsp;&nbsp;<a style="color:red;" rel="external nofollow" href="https://pdfyl.ertongbook.com/01/30041176.pdf" target="_blank"><b>[在线试读本书]</b></a>&nbsp;&nbsp;<b> <a style="color:red;" rel="external nofollow" href="https://web.jyjl.org/index/recovery.html" target="_blank">[在线获取解压码]</a></b><div class="copymd5-btn"><a href="javascript:copyToClip('3560112df2203b9a90f5f4fa39c6e841')">点击复制MD5值：3560112df2203b9a90f5f4fa39c6e841</a></div></div><div class="tit"><h3>下载说明</h3></div><div style="margin:20px 10px"><h2>深入解析Android 5.0系统PDF格式电子书版下载</h2>下载的文件为RAR压缩包。需要使用解压软件进行解压得到PDF格式图书。<br><br><div class="copymd5-btn"><a href="javascript:copyToClip('magnet:?xt=urn:btih:RX6G6JQ2LJW7PBBEDNUSCQM7ICDMHIWK')">点击复制85GB完整离线版磁力链接到迅雷FDM等BT下载工具进行下载</a>&nbsp;&nbsp;<a rel="nofollow" target="_blank">详情点击-查看共享计划</a></div>建议使用BT下载工具Free Download Manager进行下载,简称FDM(免费,没有广告,支持多平台）。本站资源全部打包为BT种子。所以需要使用专业的BT下载软件进行下载。如BitComet qBittorrent uTorrent等BT下载工具。迅雷目前由于本站不是热门资源。不推荐使用！后期资源热门了。安装了迅雷也可以迅雷进行下载！<br><br><b>（文件页数 要大于 标注页数，上中下等多册电子书除外）</b><br><br><p style="color:red;"> <b>注意：本站所有压缩包均有解压码：</b> <a rel="nofollow" target="_blank"><b>点击下载压缩包解压工具</b></a></p></div><div class="tit"><h3>图书目录</h3></div><div id="book-contents"><p>第1章 建立Android系统开发环境1</p><p>1.1 安装操作系统1</p><p>1.1.1 安装方式的选择1</p><p>1.1.2 下载和安装Ubuntu1</p><p>1.1.3 使用Ubuntu遇到的问题2</p><p>1.2 安装开发包3</p><p>1.2.1 安装JDK 1.63</p><p>1.2.2 安装OpenJDK 1.74</p><p>1.2.3 安装编译需要的开发包4</p><p>1.3 安装一些有用的工具4</p><p>1.3.1 安装Android SDK4</p><p>1.3.2 安装Android Studio4</p><p>1.3.3 安装Source Insight5</p><p>1.3.4 安装比较工具Meld5</p><p>1.4 下载源码5</p><p>1.4.1 Git and Repo简介5</p><p>1.4.2 源码版本历史6</p><p>1.4.3 下载Android源码7</p><p>1.4.4 下载Kernel源码8</p><p>第2章 Android的编译环境——Build系统10</p><p>2.1 Android Build系统核心10</p><p>2.1.1 编译环境的建立11</p><p>2.1.2 Build相关的环境变量14</p><p>2.1.3 Build系统的层次关系15</p><p>2.1.4 分析main.mk文件17</p><p>2.1.5 Build系统的编译目标介绍20</p><p>2.1.6 分析config.mk文件22</p><p>2.1.7 分析product_config.mk文件24</p><p>2.1.8 Android 5.0中的64位编译26</p><p>2.2 Android的产品配置文件27</p><p>2.2.1 分析hammerhead的配置文件27</p><p>2.2.2 编译类型eng、 user和userdebug31</p><p>2.2.3 产品的Image文件32</p><p>2.2.4 如何加快编译速度33</p><p>2.2.5 如何编译Android的模拟器34</p><p>2.3 编译Android的模块34</p><p>2.3.1 模块编译变量简介35</p><p>2.3.2 常用模块定义实例36</p><p>2.3.3 预编译模块的目标定义37</p><p>2.3.4 常用“LOCAL”变量39</p><p>2.4 Android中的签名40</p><p>2.4.1 Android应用签名方法41</p><p>2.4.2 Android系统签名介绍43</p><p>2.4.3 Android签名漏洞分析44</p><p>第3章 连接Android和Linu内核的桥梁——Android的Bionic46</p><p>3.1 Bionic简介46</p><p>3.1.1 Bionic的特性46</p><p>3.1.2 Bionic中的模块简介49</p><p>3.2 Bionic C库中的系统调用50</p><p>3.2.1 系统调用简介50</p><p>3.2.2 系统调用的实现方法51</p><p>3.3 Bionic中的内存管理函数52</p><p>3.3.1 系统调用brk和mmap52</p><p>3.3.2 内存分配器——dlmalloc简介53</p><p>3.3.3 dlmalloc函数用法指南54</p><p>3.4 管道57</p><p>3.4.1 匿名管道PIPE和命名管道FIFO57</p><p>3.4.2 匿名管道的使用方法58</p><p>3.5 Bionic中的线程管理函数59</p><p>3.5.1 Bionic线程函数的特性59</p><p>3.5.2 创建线程和线程的属性59</p><p>3.5.3 退出线程的方法61</p><p>3.5.4 线程本地存储TLS62</p><p>3.5.5 线程的互斥量（Mutex）函数63</p><p>3.5.6 线程的条件量（Condition）函数65</p><p>3.6 Futex同步机制66</p><p>3.6.1 Futex的系统调用66</p><p>3.6.2 Futex的用户态操作67</p><p>3.6.3 Mutex类使用Futex实现同步68</p><p>3.7 Android的Log模块68</p><p>3.7.1 Android Log系统的架构69</p><p>3.7.2 Log系统的接口和用法70</p><p>3.7.3 Log系统的实现分析71</p><p>3.8 可执行文件格式分析75</p><p>3.8.1 ELF格式简介75</p><p>3.8.2 ELF文件头格式76</p><p>3.8.3 程序头部表77</p><p>3.8.4 与重定位相关的“节区”的信息——DYNAMIC段79</p><p>3.8.5 函数的重定位过程81</p><p>3.9 Bionic中的Linker模块84</p><p>3.9.1 可执行程序的装载84</p><p>3.9.2 可执行程序的初始化85</p><p>3.9.3 Linker装载动态库87</p><p>3.10 调试器——Ptrace和Hook API91</p><p>3.10.1 ptrace函数简介91</p><p>3.10.2 Hook API的原理92</p><p>3.10.3 利用ptrace实现Hook API93</p><p>第4章 进程间通信——Android的Binder98</p><p>4.1 Binder简介98</p><p>4.1.1 Binder对象定义98</p><p>4.1.2 Binder的架构99</p><p>4.1.3 组件Service和匿名Binder服务100</p><p>4.1.4 Binder的层次101</p><p>4.2 如何使用Binder102</p><p>4.2.1 使用Binder服务102</p><p>4.2.2 Binder的混合调用102</p><p>4.2.3 用Jave开发Binder服务103</p><p>4.2.4 用C+++开发Binder服务104</p><p>4.3 Binder应用层的核心类106</p><p>4.3.1 IInterface中的两个宏106</p><p>4.3.2 Binder核心类的关系107</p><p>4.3.3 函数asInterface的奥秘109</p><p>4.3.4 Binder的“死亡通知”110</p><p>4.3.5 Jave层的Binder类111</p><p>4.4 Binder的实现原理115</p><p>4.4.1 Binder的线程模型115</p><p>4.4.2 Binder对象的传递119</p><p>4.4.3 分析IPCThreadState类122</p><p>4.5 Binder驱动126</p><p>4.5.1 应用层和驱动的消息协议126</p><p>4.5.2 Binder驱动分析129</p><p>4.5.3 Binder的内存共享机制130</p><p>4.5.4 驱动的ioctl操作131</p><p>4.5.5 Binder调用过程133</p><p>4.5.6 处理传递的Binder对象138</p><p>4.6 解析名称的模块——ServiceManager的作用140</p><p>4.6.1 ServiceManager的架构141</p><p>4.6.2 ServiceManger提供的服务143</p><p>4.7 匿名共享内存ashmem146</p><p>4.7.1 ashmem的作用和用法146</p><p>4.7.2 ashmem驱动的实现原理148</p><p>4.7.3 ashemem驱动的代码分析149</p><p>4.7.4 进程间传递文件描述符152</p><p>第5章 连接Java和C/C+层的关键——Android的JNI154</p><p>5.1 JNI的作用154</p><p>5.2 JNI用法介绍154</p><p>5.2.1 从Java到C/C+++154</p><p>5.2.2 从C/C+++到Java的调用158</p><p>5.3 JNI环境160</p><p>5.3.1 结构体JNIEnv160</p><p>5.3.2 JNIEnv的创建和初始化162</p><p>5.3.3 JNI中的异常处理163</p><p>5.3.4 JNI中的引用164</p><p>5.3.5 指明错误位置——“CheckJNI”的作用165</p><p>5.4 ART带来的JNI变化165</p><p>5.4.1 垃圾回收的影响165</p><p>5.4.2 错误处理的变化166</p><p>5.4.3 堆栈可能引发的问题166</p><p>第6章 Android的同步和消息机制167</p><p>6.1 原子操作167</p><p>6.1.1 Android的原子操作函数167</p><p>6.1.2 原子操作的实现原理168</p><p>6.1.3 内存屏障和编译屏障169</p><p>6.2 Android native层的同步方法171</p><p>6.2.1 互斥体Mutex和自动锁Autolock171</p><p>6.2.2 解决线程同步——条件类Condition173</p><p>6.3 Android Java层的同步机制174</p><p>6.3.1 同步关键字synchronized174</p><p>6.3.2 Object类在同步中的作用175</p><p>6.4 Android的消息机制176</p><p>6.4.1 消息模型177</p><p>6.4.2 理解Looper类178</p><p>6.4.3 理解Handler类180</p><p>6.4.4 消息的同步——Message类的setAsynchronous（）方法181</p><p>6.4.5 分析MessageQueue类182</p><p>6.5 进程间的消息传递186</p><p>6.5.1 理解Messenger类187</p><p>6.5.2 建立通信通道——AsyncChannel类的作用187</p><p>第7章 第一个用户进程——Android的Init进程192</p><p>7.1 Init进程的初始化过程194</p><p>7.1.1 main函数的流程194</p><p>7.1.2 启动Service进程199</p><p>7.2 解析启动脚本init.rc202</p><p>7.2.1 init.rc文件格式介绍202</p><p>7.2.2 Init脚本的关键字定义203</p><p>7.2.3 脚本文件的解析过程205</p><p>7.2.4 Init中启动的守护进程210</p><p>7.3 Init进程对信号的处理212</p><p>7.3.1 “僵尸”（Zombie）进程介绍212</p><p>7.3.2 初始化SIGCHLD信号212</p><p>7.3.3 响应子进程死亡事件213</p><p>7.4 属性系统215</p><p>7.4.1 属性系统介绍216</p><p>7.4.2 创建属性系统的共享空间218</p><p>7.4.3 初始化属性系统的值219</p><p>7.4.4 用户进程初始化属性系统220</p><p>7.4.5 响应修改属性的请求221</p><p>7.5 守护进程ueventd介绍222</p><p>7.5.1 ueventd的初始化223</p><p>7.5.2 内核和用户空间交换信息——Netlink Socket简介224</p><p>7.5.3 创建设备节点文件225</p><p>7.6 “看门狗”watchdogd介绍227</p><p>第8章 支撑Android世界的一极——Zygote进程229</p><p>8.1 Zygote简介229</p><p>8.2 Zygote进程的初始化229</p><p>8.2.1 app_porcess的main函数230</p><p>8.2.2 启动虚拟机——AndroidRuntime类233</p><p>8.2.3 启动虚拟机234</p><p>8.2.4 初始化工作——ZygoteInit类236</p><p>8.3 Zygote启动应用程序237</p><p>8.3.1 注册Zygote的socket237</p><p>8.3.2 请求启动应用238</p><p>8.3.3 处理启动应用的请求239</p><p>8.3.4 Fork应用进程240</p><p>8.3.5 子进程的初始化241</p><p>8.4 预加载系统类和资源244</p><p>8.4.1 预加载Java类244</p><p>8.4.2 preload-classes文件245</p><p>8.4.3 预加载系统资源247</p><p>8.4.4 预加载共享库247</p><p>第9章 精确地控制资源的使用——Android的资源管理248</p><p>9.1 资源系统简介248</p><p>9.1.1 缺省资源和候选资源248</p><p>9.1.2 常用术语和单位248</p><p>9.1.3 资源类型249</p><p>9.1.4 系统资源定义250</p><p>9.2 Android资源的制作252</p><p>9.2.1 资源的存储目录252</p><p>9.2.2 候选资源目录的命名规则253</p><p>9.2.3 资源匹配算法255</p><p>9.3 Android资源的使用256</p><p>9.3.1 常规的资源使用方法256</p><p>9.3.2 使用公开和非公开资源257</p><p>9.3.3 图片资源的缩放问题258</p><p>9.4 Android资源管理的实现原理260</p><p>9.4.1 Resources类的作用260</p><p>9.4.2 AssetManager类的作用263</p><p>9.4.3 理解AssetManager的设计265</p><p>9.5 全新的设计语言——Android 5.0的Material Design270</p><p>9.5.1 Material Design的设计原则271</p><p>9.5.2 Material主题271</p><p>9.5.3 View的阴影272</p><p>第10章 Android系统的核心之——SystemServer进程274</p><p>10.1 SystemServer的创建过程274</p><p>10.1.1 创建SystemServer进程274</p><p>10.1.2 SystemServer初始化276</p><p>10.1.3 SystemServer的服务大全279</p><p>10.2 SystemServer中的Watchdog281</p><p>10.2.1 启动Watchdog281</p><p>10.2.2 Watchdog监控的服务和线程282</p><p>10.2.3 Watchdog监控的原理283</p><p>第11章 APK包的安装、卸载和优化——Android的应用管理287</p><p>11.1 了解PackageManagerService288</p><p>11.1.1 理解Packages.xml和Settings类289</p><p>11.1.2 服务的初始化过程291</p><p>11.1.3 处理permission文件298</p><p>11.1.4 扫描应用目录的过程300</p><p>11.1.5 解析APK文件304</p><p>11.2 安装应用306</p><p>11.2.1 管理“安装会话”——PackageManagerInstaller Service306</p><p>11.2.2 应用安装第一阶段：复制文件307</p><p>11.2.3 应用安装第二阶段：装载应用313</p><p>11.3 系统运行时的应用管理316</p><p>11.3.1 卸载应用316</p><p>11.3.2 通过Intent查询组件318</p><p>11.4 守护进程installd320</p><p>11.4.1 installd的初始化320</p><p>11.4.2 变更installd进程的权限321</p><p>11.4.3 installd中支持的命令322</p><p>11.4.4 分析install（安装）命令323</p><p>11.4.5 分析patchoat（优化）命令324</p><p>11.4.6 分析movefiles（移动）命令326</p><p>第12章 Android的组件管理327</p><p>12.1 应用进程的组成327</p><p>12.1.1 ApplicationThread的作用328</p><p>12.1.2 理解应用的Context329</p><p>12.1.3 Application类330</p><p>12.2 Android框架的核心——ActivityManagerService服务332</p><p>12.2.1 ActivityManagerService的初始化333</p><p>12.2.2 理解setSystemProcess（）方法334</p><p>12.2.3 理解systemReady（）方法335</p><p>12.3 Process管理339</p><p>12.3.1 如何启动进程339</p><p>12.3.2 调整进程的位置341</p><p>12.3.3 ProcessList的常量343</p><p>12.3.4 调整进程的oom adj值344</p><p>12.4 Activity管理347</p><p>12.4.1 Activity的生命周期347</p><p>12.4.2 理解Intent348</p><p>12.4.3 Task和LauncherMode349</p><p>12.5 应用的启动过程352</p><p>12.5.1 启动Activity352</p><p>12.5.2 resumeTopActivities Locked方法355</p><p>12.5.3 ActivityThread的main方法357</p><p>12.5.4 AM S的attachApplication方法358</p><p>12.5.5 应用的handleBind Application方法360</p><p>12.6 Service管理361</p><p>12.6.1 Service的生命周期362</p><p>12.6.2 理解Service的管理类363</p><p>12.6.3 Service的启动过程363</p><p>12.7 提供数据的访问——ContentProvider管理368</p><p>12.7.1 理解ContentProvider368</p><p>12.7.2 获取ContentProvider370</p><p>12.7.3 应用中安装Content Provider373</p><p>12.7.4 发布ContentProvider375</p><p>12.8 广播——BroadcastReceiver管理376</p><p>12.8.1 理解BroadcastReceiver377</p><p>12.8.2 广播的种类378</p><p>12.8.3 广播的数据结构378</p><p>12.8.4 广播的注册过程380</p><p>12.8.5 广播的发送过程381</p><p>第13章 Android的多用户模式388</p><p>13.1 管理用户的系统服务——UserManagerService服务388</p><p>13.1.1 初始化388</p><p>13.1.2 用户的UserInfo定义389</p><p>13.1.3 用户限制（Restriction）390</p><p>13.1.4 添加用户391</p><p>13.1.5 删除用户393</p><p>13.1.6 Guest用户395</p><p>13.2 PackageManagerService和多用户395</p><p>13.2.1 创建用户的应用数据395</p><p>13.2.2 删除用户的应用数据396</p><p>13.3 ActivityManagerServier和多用户396</p><p>13.3.1 用户的状态397</p><p>13.3.2 切换当前用户397</p><p>13.3.3 停止用户运行401</p><p>第14章 Android的图形显示系统404</p><p>14.1 画布——理解Surface404</p><p>14.1.1 应用中Surface的创建过程404</p><p>14.1.2 WMS中Surface的创建过程406</p><p>14.1.3 单实例模式——ComposerService的作用410</p><p>14.1.4 SurfaceFlinger中创建Surface411</p><p>14.1.5 管理图像缓冲区414</p><p>14.1.6 创建GraphicBuffer对象417</p><p>14.2 图像显示原理421</p><p>14.2.1 Project Buffer简介421</p><p>14.2.2 VSync信号的生成424</p><p>14.2.3 Framebuffer的工作原理426</p><p>14.2.4 分配图像缓冲区的内存429</p><p>14.3 SurfaceFlinger服务433</p><p>14.3.1 SurfaceFlinger的启动过程433</p><p>14.3.2 消息和事件分发——MessageQueue和EventThread435</p><p>14.3.3 显示设备——理解DisplayDevice类437</p><p>14.3.4 VSync信号的分发过程440</p><p>14.4 图像的输出过程445</p><p>14.4.1 图像的输出过程445</p><p>14.4.2 理解handleTransaction函数446</p><p>14.4.3 理解handlePageFlip函数451</p><p>14.4.4 理解rebuildLayerStacks函数453</p><p>14.4.5 更新对象中的图层——理解setUpHWComposer函数455</p><p>14.4.6 合成所有层的图像——理解doComposition函数457</p><p>14.4.7 理解postFramebuffer函数458</p><p>14.5 总结459</p><p>第15章 Android的窗口系统460</p><p>15.1 应用进程和WMS的联系460</p><p>15.1.1 应用中的Window对象460</p><p>15.1.2 应用中的Window Manager类461</p><p>15.1.3 建立应用和WMS的联系463</p><p>15.1.4 WMS中建立和应用的联系465</p><p>15.1.5 理解DecorView467</p><p>15.2 WindowManagerService服务468</p><p>15.2.1 PhoneWindowManager对象468</p><p>15.2.2 WindowToken对象469</p><p>15.2.3 窗口类型定义469</p><p>15.2.4 新增窗口的过程471</p><p>15.2.5 确定窗口的Z轴位置475</p><p>15.3 确定窗口尺寸479</p><p>15.3.1 Overscan区域479</p><p>15.3.2 表示窗口尺寸的数据结构480</p><p>15.3.3 计算窗口的尺寸481</p><p>15.4 窗口动画管理485</p><p>15.4.1 接收VSync信号485</p><p>15.4.2 动画的显示过程488</p><p>15.4.3 窗口的动画对象——WindowStateAnimator491</p><p>15.4.4 生成动画并显示493</p><p>15.5 总结494</p><p>第16章 Android的输入管理495</p><p>16.1 管理各种输入的服务——InputManagerService495</p><p>16.1.1 服务的启动过程495</p><p>16.1.2 把消息统一格式——EventHub的作用497</p><p>16.1.3 读取RawEvent500</p><p>16.1.4 处理RawEvent501</p><p>16.1.5 分发输入消息505</p><p>16.2 应用进程处理Input消息508</p><p>16.2.1 理解InputChannel508</p><p>16.2.2 接收Input消息511</p><p>16.2.3 理解InputStage515</p><p>16.2.4 流水线处理Input消息518</p><p>16.3 总结523</p><p>第17章 Android的电源管理524</p><p>17.1 电源管理服务——PowerManagerService524</p><p>17.1.1 初始化过程524</p><p>17.1.2 系统准备工作——SystemReady方法525</p><p>17.1.3 报告用户活动——userActivity接口527</p><p>17.1.4 强制系统进入休眠模式——gotoSleep接口528</p><p>17.2 控制系统休眠的机制529</p><p>17.2.1 PMS中WakeLock相关接口529</p><p>17.2.2 WakeLock的native层实现531</p><p>17.2.3 理解updatePowerStateLocked方法532</p><p>17.2.4 管理显示设备536</p><p>17.3 电池管理服务539</p><p>17.3.1 BattetyService类的作用539</p><p>17.3.2 Healthd守护进程541</p><p>17.3.3 读取电池的各种参数——Battery Monitor类543</p><p>第18章 Android的存储系统545</p><p>18.1 管理存储设备——Vold守护进程546</p><p>18.1.1 Vold的main函数546</p><p>18.1.2 监听驱动发出的消息——Vold的NetlinkManager对象547</p><p>18.1.3 处理block类型的uevent548</p><p>18.1.4 处理MountService的命令552</p><p>18.1.5 VolumeManager的作用——创建实例对象554</p><p>18.2 对存储设备操作——MountService服务557</p><p>18.2.1 MountService的启动过程557</p><p>18.2.2 进行Socket通信——NativeDaemonConnector558</p><p>18.2.3 OBB文件系统561</p><p>18.3 其他存储相关的服务564</p><p>18.3.1 监视存储设备大小——DeviceStorageMonitor Service564</p><p>18.3.2 打印系统分区信息——DiskStatsService566</p><p>第19章 Android的网络管理框架567</p><p>19.1 管理各种网络设备——Netd守护进程567</p><p>19.1.1 Netd的架构567</p><p>19.1.2 处理net类型的uevent569</p><p>19.1.3 处理NMS的命令570</p><p>19.1.4 DNS服务代理571</p><p>19.1.5 MDnsSdListener的作用——与守护进程进行交互572</p><p>19.2 网络管理的中心——ConnectivityService服务573</p><p>19.2.1 初始化过程573</p><p>19.2.2 网络连接类型574</p><p>19.2.3 NetworkStateTracker对象的作用——获得网络连接信息576</p><p>19.3 完成对网络物理接口操作——NetworkManagementService服务578</p><p>19.4 总结581</p><p>第20章 Android的音频系统582</p><p>20.1 音频系统简介582</p><p>20.1.1 Linux的音频架构582</p><p>20.1.2 手机中的音频设备582</p><p>20.1.3 Audio系统的架构583</p><p>20.2 AudioPolicyService服务——输入输出设备的状态584</p><p>20.2.1 服务的创建过程584</p><p>20.2.2 管理音频路由策略587</p><p>20.2.3 管理输入输出设备591</p><p>20.3 音频的核心——AudioFlinger服务594</p><p>20.3.1 AudioFlinger的创建过程594</p><p>20.3.2 AudioFlinger中的线程595</p><p>20.3.3 MixerThread线程597</p><p>20.3.4 打开物理设备——OpenOutput函数599</p><p>20.4 一次完整的播放过程601</p><p>20.4.1 创建AudioTrack对象601</p><p>20.4.2 在native层的AudioTrack604</p><p>20.4.3 开始播放609</p><p>20.4.4 传递音频数据612</p><p>20.4.5 AudioFlinger的播放线程616</p><p>第21章 让应用更安全——Android的SELinux模块619</p><p>21.1 安全系统——SELinux简介619</p><p>21.1.1 安全机制——DAC和MAC619</p><p>21.1.2 安全模块SELinux的架构620</p><p>21.1.3 安全上下文621</p><p>21.1.4 域的转移623</p><p>21.1.5 常用命令624</p><p>21.2 安全增强型——SEAndroid简介625</p><p>21.2.1 SEAndroid的组成625</p><p>21.2.2 理解各种策略文件626</p><p>21.3 Android如何使用SELinux629</p><p>21.3.1 Init进程设置SELinux的Policy629</p><p>21.3.2 Init进程初始化安全上下文632</p><p>21.3.3 设置守护进程的安全上下文635</p><p>21.3.4 设置应用进程的安全上下文636</p><p>21.4 总结640</p><p>第22章 Dalvik和ART虚拟机641</p><p>22.1 Dalvik虚拟机简介641</p><p>22.1.1 Dalvik虚拟机的特点641</p><p>22.1.2 即时编译JIT642</p><p>22.2 Dalvik的启动和初始化643</p><p>22.2.1 启动的流程分析643</p><p>22.2.2 重要的全局变量——初始化 gDvm643</p><p>22.3 Dalvik字节码的执行过程646</p><p>22.3.1 执行流程646</p><p>22.3.2 代码分析647</p><p>22.4 Dalvik的内存管理机制649</p><p>22.4.1 堆的初始化过程649</p><p>22.4.2 Dalvik内存分配机制656</p><p>22.4.3 软引用、弱引用和虚引用658</p><p>22.4.4 Dalvik的内存回收机制659</p><p>22.5 ART模式简介667</p><p>22.5.1 两种模式的区别668</p><p>22.5.2 ART的初始化669</p><p>22.5.3 ART开始运行672</p><p>第23章 系统升级模块——Android的Recovery模块674</p><p>23.1 Recovery模块的执行675</p><p>23.1.1 Recovery模块的启动675</p><p>23.1.2 如何传递启动参数677</p><p>23.1.3 执行菜单命令679</p><p>23.2 Recovery的升级过程681</p><p>23.2.1 sideload方式安装681</p><p>23.2.2 升级的入口函数682</p><p>23.3 update-binary模块685</p><p>23.3.1 update-binary的执行流程685</p><p>23.3.2 update-script的语法规则687</p><p>第24章 Android的调试方法689</p><p>24.1 获取和分析系统Log689</p><p>24.1.1 Logcat使用说明689</p><p>24.1.2 如何分析Android Log690</p><p>24.1.3 如何分析ANR694</p><p>24.2 内存泄露的分析方法696</p><p>24.2.1 分析内存使用情况——DDMS的Allocation Tracker696</p><p>24.2.2 DDMS的DumpHeap工具697</p><p>24.2.3 使用MAT分析内存泄露698</p><p>24.2.4 使用Valgrind分析内存泄露699</p><p>24.3 Android的自动化测试700</p><p>24.3.1 Monkey701</p><p>24.3.2 让用户开发控制程序——Monkeyrunner702</p><p>24.3.3 UI测试工具——uiAutomator工具705</p><p>参考文献709</p><p></p></div></div><div class="d-rt"><h3>热门推荐</h3><ul><li><a href="/book/3130722.html">3130722.html</a></li><li><a href="/book/2981365.html">2981365.html</a></li><li><a href="/book/119651.html">119651.html</a></li><li><a href="/book/1007860.html">1007860.html</a></li><li><a href="/book/386190.html">386190.html</a></li><li><a href="/book/1983969.html">1983969.html</a></li><li><a href="/book/3712201.html">3712201.html</a></li><li><a href="/book/548335.html">548335.html</a></li><li><a href="/book/1863063.html">1863063.html</a></li><li><a href="/book/937946.html">937946.html</a></li></ul></div></div><div id="footer"><p>Copyright&nbsp;&copy;&nbsp;2025&nbsp;&nbsp;<a href="/list/">最新更新</a></p><p>请使用FDM BitComet qBittorrent uTorrent等BT下载工具，下载本站电子书资源！首推Free Download Manager下载软件。文件页数>标注页数[分册图书除外]</p></div></body></html>