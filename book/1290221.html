<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><script type="text/javascript" src="https://file.bkxsj.com/skin/book/js/sk.js"></script><meta name="robots" content="index,follow"><title>GNU/Linux编程指南[PDF|Epub|txt|kindle电子书版本网盘下载]-灵感之桥</title><meta name="Keywords" content="GNU/Linux编程指南"/><meta name="description" content="GNU/Linux编程指南pdf下载文件大小为35MB,PDF页数为592页"/><meta http-equiv="X-UA-Compatible" content="IE=9; IE=8; IE=7; IE=EDGE;chrome=1"><link type="image/x-icon" rel="shortcut icon" href="https://www.shukui.net/skin/book/images/favicon.ico"><link type="text/css" rel="stylesheet" href="https://www.shukui.net/skin/book/css/style.css"><style>#main .d-main {margin-left: 0;width: 620px;}.down-btn {animation: myShake 2.5s linear .15s infinite}@keyframes myShake {0%, 66% {transform: translateZ(0)}67%, 73.6%, 83.6%, 93.6%, to {animation-timing-function: cubic-bezier(.215, .61, .355, 1);transform: translateZ(0)}80.3%, 81.4% {animation-timing-function: cubic-bezier(.755, .05, .855, .06);transform: translate3d(0, -4px, 0)}90.3% {animation-timing-function: cubic-bezier(.755, .05, .855, .06);transform: translate3d(0, -2px, 0)}97% {transform: translate3d(0, -.5px, 0)}}.copylink-btn {margin-right: 20px;}.copymd5-btn {margin-bottom: 25px;margin-left: 10px;}</style></head><body><div id="header"><div class="inner"><div class="logo"><a href="/"><img width="103" height="25" alt="灵感之桥"src="https://www.shukui.net/skin/book/images/logo.png"></a></div><div class="search"><form action="/so/search.php" target="_blank"><input type="text" autocomplete="off" id="bdcsMain" name="q" placeholder="书名 / 作者 / 出版社 / ISBN"class="inp-txt"><select class="inp-select" id="datasource" onchange="selectDatasource(this)"><option value="so">主库</option><option value="s">从库</option></select><input type="submit" value="搜索" class="inp-btn"></form></div></div></div><div id="main"><div class="d-main"><div class="tit"><h3>图书介绍</h3></div><h1 class="book-name">GNU/Linux编程指南PDF|Epub|txt|kindle电子书版本网盘下载</h1><div class="d-info"><div class="b-thumb"><img src="https://www.shukui.net/cover/19/31435217.jpg" alt="GNU/Linux编程指南"></div><div class="b-info"><ul><li>（美）（K.沃尔）K.Wall等著；王勇等译 著</li><li>出版社： 北京：清华大学出版社</li><li>ISBN：7302039135</li><li>出版时间：2000</li><li>标注页数：568页</li><li>文件大小：35MB</li><li>文件页数：592页</li><li>主题词：UNIX操作系统-程序设计 程序设计-UNIX操作系统</li></ul></div></div><div class="tit"><h3>PDF下载</h3></div><div></br><a style="color:red;" rel="external nofollow" href="https://www.kjlm.net/ebook/1290223.html"target="_blank"><b>点此进入-本书在线PDF格式电子书下载【推荐-云解压-方便快捷】直接下载PDF格式图书。移动端-PC端通用</a></b></br><a class="down-btn" rel="external nofollow" href="https://down.trackerbk.com/bt/04/31435217.torrent"target="_blank">种子下载</a>[BT下载速度快]温馨提示：（请使用BT下载软件FDM进行下载）<a rel="nofollow" href="https://www.freedownloadmanager.org/zh/" target="_blank">软件下载地址页</a><a class="down-btn" rel="external nofollow" href="https://down.p2spdb.com/04/31435217.rar" target="_blank">直链下载</a>[便捷但速度慢]&nbsp;&nbsp;<a style="color:red;" rel="external nofollow" href="https://pdfyl.ertongbook.com/29/31435217.pdf" target="_blank"><b>[在线试读本书]</b></a>&nbsp;&nbsp;<b> <a style="color:red;" rel="external nofollow" href="https://web.jyjl.org/index/recovery.html" target="_blank">[在线获取解压码]</a></b><div class="copymd5-btn"><a href="javascript:copyToClip('bd87bd0d19d75fc18251c635624a2041')">点击复制MD5值：bd87bd0d19d75fc18251c635624a2041</a></div></div><div class="tit"><h3>下载说明</h3></div><div style="margin:20px 10px"><h2>GNU/Linux编程指南PDF格式电子书版下载</h2>下载的文件为RAR压缩包。需要使用解压软件进行解压得到PDF格式图书。<br><br><div class="copymd5-btn"><a href="javascript:copyToClip('magnet:?xt=urn:btih:RX6G6JQ2LJW7PBBEDNUSCQM7ICDMHIWK')">点击复制85GB完整离线版磁力链接到迅雷FDM等BT下载工具进行下载</a>&nbsp;&nbsp;<a rel="nofollow" target="_blank">详情点击-查看共享计划</a></div>建议使用BT下载工具Free Download Manager进行下载,简称FDM(免费,没有广告,支持多平台）。本站资源全部打包为BT种子。所以需要使用专业的BT下载软件进行下载。如BitComet qBittorrent uTorrent等BT下载工具。迅雷目前由于本站不是热门资源。不推荐使用！后期资源热门了。安装了迅雷也可以迅雷进行下载！<br><br><b>（文件页数 要大于 标注页数，上中下等多册电子书除外）</b><br><br><p style="color:red;"> <b>注意：本站所有压缩包均有解压码：</b> <a rel="nofollow" target="_blank"><b>点击下载压缩包解压工具</b></a></p></div><div class="tit"><h3>图书目录</h3></div><div id="book-contents"><p>第1章 概貌1</p><p>1.1 Linux既往成就1</p><p>1.2 Linux预期成就1</p><p>第1部分 Linux编程工具包1</p><p>1.3 Linux简史2</p><p>1.4 Linux与UNIX2</p><p>1.5 Linux编程2</p><p>1.6 为何选择Linux编程3</p><p>1.7 小结3</p><p>第2章 设置开发系统4</p><p>2.1 硬件选择4</p><p>2.1.1 硬件选择上的考虑4</p><p>2.2 处理器/主板5</p><p>2.2.1 板上I/O6</p><p>2.2.2 处理器6</p><p>2.2.4 内存7</p><p>2.2.5 机箱和电源7</p><p>2.2.3 BIOS7</p><p>2.3 用户交互硬件：视频、声音、键盘及鼠标8</p><p>2.3.1 显卡8</p><p>2.3.2 显示器9</p><p>2.3.3 声卡10</p><p>2.4 键盘与鼠标10</p><p>2.5 通信设备、端口及总线11</p><p>2.5.1 调制解调器11</p><p>2.5.2 网络接口卡12</p><p>2.5.5 串行卡(包括多端口)13</p><p>2.5.3 SCSI13</p><p>2.5.4 USB与火线(IEEE 1394)13</p><p>2.5.6 IRDA14</p><p>2.5.7 PCMCIA卡14</p><p>2.5.8 ISA即插即用设备14</p><p>2.6 存储设备14</p><p>2.6.1 硬盘14</p><p>2.6.2 可移动磁盘设备14</p><p>2.7.1 打印机15</p><p>2.7 外围设备15</p><p>2.6.3 CD-ROM/DVD15</p><p>2.6.4 磁带备份设备15</p><p>2.7.2 扫描仪16</p><p>2.7.3 数字相机17</p><p>2.7.4 家居自动控制设备17</p><p>2.8 完备型系统17</p><p>2.9 便携系统18</p><p>2.10 安装18</p><p>2.11 小结21</p><p>3.2 使用简介22</p><p>第3章 使用GNU cc22</p><p>3.1 GNU cc特性22</p><p>3.3 常用命令行选项24</p><p>3.3.1 函数库和包含文件25</p><p>3.3.2 出错检查及警告26</p><p>3.4 优化选项27</p><p>3.5 调试选项28</p><p>3.6 GNU C扩展29</p><p>3.7 小结30</p><p>4.2 缩写makefile31</p><p>第4章 使用GNU make管理项目31</p><p>4.1 为何使用make31</p><p>4.3 有关makefile编写的详细规则33</p><p>4.3.1 伪目标33</p><p>4.3.2 变量33</p><p>4.3.3 环境变量、自动变量及预定义变量35</p><p>4.3.4 隐式规则36</p><p>4.3.5 模式规则36</p><p>4.5 调试make37</p><p>4.4 额外的make命令行选项37</p><p>4.3.6 注释37</p><p>4.6 常见的make出错消息38</p><p>4.7 有用的makefile目标38</p><p>4.8 小结38</p><p>第5章 使用autoconf创建自配置软件39</p><p>5.1 理解autoconf39</p><p>5.1.1 创建configure. in文件40</p><p>5.1.2 构造文件40</p><p>5.2.1 候选程序测试41</p><p>32.1 Java简介41</p><p>5.2 内置宏41</p><p>5.1.3 有用的autoconf实用工具41</p><p>5.2.2 库函数测试42</p><p>5.2.3 头文件测试43</p><p>5.2.4 结构测试44</p><p>5.2.5 类型定义测试44</p><p>5.2.6 编译器行为测试44</p><p>5.2.7 系统服务测试45</p><p>5.2.8 UNIX变种测试45</p><p>5.3 普通宏46</p><p>5.4 一个带注解的autoconf脚本47</p><p>5.5 小结52</p><p>第6章 比较和归并源文件53</p><p>6.1.1 理解cmp命令53</p><p>6.1 比较文件53</p><p>6.1.2 理解diff命令55</p><p>6.1.3 理解diff3命令60</p><p>6.1.4 理解sdiff命令63</p><p>6.2 准备源代码补丁63</p><p>6.2.1 patch命令行选项64</p><p>6.2.2 创建补丁64</p><p>6.3 小结65</p><p>6.2.3 使用补丁65</p><p>第7章 使用RCS控制版本66</p><p>7.1 术语66</p><p>7.2.1 ci和co67</p><p>7.2 RCS基本用法67</p><p>7.2.2 RCS关键字69</p><p>7.2.3 ident命令70</p><p>7.3 rcsdiff71</p><p>7.4 其他RCS命令73</p><p>7.4.4 rcsmerge74</p><p>7.4.2 rlog74</p><p>7.4.3 rcs74</p><p>7.4.1 rcsclean74</p><p>7.5 小结75</p><p>第8章 在Emacs中创建程序76</p><p>8.1 Emacs简介76</p><p>8.1.1 启动与停止Emacs76</p><p>8.1.2 移动78</p><p>8.1.3 插入文本79</p><p>8.1.4 删除文本79</p><p>8.1.5 查找和替换80</p><p>8.1.6 保存和打开文件81</p><p>8.1.7 多窗口82</p><p>8.2.1 缩进约定83</p><p>8.2 支持编程的特性83</p><p>8.2.2 语法高亮度显示84</p><p>8.2.3 使用注释84</p><p>8.2.4 使用Emacs进行编译85</p><p>8.2.5 定制简介87</p><p>8.3 使用Emacs Lisp自动完成Emacs操作89</p><p>8.4 小结91</p><p>9.2 使用文件描述符的系统调用92</p><p>9.1 文件描述符92</p><p>第9章 I/O例程92</p><p>第2部分 系统编程92</p><p>9.2.1 open()调用93</p><p>9.2.2 close()调用94</p><p>9.2.3 read()调用94</p><p>9.2.4 write()调用94</p><p>9.2.5 ioctl()调用94</p><p>9.2.6 fcntl()调用95</p><p>9.2.7 fsync()调用95</p><p>9.2.8 ftruncate()调用96</p><p>9.2.9 lseek()调用96</p><p>9.2.10 dup()t duo2()调用96</p><p>9.2.11 select()调用97</p><p>9.2.12 fstat()调用101</p><p>9.2.13 fchown()调用102</p><p>9.2.14 fchmod()调用102</p><p>9.2.15 fchdir()调用103</p><p>9.2.16 flock()调用103</p><p>9.2.17 pipe()调用103</p><p>9.3 文件类型104</p><p>9.3.1 普通文件104</p><p>9.3.2 磁带I/O106</p><p>9.3.3 串口I/O109</p><p>9.3.4 打印机接口109</p><p>9.3.5 声卡109</p><p>9.4 小结109</p><p>第10章 文件操作110</p><p>10.1 文件操作函数110</p><p>10.1.1 打开/关闭文件110</p><p>10.1.2 基本的读和写111</p><p>10.1.3 状态函数111</p><p>10.2 格式化输出112</p><p>10.2.1 格式化输入114</p><p>10.2.2 基于字符和行的输入输出115</p><p>10.2.4 缓冲区控制116</p><p>10.2.3 文件定位116</p><p>10.2.5 删除和改名117</p><p>10.2.6 临时文件117</p><p>10.3 小结118</p><p>第11章 进程控制119</p><p>11.1 进程的属性119</p><p>11.2.1 fork()系统调用120</p><p>11.2.2 exec()函数族120</p><p>11.2 系统调用及库函数120</p><p>11.2.3 system()和popen()函数121</p><p>11.2.4 clone()函数调用121</p><p>11.2.5 wait()、waitpid()、wait3()以及wait4()系统调用122</p><p>11.2.6 select()系统调用122</p><p>11.2.7 信号122</p><p>11.2.8 程序的中止124</p><p>11.2.9 闹钟和计时器125</p><p>11.3 调度参数126</p><p>11.4 线程127</p><p>11.4.1 pthread-create()函数128</p><p>11.4.2 pthread-exit()函数128</p><p>11.4.3 pthread-join()函数128</p><p>11.4.4 属性的控制129</p><p>11.4.5 pthread-atfork()函数130</p><p>11.4.6 取消线程130</p><p>11.4.8 pthread-cond-init()函数131</p><p>11.4.7 pthread-cleanup-push()宏131</p><p>11.4.9 pthread-equal()函数132</p><p>11.4.10 互斥132</p><p>11.5 编程示例132</p><p>11.5.1 子库133</p><p>11.5.2 例子child-demol.c程序143</p><p>11.5.3 例子程序child-demo2.c145</p><p>11.5.4 例子程序child-demo3.c150</p><p>11.6 小结151</p><p>12.1 进程的信息152</p><p>第12章 访问系统信息152</p><p>12.1.1 cmdline文件153</p><p>12.1.2 environ文件153</p><p>12.1.3 fd目录153</p><p>12.1.4 mem文件153</p><p>12.1.5 stat文件153</p><p>12.1.11 statm文件155</p><p>12.2.2 /proc/cpuinfo文件155</p><p>12.2.1 /proc/cmd/line文件155</p><p>12.2 普通的系统信息155</p><p>12.1.8 exe符号链接155</p><p>12.1.10 root符号链接155</p><p>12.1.9 maps文件155</p><p>12.1.7 cwd符号链接155</p><p>12.1.6 status文件155</p><p>12.2.10 /proc/ksyms文件156</p><p>12.2.9 /proc/kmsg文件156</p><p>12.2.7 /proc/ioports文件156</p><p>12.2.8 /proc/kcore文件156</p><p>12.2.5 /proc/filesystems文件156</p><p>12.2.4 /proc/dma文件156</p><p>12.2.3 /proc/devices文件156</p><p>12.2.6 /proc/interrupts文件156</p><p>12.2.15 /proc/misc文件157</p><p>12.2.17 /proc/mounts文件157</p><p>12.2.16 /proc/modules文件157</p><p>12.2.18 /proc/pci文件157</p><p>12.2.14 /proc/meminfo文件157</p><p>12.2.13 /proc/mdstat文件157</p><p>12.2.12 /proc/locks文件157</p><p>12.2.11 /proc/loadavg文件157</p><p>12.2.19 /proc/rtc文件158</p><p>12.2.20 /proc/stat文件158</p><p>12.2.21 /proc/uptime文件158</p><p>12.2.22 /proc/version文件158</p><p>12.2.23 /proc/net子目录158</p><p>12.2.24 /proc/scsi子目录159</p><p>12.2.25 /proc/sys目录159</p><p>12.3 函数库和实用工具160</p><p>12.4 小结160</p><p>13.2.1 assert()宏161</p><p>第13章 出错处理161</p><p>13.2 C语言机制161</p><p>13.1 出错处理简述161</p><p>13.2.2 使用预编译163</p><p>13.2.3 标准库工具165</p><p>13.2.4 对错误代码errno的理解165</p><p>13.2.5 使用函数abort()166</p><p>13.2.6 使用函数exit()166</p><p>13.2.7 使用函数atexit()167</p><p>13.2.9 使用函数perror()168</p><p>13.2.8 使用函数strerror()168</p><p>13.3 系统日志工具169</p><p>13.3.1 用户程序173</p><p>13.4 小结173</p><p>第14章 内存管理174</p><p>14.1 C内存管理的回顾174</p><p>14.1.1 malloc()函数的使用174</p><p>14.1.2 calloc()函数的使用174</p><p>14.1.5 alloca()函数的使用175</p><p>14.1.3 realloc()函数的使用175</p><p>14.1.4 free()函数的使用175</p><p>14.2 内存映像文件177</p><p>14.2.1 mmap()函数的使用177</p><p>14.2.2 munmap()函数的使用178</p><p>14.2.3 msync()函数的使用178</p><p>14.2.4 mprotect()函数的使用179</p><p>14.2.5 锁住内存179</p><p>14.2.6 mremap()函数的使用179</p><p>14.2.7 用内存映像实现cat(1)180</p><p>14.3 发现并修改内存管理错误181</p><p>14.3.1 一个有问题的程序182</p><p>14.3.2 用mpr和check定位内存错误183</p><p>14.3.3 Electric Fence185</p><p>14.3.4 使用Lint Brush187</p><p>14.4 小结188</p><p>第3部分 进程间通信和网络编程189</p><p>第15章 IPC入门：使用管道189</p><p>15.1 管道使用简介190</p><p>15.1.1 无名管道190</p><p>15.1.2 有名管道191</p><p>15.2 小结193</p><p>16.1 创建一个使用消息队列示例程序194</p><p>第16章 消息队列194</p><p>16.2 运行这个消息队列示例程序196</p><p>16.3 小结196</p><p>第17章 共享内存197</p><p>17.1 把Linux配置成使用共享内存197</p><p>17.2 创建一个使用共享内存的例子程序197</p><p>17.3 运行共享内存示例程序199</p><p>17.4 小结200</p><p>18.1 使用信号灯的示例程序201</p><p>第18章 信号灯201</p><p>18.2 运行信号灯示例程序205</p><p>18.3 小结206</p><p>第19章 TCP/IP和套接口编程207</p><p>19.1 支持套接口编程的系统调用207</p><p>19.1.1 socket207</p><p>19.1.2 bind208</p><p>19.1.3 listen209</p><p>19.1.4 connect209</p><p>19.1.5 recv210</p><p>19.1.6 send210</p><p>19.2 使用套接口的客户/服务器例子程序211</p><p>19.2.1 服务器例子程序211</p><p>19.2.2 客户例子程序212</p><p>19.2.4 使用Web浏览器作为客户运行服务器例子程序213</p><p>19.2.3 运行客户和服务器例子程序213</p><p>19.3 一个简单的Web服务器程序和Web客户程序214</p><p>19.3.1 实现一个简单的Web服务器程序214</p><p>19.3.2 实现一个简单的Web客户程序216</p><p>19.3.3 测试这个Web服务器程序和Web客户程序216</p><p>19.3.4 使用Netscape Navigator作为客户运行这个简单Web服务器程序217</p><p>19.4 小结218</p><p>第20章 UDP：用户数据协议219</p><p>20.1 一个发送UDP数据的例子程序219</p><p>20.2 一个接收UDP数据的例子程序220</p><p>20.3 运行这两个UDP例子程序221</p><p>20.4 小结222</p><p>第21章 使用多播套接口223</p><p>21.1 把Linux配置成支持多播IP223</p><p>21.2 几个使用多播IP的例子程序224</p><p>21.2.1 使用多播IP广播数据的例子程序225</p><p>21.2.2 监听多播IP广播的例子程序226</p><p>21.2.3 运行这两个多播IP例子程序227</p><p>21.3 小结228</p><p>第22章 非阻塞套接口I/O229</p><p>22.1 使用非阻塞套接口I/O的例子程序229</p><p>22.2 运行这个非阻塞套接口I/O的例子程序232</p><p>22.3 小结232</p><p>23.1.1 理解客户程序的设计233</p><p>23.1 C++客户/服务器类的设计233</p><p>第23章 用于TCP套接口的一个C++类库233</p><p>23.1.2 理解服务器设计235</p><p>23.2 C++客户/服务器类的实现236</p><p>23.2.1 实现客户程序236</p><p>23.2.2 实现服务器237</p><p>23.3 测试这个客户/服务器类238</p><p>23.4 小结240</p><p>第24章 使用库241</p><p>24.1 比较libc5和libc6241</p><p>24.2.2 理解ar命令242</p><p>24.2.1 理解nm命令242</p><p>24.2 库操作工具242</p><p>24.2.4 理解ldconfig243</p><p>24.2.3 理解ldd命令243</p><p>24.2.5 环境变量和配置文件244</p><p>24.3 编写并使用静态库244</p><p>24.4 编写并使用享库249</p><p>24.5 使用动态加载的共享对象251</p><p>24.5.1 理解dl接口251</p><p>24.5.2 加载共享对象251</p><p>24.5.6 使用dl接口252</p><p>24.5.4 检查错误252</p><p>24.5.5 卸载共享对象252</p><p>24.5.3 使用共享对象252</p><p>24.6 小结254</p><p>第25章 设备驱动程序255</p><p>25.1 驱动程序类型255</p><p>25.1.1 静态链接的内核设备驱动程序255</p><p>25.1.2 可加载的内核模块255</p><p>25.1.5 特权用户模式程序256</p><p>25.1.4 无特权用户模式程序256</p><p>25.1.3 共享库256</p><p>25.2 演示用的硬件257</p><p>25.1.6 守护进程257</p><p>25.1.7 字符设备与块设备257</p><p>25.2.1 步进电机工作原理258</p><p>25.2.2 标准或双向并口260</p><p>25.3 开发配置262</p><p>25.4 低层端口I/O262</p><p>25.5 引发使用设备驱动程序的中断264</p><p>25.7 一个简单的用户模式测试驱动程序265</p><p>25.6 使用DMA访问内存265</p><p>25.8 调试内核级驱动程序266</p><p>25.9 下半部与上半部267</p><p>25.10 创建一个内核驱动程序267</p><p>25.10.1 查看源代码267</p><p>25.10.2 编译驱动程序291</p><p>25.10.3 使用内核驱动程序291</p><p>25.10.4 未来发展方向292</p><p>25.12 小结293</p><p>25.11 其他信息来源293</p><p>第26章 底层终端控制294</p><p>26.1 终端接口294</p><p>第4部分 用户界面编程294</p><p>26.2 控制终端295</p><p>26.2.1 属性控制函数296</p><p>26.2.2 速度控制函数297</p><p>26.2.3 行控制函数297</p><p>26.2.4 进程控制函数298</p><p>26.3 使用终端接口299</p><p>26.4 改变终端模式301</p><p>26.5.1 terminfo能力303</p><p>26.5 使用terminfo303</p><p>26.5.2 使用terminfo304</p><p>26.5.3 发挥terminfo能力307</p><p>26.6 小结310</p><p>第27章 使用ncurses操纵屏幕311</p><p>27.1 ncurses简史311</p><p>27.2 使用ncurses编译程序312</p><p>27.3 调试ncurses程序312</p><p>27.4 关于窗口312</p><p>27.4.1 ncurses的窗口设计313</p><p>27.4.2 ncurses的函数命名约定314</p><p>27.5.2 ncurses终止315</p><p>27.5 初始化与终止315</p><p>27.5.1 ncurses初始化结构315</p><p>27.5.3 说明ncurses的初始化与终止316</p><p>27.6 输入与输出318</p><p>27.6.1 输出例程318</p><p>27.6.2 输入例程326</p><p>27.7 颜色例程329</p><p>27.8 窗口管理331</p><p>27.9 其他实用函数331</p><p>27.10 小结334</p><p>第28章 X Window编程335</p><p>28.1 X的概念335</p><p>28.2 Xlib API336</p><p>28.2.1 XopenDisplay337</p><p>28.2.2 XcreateSimpleWindow和XcreateWindow337</p><p>28.2.5 事件处理338</p><p>28.2.4 撤消窗口338</p><p>28.2.3 映射窗口和撤消映射窗口338</p><p>28.2.6 初始化图形设备上下文和字体340</p><p>28.2.7 在X窗口中绘图340</p><p>28.2.8 一个Xlib的示例程序341</p><p>28.3 X工具包API344</p><p>28.3.1 准备使用X工具包344</p><p>28.3.2 使用X工具包设置窗口部件参数345</p><p>28.4 小结346</p><p>第29章 使用Athena和Motif的窗口部件347</p><p>29.1.1 Athena的标签窗口部件347</p><p>29.1 使用Athena的窗口部件347</p><p>29.1.2 Athena的命令按钮窗口部件348</p><p>29.1.3 Athena的列表窗口部件351</p><p>29.1.4 Athena的文本窗口部件352</p><p>29.1.5 Athena的简单菜单窗口部件355</p><p>29.2 使用Motif的窗口部件357</p><p>29.2.1 Motif的标签窗口部件358</p><p>29.2.2 Motif的列表窗口部件359</p><p>29.2.3 Motif的文本窗口部件360</p><p>29.3.1 使用fetch-url.c文件363</p><p>29.3 编写一个定制的Athena窗口部件363</p><p>29.3.2 使用URL.h文件365</p><p>29.3.3 使用URLP.h文件366</p><p>29.3.4 使用URL.c文件367</p><p>29.3.5 测试URL窗口部件369</p><p>29.4 在C++程序中同时使用Athena和Motif370</p><p>29.5 使用封装Athena窗口部件的一个C++类库371</p><p>29.5.1 Conmponent类372</p><p>29.5.2 PanedWindow类373</p><p>29.5.3 Label类375</p><p>29.5.4 Button类376</p><p>29.5.5 Text类377</p><p>29.6 小结379</p><p>第30章 使用GTK进行GUI编程380</p><p>30.1 GTK简介381</p><p>30.1.1 处理GTK中的事件382</p><p>30.1.2 使用GTK的示例程序383</p><p>30.1.4 GTK容器窗口部件385</p><p>30.1.3 其他GTK窗口部件385</p><p>30.2 用于显示XML文件的GTK程序386</p><p>30.2.1 XML简介387</p><p>30.2.2 James Clark的XML分析器Expat388</p><p>30.2.3 GTK的XML显示程序实现389</p><p>30.2.4 运行GTK的XML显示程序394</p><p>30.3 使用Notebook窗口部件的GUI程序394</p><p>30.3.1 Notebook窗口部件示例程序的实现394</p><p>30.3.2 实现绘图窗口部件396</p><p>30.3.3 运行GTK Notebook窗口部件示例程序398</p><p>第31章 使用Qt进行GUI编程400</p><p>31.1 通过重载QWidget类方法处理事件401</p><p>31.1.1 QWindget类概述401</p><p>31.1.2 实现DrawWidget类403</p><p>31.1.3 测试DrawWidget405</p><p>31.2 使用Qt槽和信号处理事件405</p><p>31.2.1 派生StateLCDWidget类406</p><p>31.2.2 使用信号和槽408</p><p>31.3 小结410</p><p>31.2.3 运行信号/槽示例程序410</p><p>第32章 使用Java进行GUI编程412</p><p>32.1.1 Java是一种面向对象的语言412</p><p>32.1.2 在Java中使用包415</p><p>32.1.3 使用java读写文件416</p><p>32.1.4 在Java中使用多个线程419</p><p>32.1.5 在Java中进行套接口编程420</p><p>32.2 使用Java编写一个聊天引擎424</p><p>32.3 AWT简介428</p><p>32.4 使用AWT编写一个聊天程序430</p><p>32.5 JFC简介434</p><p>32.6 使用JFC编写一个聊天程序437</p><p>32.7 使用本机Java编译器440</p><p>32.8 小结440</p><p>第33章 OpenGL/Mesa图形编程441</p><p>33.1 OpenGL是一个图形硬件的软件接口441</p><p>33.2 Orbits示例程序442</p><p>33.2.1 为OpenGL图形创建窗口以及对OpenGL初始化442</p><p>33.2.2 使用GLUT创建简单的三维物体443</p><p>33.2.4 沿着X-，Y-，Z-中的任何轴或所有轴旋转物体445</p><p>33.2.3 在三维空间中使用X-Y-Z坐标放置物体445</p><p>33.2.5 启用材料属性446</p><p>33.2.6 启用深度值测试447</p><p>33.2.7 处理键盘事件447</p><p>33.2.8 为获得动画效果对OpenGL图形进行更新447</p><p>33.2.9 示例程序清单447</p><p>34.2 bash基础知识451</p><p>34.2.1 通配符451</p><p>第34章 使用GNU bash进行Shell编程451</p><p>34.1 为何使用bash451</p><p>第5部分 特殊编程技术451</p><p>34.2.2 花括弧展开式452</p><p>34.2.3 特殊字符452</p><p>34.3 使用bash变量453</p><p>34.4 使用bash操作符455</p><p>34.4.1 字符串操作符456</p><p>34.4.2 模式匹配操作符457</p><p>34.5.1 条件执行：if458</p><p>34.5 流控制458</p><p>34.5.2 确定性循环：for462</p><p>34.5.3 非确定性循环：while和until462</p><p>34.5.4 选择结构：case和select463</p><p>34.6 shell函数465</p><p>34.7 输入与输出466</p><p>34.7.1 I/O重定向466</p><p>34.7.2 字符串I/O467</p><p>34.8 命令行处理469</p><p>34.9 进程和作业控制471</p><p>34.9.1 shell的信号处理471</p><p>34.9.2 使用trap471</p><p>34.10 小结473</p><p>第35章 有关安全性的编程474</p><p>35.1 应用程序类型474</p><p>35.1.1 setuid程序474</p><p>35.1.2 网络服务器(守护进程)474</p><p>35.1.6 工具程序475</p><p>35.1.5 CGI程序475</p><p>35.1.4 邮件用户代理程序475</p><p>35.1.3 网络客户程序475</p><p>35.1.7 应用程序476</p><p>35.2 特殊的代码问题476</p><p>35.2.1 shell脚本和system()系统调用476</p><p>35.2.2 来自不信任用户的输入477</p><p>35.2.3 缓冲区溢出477</p><p>35.2.4 环境变量480</p><p>35.2.5 gethostbyname()函数482</p><p>35.2.6 信号482</p><p>35.2.7 user ID和group ID483</p><p>35.2.8 函数库的脆弱性485</p><p>35.2.9 执行其他程序485</p><p>35.2.10 /tmp竞争485</p><p>35.2.11 拒绝服务型攻击485</p><p>35.2.12 随机数487</p><p>35.2.13 令牌487</p><p>35.2.14 密码487</p><p>35.2.15 文件名488</p><p>35.2.16 符号链接489</p><p>35.2.17 chroot()环境498</p><p>35.2.19 进程间通信499</p><p>35.2.18 分割程序499</p><p>35.2.20 identd守护进程500</p><p>35.2.21 TCP与UDP500</p><p>35.2.22 动态与静态内存分配501</p><p>35.2.23 安全级别502</p><p>35.2.24 POSIX.le的能力502</p><p>35.3 擦除缓冲区502</p><p>35.4 穿越防火墙提交HTML表单502</p><p>35.7 预先派生子进程的服务器的问题503</p><p>35.6 HTML服务器包含特性503</p><p>35.5 窃呼、盗取及中间人攻击503</p><p>35.8 超时504</p><p>35.9 三因素认证504</p><p>35.10 可插入的认证模块505</p><p>35.11 一般的程序健壮性问题505</p><p>35.12 加密技术505</p><p>35.12.1 加密算法的类型506</p><p>35.12.2 加密系统507</p><p>35.12.3 加密的脆弱性507</p><p>35.13 小结508</p><p>第36章 调试：GNU gdb509</p><p>36.1 为使用gdb进行编译509</p><p>36.2 使用基本的gdb命令509</p><p>36.2.1 启动gdb510</p><p>36.2.2 在调试器中查看代码511</p><p>36.2.3 检查数据512</p><p>36.2.4 设置断点513</p><p>36.2.5 检查并更改运行中的代码515</p><p>36.3.1 变量的作用域和上下文516</p><p>36.3 高级gdb概念和命令516</p><p>36.3.2 遍历函数调用栈517</p><p>36.3.3 操纵源文件518</p><p>36.3.4 与Shell进行通信519</p><p>36.3.5 附加到某个运行中的程序520</p><p>36.4 小结520</p><p>第6部分 补充内容521</p><p>第37章 软件包管理521</p><p>37.1 理解tar文件521</p><p>37.1.1 创建tar文件522</p><p>37.2 理解install命令523</p><p>37.1.3 列出tar文件的内容523</p><p>37.1.2 更新tar文件523</p><p>37.3 理解Red Hat软件包管理器525</p><p>37.3.1 最小要求526</p><p>37.3.2 配置RPM526</p><p>37.3.3 控制构造过程：使用spec文件527</p><p>37.3.4 分析一个spec文件528</p><p>37.3.5 构造软件包530</p><p>37.4 小结531</p><p>38.1.1 手册页面的组成532</p><p>38.1.2 手册页面例子及解释532</p><p>38.1 手册页面532</p><p>第38章 建档532</p><p>38.1.3 使用groff命令534</p><p>38.1.4 Linux约定535</p><p>38.2 使用SGML工具创建SGML文档536</p><p>38.2.1 SGML工具537</p><p>38.2.2 SGML工具的标记540</p><p>38.2.3 格式化SGML文档541</p><p>38.3 小结541</p><p>39.1 MIT/X风格的许可证542</p><p>第39章 许可证的发放542</p><p>39.3 Artistic许可证543</p><p>39.2 BSD风格的许可证543</p><p>39.4 GNU通用公共许可证544</p><p>39.4.1 GNU通用公共许可证(GPL)544</p><p>39.4.2 GNU库通用公共许可证(LGPL)545</p><p>39.5 开放源代码的定义546</p><p>39.6 选择正确的许可证547</p><p>附录A 符号表函数库548</p><p>A.1 可用的文档548</p><p>第7部分 附录548</p><p>A.1.1 示例程序：userchange549</p><p>A.1.2 定义一个符号表来描述一个结构类型549</p><p>A.1.3 定义一个变量的随机集551</p><p>A.1.4 包含另一个符号表553</p><p>A.1.5 出错报告554</p><p>A.1.6 智能指针555</p><p>A.1.7 符号表库函数555</p><p>A.1.8 执行例子560</p><p>附录B GNU通用公共许可证(General Public License)562</p><p></p></div></div><div class="d-rt"><h3>热门推荐</h3><ul><li><a href="/book/294327.html">294327.html</a></li><li><a href="/book/1394074.html">1394074.html</a></li><li><a href="/book/3682404.html">3682404.html</a></li><li><a href="/book/1750064.html">1750064.html</a></li><li><a href="/book/1879255.html">1879255.html</a></li><li><a href="/book/107988.html">107988.html</a></li><li><a href="/book/2602454.html">2602454.html</a></li><li><a href="/book/37402.html">37402.html</a></li><li><a href="/book/2870008.html">2870008.html</a></li><li><a href="/book/2986093.html">2986093.html</a></li></ul></div></div><div id="footer"><p>Copyright&nbsp;&copy;&nbsp;2025&nbsp;&nbsp;<a href="/list/">最新更新</a></p><p>请使用FDM BitComet qBittorrent uTorrent等BT下载工具，下载本站电子书资源！首推Free Download Manager下载软件。文件页数>标注页数[分册图书除外]</p></div></body></html>