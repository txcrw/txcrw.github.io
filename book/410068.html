<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><script type="text/javascript" src="https://file.bkxsj.com/skin/book/js/sk.js"></script><meta name="robots" content="index,follow"><title>Clojure编程乐趣 第2版[PDF|Epub|txt|kindle电子书版本网盘下载]-灵感之桥</title><meta name="Keywords" content="Clojure编程乐趣 第2版"/><meta name="description" content="Clojure编程乐趣 第2版pdf下载文件大小为63MB,PDF页数为473页"/><meta http-equiv="X-UA-Compatible" content="IE=9; IE=8; IE=7; IE=EDGE;chrome=1"><link type="image/x-icon" rel="shortcut icon" href="https://www.shukui.net/skin/book/images/favicon.ico"><link type="text/css" rel="stylesheet" href="https://www.shukui.net/skin/book/css/style.css"><style>#main .d-main {margin-left: 0;width: 620px;}.down-btn {animation: myShake 2.5s linear .15s infinite}@keyframes myShake {0%, 66% {transform: translateZ(0)}67%, 73.6%, 83.6%, 93.6%, to {animation-timing-function: cubic-bezier(.215, .61, .355, 1);transform: translateZ(0)}80.3%, 81.4% {animation-timing-function: cubic-bezier(.755, .05, .855, .06);transform: translate3d(0, -4px, 0)}90.3% {animation-timing-function: cubic-bezier(.755, .05, .855, .06);transform: translate3d(0, -2px, 0)}97% {transform: translate3d(0, -.5px, 0)}}.copylink-btn {margin-right: 20px;}.copymd5-btn {margin-bottom: 25px;margin-left: 10px;}</style></head><body><div id="header"><div class="inner"><div class="logo"><a href="/"><img width="103" height="25" alt="灵感之桥"src="https://www.shukui.net/skin/book/images/logo.png"></a></div><div class="search"><form action="/so/search.php" target="_blank"><input type="text" autocomplete="off" id="bdcsMain" name="q" placeholder="书名 / 作者 / 出版社 / ISBN"class="inp-txt"><select class="inp-select" id="datasource" onchange="selectDatasource(this)"><option value="so">主库</option><option value="s">从库</option></select><input type="submit" value="搜索" class="inp-btn"></form></div></div></div><div id="main"><div class="d-main"><div class="tit"><h3>图书介绍</h3></div><h1 class="book-name">Clojure编程乐趣 第2版PDF|Epub|txt|kindle电子书版本网盘下载</h1><div class="d-info"><div class="b-thumb"><img src="https://www.shukui.net/cover/34/30460451.jpg" alt="Clojure编程乐趣 第2版"></div><div class="b-info"><ul><li>（美）福格斯（Michael Fogus），豪泽（Chris Houser ） 著</li><li>出版社： 北京：人民邮电出版社</li><li>ISBN：9787115443298</li><li>出版时间：2017</li><li>标注页数：442页</li><li>文件大小：63MB</li><li>文件页数：473页</li><li>主题词：JAVA语言－程序设计</li></ul></div></div><div class="tit"><h3>PDF下载</h3></div><div></br><a style="color:red;" rel="external nofollow" href="https://www.kjlm.net/ebook/410070.html"target="_blank"><b>点此进入-本书在线PDF格式电子书下载【推荐-云解压-方便快捷】直接下载PDF格式图书。移动端-PC端通用</a></b></br><a class="down-btn" rel="external nofollow" href="https://down.trackerbk.com/bt/01/30460451.torrent"target="_blank">种子下载</a>[BT下载速度快]温馨提示：（请使用BT下载软件FDM进行下载）<a rel="nofollow" href="https://www.freedownloadmanager.org/zh/" target="_blank">软件下载地址页</a><a class="down-btn" rel="external nofollow" href="https://down.p2spdb.com/01/30460451.rar" target="_blank">直链下载</a>[便捷但速度慢]&nbsp;&nbsp;<a style="color:red;" rel="external nofollow" href="https://pdfyl.ertongbook.com/10/30460451.pdf" target="_blank"><b>[在线试读本书]</b></a>&nbsp;&nbsp;<b> <a style="color:red;" rel="external nofollow" href="https://web.jyjl.org/index/recovery.html" target="_blank">[在线获取解压码]</a></b><div class="copymd5-btn"><a href="javascript:copyToClip('401cdb13921d962e68fd79d5f230d54e')">点击复制MD5值：401cdb13921d962e68fd79d5f230d54e</a></div></div><div class="tit"><h3>下载说明</h3></div><div style="margin:20px 10px"><h2>Clojure编程乐趣 第2版PDF格式电子书版下载</h2>下载的文件为RAR压缩包。需要使用解压软件进行解压得到PDF格式图书。<br><br><div class="copymd5-btn"><a href="javascript:copyToClip('magnet:?xt=urn:btih:RX6G6JQ2LJW7PBBEDNUSCQM7ICDMHIWK')">点击复制85GB完整离线版磁力链接到迅雷FDM等BT下载工具进行下载</a>&nbsp;&nbsp;<a rel="nofollow" target="_blank">详情点击-查看共享计划</a></div>建议使用BT下载工具Free Download Manager进行下载,简称FDM(免费,没有广告,支持多平台）。本站资源全部打包为BT种子。所以需要使用专业的BT下载软件进行下载。如BitComet qBittorrent uTorrent等BT下载工具。迅雷目前由于本站不是热门资源。不推荐使用！后期资源热门了。安装了迅雷也可以迅雷进行下载！<br><br><b>（文件页数 要大于 标注页数，上中下等多册电子书除外）</b><br><br><p style="color:red;"> <b>注意：本站所有压缩包均有解压码：</b> <a rel="nofollow" target="_blank"><b>点击下载压缩包解压工具</b></a></p></div><div class="tit"><h3>图书目录</h3></div><div id="book-contents"><p>第1部分 基础3</p><p>第1章 Clojure哲学3</p><p>1.1 Clojure之道4</p><p>1.1.1 简单4</p><p>1.1.2 专注5</p><p>1.1.3 实用5</p><p>1.1.4 清晰6</p><p>1.1.5 一致7</p><p>1.2 为何（又一种）Lisp8</p><p>1.2.1 优美8</p><p>1.2.2 极度灵活9</p><p>1.3 函数式编程15</p><p>1.3.1 一个可行的函教式编程定义15</p><p>1.3.2 函数式编程的内涵16</p><p>1.4 Clojure为何不是面向对象的16</p><p>1.4.1 定义术语16</p><p>1.4.2 命令式“烘烤”18</p><p>1.4.3 OOP提供的大多数东西，Clojure也有18</p><p>1.5 小结23</p><p>第2章 Clojure疾风式教程24</p><p>2.1 基本数据类型25</p><p>2.1.1 数字25</p><p>2.1.2 整数25</p><p>2.1.3 浮点数26</p><p>2.1.4 有理数26</p><p>2.1.5 符号27</p><p>2.1.6 关键字27</p><p>2.1.7 字符串27</p><p>2.1.8 字符28</p><p>2.2 组合起来：集合28</p><p>2.2.1 list28</p><p>2.2.2 vector29</p><p>2.2.3 map29</p><p>2.2.4 set29</p><p>2.3 付诸实现：函数29</p><p>2.4 var30</p><p>2.5 函数30</p><p>2.5.1 匿名函数31</p><p>2.5.2 使用def和defn定义命名函数31</p><p>2.5.3 不同参数数量的函数32</p><p>2.5.4 以＃（）定义原位（in-place）函数33</p><p>2.6 局部量、循环和block33</p><p>2.6.1 block34</p><p>2.6.2 局部量34</p><p>2.6.3 循环35</p><p>2.7 防止发生：quote37</p><p>2.7.1 求值37</p><p>2.7.2 Quoting38</p><p>2.7.3 反quote40</p><p>2.7.4 反quote拼接41</p><p>2.7.5 auto-gensym41</p><p>2.8 与Java互操作41</p><p>2.8.1 访问静态类成员（仅限于Clojure）41</p><p>2.8.2 创建Java实例42</p><p>2.8.3 用．运算符访问Java实例成员42</p><p>2.8.4 设置Java实例属性43</p><p>2.8.5 ．．宏43</p><p>2.8.6 doto宏44</p><p>2.8.7 定义类44</p><p>2.9 异常环境44</p><p>2.10 命名空间45</p><p>2.10.1 用ns创建命名空间45</p><p>2.10.2 用：require加载其他命名空间46</p><p>2.10.3 用：refer加载和创建映射47</p><p>2.10.4 用：refer创建映射47</p><p>2.10.5 用：import加载Java类48</p><p>2.11 小结48</p><p>第3章 小试牛刀49</p><p>3.1 真值50</p><p>3.1.1 什么是真50</p><p>3.1.2 不要创建布尔对象50</p><p>3.1.3 nil vs.false51</p><p>3.2 小心翼翼nil双关51</p><p>3.3 解构53</p><p>3.3.1 你的任务，你应该选择接受53</p><p>3.3.2 解构vector53</p><p>3.3.3 解构map55</p><p>3.3.4 解构函数参数57</p><p>3.3.5 解构vs．访问器方法57</p><p>3.4 用REPL做试验57</p><p>3.4.1 试验seq57</p><p>3.4.2 试验图形化59</p><p>3.4.3 知识汇总60</p><p>3.4.4 出错之时61</p><p>3.4.5 只为乐趣62</p><p>3.5 小结63</p><p>第2部分 数据类型67</p><p>第4章 标量67</p><p>4.1 理解精度68</p><p>4.1.1 截断（Truncation）68</p><p>4.1.2 提升（Promotion）69</p><p>4.1.3 上溢（Overflow）69</p><p>4.1.4 下溢（Underflow）70</p><p>4.1.5 舍入错误（Rounding errors）70</p><p>4.2 有理数71</p><p>4.2.1 为什么是有理数71</p><p>4.2.2 怎样才是有理数72</p><p>4.2.3 有理数的合理性73</p><p>4.3 使用关键字的时机73</p><p>4.3.1 关键字的应用73</p><p>4.3.2 限定关键字75</p><p>4.4 符号解析76</p><p>4.4.1 元数据77</p><p>4.4.2 符号与命名空间78</p><p>4.4.3 Lisp-178</p><p>4.5 正则表达式——第二个问题79</p><p>4.5.1 语法79</p><p>4.5.2 函数80</p><p>4.5.3 小心可变匹配器（matcher）81</p><p>4.6 小结81</p><p>第5章 组合数据类型82</p><p>5.1 持久化、序列和复杂度83</p><p>5.1.1 “你一直用着这个词。我认为，这并不意味着它就是你以为的含义”83</p><p>5.1.2 序列术语及其含义84</p><p>5.1.3 大O87</p><p>5.2 vector：创建和使用其各种变体89</p><p>5.2.1 构建vector89</p><p>5.2.2 大vector90</p><p>5.2.3 vector当作栈93</p><p>5.2.4 使用vector而非reverse94</p><p>5.2.5 子vector95</p><p>5.2.6 vector当作MapEntry95</p><p>5.2.7 vector不是什么96</p><p>5.3 list：Clojure代码form的数据结构97</p><p>5.3.1 像Lisp那样的list97</p><p>5.3.2 list当作栈98</p><p>5.3.3 list不是什么98</p><p>5.4 如何使用持久化队列99</p><p>5.4.1 什么都没有的队列99</p><p>5.4.2 入队100</p><p>5.4.3 获取101</p><p>5.4.4 出队101</p><p>5.5 持久化set101</p><p>5.5.1 Clojure set的基本属性101</p><p>5.5.2 用sorted-set保持set的顺序103</p><p>5.5.3 contains？103</p><p>5.5.4 clojure.set104</p><p>5.6 思考map106</p><p>5.6.1 hash map106</p><p>5.6.2 以有序map保持键值的顺序107</p><p>5.6.3 用数组map保持插入顺序108</p><p>5.7 知识汇总：在序列里查找某项的位置109</p><p>5.8 小结111</p><p>第3部分 函数式编程115</p><p>第6章 惰性与不变性115</p><p>6.1 关于不变性：按照自己的方式去使用115</p><p>6.1.1 什么是不变性116</p><p>6.1.2 不变性可以做什么116</p><p>6.2 设计一个持久化玩具118</p><p>6.3 惰性121</p><p>6.3.1 以“逻辑与”熟悉惰性122</p><p>6.3.2 理解lazy-seq的秘诀123</p><p>6.3.3 丢掉头126</p><p>6.3.4 采用无限序列126</p><p>6.3.5 delay和force宏128</p><p>6.4 知识汇总：一个惰性的快速排序程序130</p><p>6.5 小结133</p><p>第7章 函数式编程134</p><p>7.1 各种形式的函数134</p><p>7.1.1 一等函数135</p><p>7.1.2 高阶函数138</p><p>7.1.3 纯函数141</p><p>7.1.4 命名实参143</p><p>7.1.5 使用前置条件和后置条件约束函数143</p><p>7.2 闭包145</p><p>7.2.1 函数返回闭包146</p><p>7.2.2 隐藏参数147</p><p>7.2.3 将闭包当作函数传递148</p><p>7.3 递归思考152</p><p>7.3.1 普通递归152</p><p>7.3.2 尾递归和recur155</p><p>7.3.3 勿忘trampoline157</p><p>7.3.4 延续传递风格159</p><p>7.4 知识汇总：A＊寻路161</p><p>7.4.1 世界161</p><p>7.4.2 近邻161</p><p>7.4.3 A＊实现163</p><p>7.4.4 A＊实现的笔记165</p><p>7.5 小结166</p><p>第4部分 大规模设计169</p><p>第8章 宏169</p><p>8.1 数据即代码即数据170</p><p>8.1.1 语法quote、反quote和拼接171</p><p>8.1.2 宏之经验谈173</p><p>8.2 定义控制结构173</p><p>8.2.1 不用语法quote定义控制结构174</p><p>8.2.2 使用语法quote和反quote定义控制结构175</p><p>8.3 组合form的宏176</p><p>8.4 使用宏改变form177</p><p>8.5 使用宏控制符号解析时间181</p><p>8.5.1 回指181</p><p>8.5.2 （可能）有用的选择性名字捕获182</p><p>8.6 使用宏管理资源183</p><p>8.7 知识汇总：返回函数的宏184</p><p>8.8 小结187</p><p>第9章 组合数据与代码188</p><p>9.1 命名空间188</p><p>9.1.1 创建命名空间189</p><p>9.1.2 只暴露所需191</p><p>9.1.3 声明性包含和排除194</p><p>9.2 以通用设计模式探索Clojure多重方法194</p><p>9.2.1 组成部分195</p><p>9.2.2 用法196</p><p>9.2.3 以多重方法拯救197</p><p>9.2.4 处理继承行为的特别继承197</p><p>9.2.5 解析层次中的冲突198</p><p>9.2.6 真正的最大功率任意分发199</p><p>9.3 类型、协议和记录200</p><p>9.3.1 记录200</p><p>9.3.2 协议203</p><p>9.3.3 用deftype从更原始的基础开始构建211</p><p>9.4 知识汇总：国际象棋移动的流畅构建器213</p><p>9.4.1 Java实现213</p><p>9.4.2 Clojure实现215</p><p>9.5 小结217</p><p>第10章 变化和并发218</p><p>10.1 使用Ref的时机219</p><p>10.1.1 利用ref构建可变棋盘221</p><p>10.1.2 事务223</p><p>10.1.3 嵌入式事务225</p><p>10.1.4 STM使其简单的事情225</p><p>10.1.5 潜在缺陷226</p><p>10.1.6 让STM不高兴的事227</p><p>10.2 利用refs重构228</p><p>10.2.1 解决棋盘例子228</p><p>10.2.2 以commute进行可交换的改变230</p><p>10.2.3 以ref-set进行普通改变231</p><p>10.2.4 压力之下的Ref232</p><p>10.3 使用Agent的时机233</p><p>10.3.1 进程内并发模型vs分布式并发模型234</p><p>10.3.2 用Agent控制I/O235</p><p>10.3.3 send和send-off之间的差异237</p><p>10.3.4 错误处理239</p><p>10.3.5 何时不用Agent241</p><p>10.4 使用Atom的时机241</p><p>10.4.1 跨线程共享242</p><p>10.4.2 在事务里使用Atom242</p><p>10.5 使用lock的时机244</p><p>10.5.1 使用锁进行安全变化245</p><p>10.5.2 使用Java的显式锁246</p><p>10.6 var和动态绑定248</p><p>10.6.1 binding宏248</p><p>10.6.2 创建命名var250</p><p>10.6.3 创建匿名var251</p><p>10.6.4 动态作用域251</p><p>10.7 小结253</p><p>第11章 并行254</p><p>11.1 使用future的时机255</p><p>11.2 使用promise的时机259</p><p>11.2.1 以promise进行并行任务260</p><p>11.2.2 回调API到阻塞API261</p><p>11.2.3 确定性死锁262</p><p>11.3 并行263</p><p>11.3.1 pvalues263</p><p>11.3.2 pmap263</p><p>11.3.3 pcalls264</p><p>11.4 reduce/fold264</p><p>11.5 小结265</p><p>第5部分 宿主共生关系269</p><p>第12章 Java.next269</p><p>12.1 使用proxy动态生成对象270</p><p>12.2 Clojure gen-class和GUI程序设计277</p><p>12.2.1 命名空间作为类的规范277</p><p>12.2.2 命名空间编译内幕280</p><p>12.2.3 以Clojure探索用户界面设计与开发281</p><p>12.3 Clojure同Java数组的关系284</p><p>12.3.1 数组的类型：原生与引用284</p><p>12.3.2 数组可变性286</p><p>12.3.3 那个不幸的命名约定286</p><p>12.3.4 多维数组287</p><p>12.3.5 调用可变方法／构造函数288</p><p>12.4 所有Clojure函数都实现……288</p><p>12.4.1 java.util.Comparator288</p><p>12.4.2 java.lang.Runnable289</p><p>12.4.3 java.util.concurrent.Callable290</p><p>12.5 在Java API里使用Clojure数据结构290</p><p>12.5.1 java.util.List291</p><p>12.5.2 java.lang.Comparable291</p><p>12.5.3 java.util.RandomAccess292</p><p>12.5.4 java.util.Collection292</p><p>12.5.5 java.util.Set293</p><p>12.6 definterface293</p><p>12.7 慎用异常295</p><p>12.7.1 一点异常的背景296</p><p>12.7.2 运行时异常vs．编译时异常296</p><p>12.7.3 处理异常298</p><p>12.7.4 定制异常299</p><p>12.8 小结300</p><p>第13章 ClojureScript301</p><p>13.1 实现VS接口302</p><p>13.2 编译器内部：分析和发布305</p><p>13.2.1 编译步骤305</p><p>13.2.2 Web Audio307</p><p>13.2.3 高级编译311</p><p>13.2.4 生成extern.js文件313</p><p>13.3 编译和运行315</p><p>13.4 小结319</p><p>第6部分 杂项考量323</p><p>第14章 面向数据编程323</p><p>14.1 代码是代码，数据是数据323</p><p>14.1.1 严格的分界324</p><p>14.1.2 ORMG325</p><p>14.1.3 从数据中获取信息的一般方式326</p><p>14.1.4 PLOP327</p><p>14.2 数据就是数据327</p><p>14.2.1 值的好处328</p><p>14.2.2 标签符号332</p><p>14.3 数据就是代码335</p><p>14.3.1 数据可编程引擎335</p><p>14.3.2 可编程数据引擎的例子336</p><p>14.3.3 例子：简单的事件来源337</p><p>14.4 代码就是数据，也是代码345</p><p>14.4.1 哈特的发现和同像性346</p><p>14.4.2 Clojure代码就是数据346</p><p>14.4.3 规范括号346</p><p>14.5 小结349</p><p>第15章 性能351</p><p>15.1 类型提示352</p><p>15.1.1 类型修饰的优势352</p><p>15.1.2 类型提示实参和返回值352</p><p>15.1.3 类型提示对象354</p><p>15.2 暂态（transient）354</p><p>15.2.1 短暂的垃圾354</p><p>15.2.2 暂态在效率上与可变集合相比较355</p><p>15.3 分块序列356</p><p>15.4 记忆358</p><p>15.4.1 记忆再研究359</p><p>15.4.2 记忆协议359</p><p>15.4.3 面向抽象编程361</p><p>15.5 理解强制转型（coercion）361</p><p>15.5.1 使用原始类型long362</p><p>15.5.2 使用原生double364</p><p>15.5.3 使用自动提升精度365</p><p>15.6 可缩小的366</p><p>15.6.1 简单的精简集合的例子366</p><p>15.6.2 派生第一个reducse函数变种367</p><p>15.6.3 更多的可还原函数的转换器369</p><p>15.6.4 reducible转换器371</p><p>15.6.5 reducible的性能372</p><p>15.6.6 reducible的缺陷373</p><p>15.6.7 整合reducible到Clojure reduce373</p><p>15.6.8 fold函数：并行的reduce375</p><p>15.7 小结377</p><p>第16章 思考程序378</p><p>16.1 搜索问题378</p><p>16.2 统一思考数据383</p><p>16.2.1 潜在的平等性或满足性384</p><p>16.2.2 替换387</p><p>16.2.3 一致性388</p><p>16.3 关于core.logic390</p><p>16.3.1 都是关于一致性390</p><p>16.3.2 关系型391</p><p>16.3.3 子目标394</p><p>16.4 约束397</p><p>16.4.1 约束编程介绍397</p><p>16.4.2 通过有限域限制绑定399</p><p>16.4.3 利用有限域解决数独问题400</p><p>16.5 小结403</p><p>第17章 Clojure改变我们的思考方式405</p><p>17.1 DSL406</p><p>17.1.1 无所不在的DSL406</p><p>17.1.2 实现类似SQL的DSL用于生成查询408</p><p>17.1.3 Clojure方式DSL的注记413</p><p>17.2 测试413</p><p>17.2.1 一些有用的技术414</p><p>17.2.2 契约式程序设计416</p><p>17.3 缺乏设计模式417</p><p>17.4 错误处理和调试426</p><p>17.4.1 错误处理426</p><p>17.4.2 调试429</p><p>17.5 珍重433</p><p>附录 资源434</p><p>Miscellaneous resources434</p><p>Online resources440</p><p></p></div></div><div class="d-rt"><h3>热门推荐</h3><ul><li><a href="/book/1075565.html">1075565.html</a></li><li><a href="/book/815021.html">815021.html</a></li><li><a href="/book/2946970.html">2946970.html</a></li><li><a href="/book/514384.html">514384.html</a></li><li><a href="/book/1276953.html">1276953.html</a></li><li><a href="/book/3873224.html">3873224.html</a></li><li><a href="/book/3393748.html">3393748.html</a></li><li><a href="/book/2226898.html">2226898.html</a></li><li><a href="/book/1166023.html">1166023.html</a></li><li><a href="/book/3836621.html">3836621.html</a></li></ul></div></div><div id="footer"><p>Copyright&nbsp;&copy;&nbsp;2025&nbsp;&nbsp;<a href="/list/">最新更新</a></p><p>请使用FDM BitComet qBittorrent uTorrent等BT下载工具，下载本站电子书资源！首推Free Download Manager下载软件。文件页数>标注页数[分册图书除外]</p></div></body></html>