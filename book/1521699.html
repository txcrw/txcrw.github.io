<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><script type="text/javascript" src="https://file.bkxsj.com/skin/book/js/sk.js"></script><meta name="robots" content="index,follow"><title>敏捷软件开发 原则、模式与实践 C#版[PDF|Epub|txt|kindle电子书版本网盘下载]-灵感之桥</title><meta name="Keywords" content="敏捷软件开发 原则、模式与实践 C#版"/><meta name="description" content="敏捷软件开发 原则、模式与实践 C#版pdf下载文件大小为66MB,PDF页数为563页"/><meta http-equiv="X-UA-Compatible" content="IE=9; IE=8; IE=7; IE=EDGE;chrome=1"><link type="image/x-icon" rel="shortcut icon" href="https://www.shukui.net/skin/book/images/favicon.ico"><link type="text/css" rel="stylesheet" href="https://www.shukui.net/skin/book/css/style.css"><style>#main .d-main {margin-left: 0;width: 620px;}.down-btn {animation: myShake 2.5s linear .15s infinite}@keyframes myShake {0%, 66% {transform: translateZ(0)}67%, 73.6%, 83.6%, 93.6%, to {animation-timing-function: cubic-bezier(.215, .61, .355, 1);transform: translateZ(0)}80.3%, 81.4% {animation-timing-function: cubic-bezier(.755, .05, .855, .06);transform: translate3d(0, -4px, 0)}90.3% {animation-timing-function: cubic-bezier(.755, .05, .855, .06);transform: translate3d(0, -2px, 0)}97% {transform: translate3d(0, -.5px, 0)}}.copylink-btn {margin-right: 20px;}.copymd5-btn {margin-bottom: 25px;margin-left: 10px;}</style></head><body><div id="header"><div class="inner"><div class="logo"><a href="/"><img width="103" height="25" alt="灵感之桥"src="https://www.shukui.net/skin/book/images/logo.png"></a></div><div class="search"><form action="/so/search.php" target="_blank"><input type="text" autocomplete="off" id="bdcsMain" name="q" placeholder="书名 / 作者 / 出版社 / ISBN"class="inp-txt"><select class="inp-select" id="datasource" onchange="selectDatasource(this)"><option value="so">主库</option><option value="s">从库</option></select><input type="submit" value="搜索" class="inp-btn"></form></div></div></div><div id="main"><div class="d-main"><div class="tit"><h3>图书介绍</h3></div><h1 class="book-name">敏捷软件开发 原则、模式与实践 C#版PDF|Epub|txt|kindle电子书版本网盘下载</h1><div class="d-info"><div class="b-thumb"><img src="https://www.shukui.net/cover/53/31776256.jpg" alt="敏捷软件开发 原则、模式与实践 C#版"></div><div class="b-info"><ul><li>（美）Robert C.Martin，Micah Martin著;邓辉，孙鸣译 著</li><li>出版社： 北京：人民邮电出版社</li><li>ISBN：7115165750</li><li>出版时间：2008</li><li>标注页数：538页</li><li>文件大小：66MB</li><li>文件页数：563页</li><li>主题词：软件开发；C语言－程序设计</li></ul></div></div><div class="tit"><h3>PDF下载</h3></div><div></br><a style="color:red;" rel="external nofollow" href="https://www.kjlm.net/ebook/1521701.html"target="_blank"><b>点此进入-本书在线PDF格式电子书下载【推荐-云解压-方便快捷】直接下载PDF格式图书。移动端-PC端通用</a></b></br><a class="down-btn" rel="external nofollow" href="https://down.trackerbk.com/bt/05/31776256.torrent"target="_blank">种子下载</a>[BT下载速度快]温馨提示：（请使用BT下载软件FDM进行下载）<a rel="nofollow" href="https://www.freedownloadmanager.org/zh/" target="_blank">软件下载地址页</a><a class="down-btn" rel="external nofollow" href="https://down.p2spdb.com/05/31776256.rar" target="_blank">直链下载</a>[便捷但速度慢]&nbsp;&nbsp;<a style="color:red;" rel="external nofollow" href="https://pdfyl.ertongbook.com/35/31776256.pdf" target="_blank"><b>[在线试读本书]</b></a>&nbsp;&nbsp;<b> <a style="color:red;" rel="external nofollow" href="https://web.jyjl.org/index/recovery.html" target="_blank">[在线获取解压码]</a></b><div class="copymd5-btn"><a href="javascript:copyToClip('dd424bb6f000d54b19ed28b13574b2b1')">点击复制MD5值：dd424bb6f000d54b19ed28b13574b2b1</a></div></div><div class="tit"><h3>下载说明</h3></div><div style="margin:20px 10px"><h2>敏捷软件开发 原则、模式与实践 C#版PDF格式电子书版下载</h2>下载的文件为RAR压缩包。需要使用解压软件进行解压得到PDF格式图书。<br><br><div class="copymd5-btn"><a href="javascript:copyToClip('magnet:?xt=urn:btih:RX6G6JQ2LJW7PBBEDNUSCQM7ICDMHIWK')">点击复制85GB完整离线版磁力链接到迅雷FDM等BT下载工具进行下载</a>&nbsp;&nbsp;<a rel="nofollow" target="_blank">详情点击-查看共享计划</a></div>建议使用BT下载工具Free Download Manager进行下载,简称FDM(免费,没有广告,支持多平台）。本站资源全部打包为BT种子。所以需要使用专业的BT下载软件进行下载。如BitComet qBittorrent uTorrent等BT下载工具。迅雷目前由于本站不是热门资源。不推荐使用！后期资源热门了。安装了迅雷也可以迅雷进行下载！<br><br><b>（文件页数 要大于 标注页数，上中下等多册电子书除外）</b><br><br><p style="color:red;"> <b>注意：本站所有压缩包均有解压码：</b> <a rel="nofollow" target="_blank"><b>点击下载压缩包解压工具</b></a></p></div><div class="tit"><h3>图书目录</h3></div><div id="book-contents"><p>第一部分 敏捷开发3</p><p>第1章 敏捷实践3</p><p>1.1 敏捷联盟4</p><p>1.1.1 人和交互重于过程和工具4</p><p>1.1.2 可以工作的软件重于面面俱到的文档5</p><p>1.1.3 客户合作重于合同谈判5</p><p>1.1.4 随时应对变化重于遵循计划6</p><p>1.2 原则6</p><p>1.3 结论8</p><p>1.4 参考文献8</p><p>第2章 极限编程概述9</p><p>2.1 极限编程实践9</p><p>2.1.1 完整团队9</p><p>2.1.2 用户故事10</p><p>2.1.3 短交付周期10</p><p>2.1.4 验收测试10</p><p>2.1.5 结对编程11</p><p>2.1.6 测试驱动开发11</p><p>2.1.7 集体所有权12</p><p>2.1.8 持续集成12</p><p>2.1.9 可持续的开发速度12</p><p>2.1.10 开放的工作空间13</p><p>2.1.11 计划游戏13</p><p>2.1.12 简单设计13</p><p>2.1.13 重构14</p><p>2.1.14 隐喻14</p><p>2.2 结论15</p><p>2.3 参考文献15</p><p>第3章 计划16</p><p>3.1 初始探索17</p><p>3.2 发布计划17</p><p>3.3 迭代计划18</p><p>3.4 定义“完成”18</p><p>3.5 任务计划18</p><p>3.6 迭代19</p><p>3.7 跟踪19</p><p>3.8 结论20</p><p>3.9 参考文献21</p><p>第4章 测试22</p><p>4.1 测试驱动开发22</p><p>4.1.1 测试优先设计的例子23</p><p>4.1.2 测试促使模块之间隔离24</p><p>4.1.3 意外获得的解耦合25</p><p>4.2 验收测试26</p><p>4.3 意外获得的构架27</p><p>4.4 结论27</p><p>4.5 参考文献28</p><p>第5章 重构29</p><p>5.1 素数产生程序：一个简单的重构示例30</p><p>5.1.1 单元测试31</p><p>5.1.2 重构32</p><p>5.1.3 最后审视35</p><p>5.2 结论38</p><p>5.3 参考文献39</p><p>第6章 一次编程实践40</p><p>6.1 保龄球比赛40</p><p>6.2 结论75</p><p>第二部分 敏捷设计81</p><p>第7章 什么是敏捷设计81</p><p>7.1 设计臭味81</p><p>7.1.1 设计臭味——腐化软件的气味82</p><p>7.1.2 僵化性82</p><p>7.1.3 脆弱性82</p><p>7.1.4 顽固性82</p><p>7.1.5 粘滞性82</p><p>7.1.6 不必要的复杂性83</p><p>7.1.7 不必要的重复83</p><p>7.1.8 晦涩性83</p><p>7.2 软件为何会腐化84</p><p>7.3 Copy程序84</p><p>7.3.1 熟悉的场景84</p><p>7.3.2 copy程序的敏捷设计87</p><p>7.4 结论88</p><p>7.5 参考文献88</p><p>第8章 SRP：单一职责原则89</p><p>8.1 定义职责90</p><p>8.2 分离耦合的职责91</p><p>8.3 持久化92</p><p>8.4 结论92</p><p>8.5 参考文献92</p><p>第9章 OCP：开放-封闭原则93</p><p>9.1 OCP概述94</p><p>9.2 Shape应用程序95</p><p>9.2.1 违反OCP95</p><p>9.2.2 遵循OCP97</p><p>9.2.3 预测变化和“贴切的”结构98</p><p>9.2.4 放置吊钩99</p><p>9.2.5 使用抽象获得显式封闭99</p><p>9.2.6 使用“数据驱动”的方法获取封闭性100</p><p>9.3 结论101</p><p>9.4 参考文献101</p><p>第10章 LSP:Liskov替换原则102</p><p>10.1 违反LSP的情形103</p><p>10.1.1 简单例子103</p><p>10.1.2 更微妙的违反情形104</p><p>10.1.3 实际的例子108</p><p>10.2 用提取公共部分的方法代替继承111</p><p>10.3 启发式规则和习惯用法113</p><p>10.4 结论114</p><p>10.5 参考文献114</p><p>第11章 DIP：依赖倒置原则115</p><p>11.1 层次化116</p><p>11.1.1 倒置的接口所有权117</p><p>11.1.2 依赖于抽象117</p><p>11.2 简单的DIP示例117</p><p>11.3 熔炉示例119</p><p>11.4 结论121</p><p>11.5 参考文献121</p><p>第12章 ISP：接口隔离原则122</p><p>12.1 接口污染122</p><p>12.2 分离客户就是分离接口123</p><p>12.3 类接口与对象接口124</p><p>12.3.1 使用委托分离接口124</p><p>12.3.2 使用多重继承分离接口125</p><p>12.4 ATM用户界面的例子126</p><p>12.5 结论131</p><p>12.6 参考文献131</p><p>第13章 C＃程序员UML概观132</p><p>13.1 类图134</p><p>13.2 对象图135</p><p>13.3 顺序图136</p><p>13.4 协作图136</p><p>13.5 状态图137</p><p>13.6 结论137</p><p>13.7 参考文献137</p><p>第14章 使用UML138</p><p>14.1 为什么建模138</p><p>14.1.1 为什么构建软件模型139</p><p>14.1.2 编码前应该构建面面俱到的设计吗139</p><p>14.2 有效使用UML139</p><p>14.2.1 与他人交流139</p><p>14.2.2 脉络图141</p><p>14.2.3 项目结束文档142</p><p>14.2.4 要保留的和要丢弃的142</p><p>14.3 迭代式改进143</p><p>14.3.1 行为优先143</p><p>14.3.2 检查结构144</p><p>14.3.3 想象代码146</p><p>14.3.4 图的演化147</p><p>14.4 何时以及如何绘制图示147</p><p>14.4.1 何时要画图，何时不要画图147</p><p>14.4.2 CASE工具148</p><p>14.4.3 那么，文档呢149</p><p>14.5 结论149</p><p>第15章 状态图150</p><p>15.1 基础知识150</p><p>15.1.1 特定事件151</p><p>15.1.2 超状态152</p><p>15.1.3 初始伪状态和结束伪状态153</p><p>15.2 使用FSM图示153</p><p>15.3 结论154</p><p>第16章 对象图155</p><p>16.1 即时快照155</p><p>16.2 主动对象156</p><p>16.3 结论159</p><p>第17章 用例160</p><p>17.1 编写用例160</p><p>17.1.1 备选流程161</p><p>17.1.2 其他东西呢161</p><p>17.2 用例图162</p><p>17.3 结论162</p><p>17.4 参考文献162</p><p>第18章 顺序图163</p><p>18.1 基础知识163</p><p>18.1.1 对象、生命线、消息及其他164</p><p>18.1.2 创建和析构164</p><p>18.1.3 简单循环165</p><p>18.1.4 时机和场合166</p><p>18.2 高级概念168</p><p>18.2.1 循环和条件168</p><p>18.2.2 耗费时间的消息169</p><p>18.2.3 异步消息171</p><p>18.2.4 多线程174</p><p>18.2.5 主动对象175</p><p>18.2.6 向接口发送消息175</p><p>18.3 结论175</p><p>第19章 类图177</p><p>19.1 基础知识177</p><p>19.1.1 类177</p><p>19.1.2 关联178</p><p>19.1.3 继承179</p><p>19.2 类图示例180</p><p>19.3 细节181</p><p>19.3.1 类衍型181</p><p>19.3.2 抽象类182</p><p>19.3.3 属性183</p><p>19.3.4 聚集183</p><p>19.3.5 组合184</p><p>19.3.6 多重性185</p><p>19.3.7 关联衍型186</p><p>19.3.8 内嵌类187</p><p>19.3.9 关联类187</p><p>19.3.10 关联修饰符187</p><p>19.4 结论188</p><p>19.5 参考文献188</p><p>第20章 咖啡的启示189</p><p>20.1 Mark Ⅳ型专用咖啡机189</p><p>20.1.1 规格说明书190</p><p>20.1.2 常见的丑陋方案192</p><p>20.1.3 虚构的抽象193</p><p>20.1.4 改进方案194</p><p>20.1.5 实现抽象模型198</p><p>20.1.6 这个设计的好处209</p><p>20.2 面向对象过度设计214</p><p>20.3 参考文献214</p><p>第三部分 薪水支付案例研究219</p><p>第21章 COMMAND模式和ACTIVE OBJECT模式：多功能与多任务219</p><p>21.1 简单的Command220</p><p>21.2 事务221</p><p>21.2.1 实体上解耦和时间上解耦222</p><p>21.2.2 时间上解耦223</p><p>21.3 Undo（）方法223</p><p>21.4 ACTIVE OBJECT模式224</p><p>21.5 结论227</p><p>21.6 参考文献228</p><p>第22章 TEMPLATE METHOD模式和STRATEGY模式：继承和委托229</p><p>22.1 TEMPLATE METHOD模式230</p><p>22.1.1 滥用模式232</p><p>22.1.2 冒泡排序232</p><p>22.2 STRATEGY模式235</p><p>22.3 结论239</p><p>22.4 参考文献239</p><p>第23章 FACADE模式和MEDIATOR模式240</p><p>23.1 FACADE模式240</p><p>23.2 MEDIATOR模式241</p><p>23.3 结论243</p><p>23.4 参考文献243</p><p>第24章 SINGLETON模式和MONOSTATE模式244</p><p>24.1 SINGLETON模式245</p><p>24.1.1 SINGLETON模式的好处246</p><p>24.1.2 SINGLETON模式的代价246</p><p>24.1.3 运用SINGLETON模式246</p><p>24.2 MONOSTATE模式247</p><p>24.2.1 MONOSTATE模式的好处249</p><p>24.2.2 MONOSTATE模式的代价249</p><p>24.2.3 运用MONOSTATE模式249</p><p>24.3 结论253</p><p>24.4 参考文献253</p><p>第25章 NULL OBJECT模式254</p><p>25.1 描述254</p><p>25.2 结论256</p><p>25.3 参考文献256</p><p>第26章 薪水支付案例研究：第一次迭代开始257</p><p>26.1 初步的规格说明257</p><p>26.2 基于用例分析258</p><p>26.2.1 增加新雇员259</p><p>26.2.2 删除雇员260</p><p>26.2.3 登记考勤卡260</p><p>26.2.4 登记销售凭条260</p><p>26.2.5 登记工会服务费261</p><p>26.2.6 更改雇员明细261</p><p>26.2.7 发薪日263</p><p>26.3 反思：找出底层的抽象264</p><p>26.3.1 雇员支付类别抽象264</p><p>26.3.2 支付时间表抽象265</p><p>26.3.3 支付方式266</p><p>26.3.4 从属关系266</p><p>26.4 结论266</p><p>26.5 参考文献267</p><p>第27章 薪水支付案例研究：实现268</p><p>27.1 事务268</p><p>27.1.1 增加雇员269</p><p>27.1.2 删除雇员273</p><p>27.1.3 考勤卡、销售凭条以及服务费用274</p><p>27.1.4 更改雇员属性280</p><p>27.1.5 犯了什么晕287</p><p>27.1.6 支付雇员薪水290</p><p>27.1.7 支付领月薪的雇员薪水292</p><p>27.1.8 支付钟点工薪水294</p><p>27.2 主程序302</p><p>27.3 数据库303</p><p>27.4 结论304</p><p>27.5 关于本章304</p><p>27.6 参考文献305</p><p>第四部分 打包薪水支付系统308</p><p>第28章 包和组件的设计原则308</p><p>28.1 包和组件308</p><p>28.2 组件的内聚性原则：粒度309</p><p>28.2.1 重用-发布等价原则309</p><p>28.2.2 共同重用原则310</p><p>28.2.3 共同封闭原则311</p><p>28.2.4 组件内聚性总结311</p><p>28.3 组件的耦合性原则：稳定性311</p><p>28.3.1 无环依赖原则311</p><p>28.3.2 稳定依赖原则316</p><p>28.3.3 稳定抽象原则319</p><p>28.4 结论322</p><p>第29章 FACTORY模式323</p><p>29.1 依赖问题325</p><p>29.2 静态类型与动态类型326</p><p>29.3 可替换的工厂326</p><p>29.4 对测试支架使用对象工厂327</p><p>29.5 工厂的重要性328</p><p>29.6 结论329</p><p>29.7 参考文献329</p><p>第30章 薪水支付案例研究：包分析330</p><p>30.1 组件结构和符号330</p><p>30.2 应用CCP332</p><p>30.3 应用REP333</p><p>30.4 耦合和封装335</p><p>30.5 度量336</p><p>30.6 度量薪水支付应用程序337</p><p>30.6.1 对象工厂340</p><p>30.6.2 重新思考内聚的边界342</p><p>30.7 最终的包结构342</p><p>30.8 结论345</p><p>30.9 参考文献345</p><p>第31章 COMPOSITE模式346</p><p>31.1 组合命令347</p><p>31.2 多重性还是非多重性348</p><p>31.3 结论348</p><p>第32章 OBSERVER——演化至模式349</p><p>32.1 数字时钟350</p><p>32.2 OBSERVER模式365</p><p>32.2.1 模型365</p><p>32.2.2 面向对象设计原则的运用366</p><p>32.3 结论366</p><p>32.4 参考文献367</p><p>第33章 ABSTRACT SERVER模式、ADAPTER模式和BRIDGE模式368</p><p>33.1 ABSTRACT SERVER模式369</p><p>33.2 ADAPTER模式370</p><p>33.2.1 类形式的ADAPTER模式370</p><p>33.2.2 调制解调器问题、适配器以及LSP370</p><p>33.3 BRIDGE模式374</p><p>33.4 结论375</p><p>33.5 参考文献376</p><p>第34章 PROXY模式和GATEWAY模式：管理第三方API377</p><p>34.1 PROXY模式377</p><p>34.1.1 实现PROXY模式381</p><p>34.1.2 小结391</p><p>34.2 数据库、中间件以及其他第三方接口392</p><p>34.3 TABLE DATA GATEWAY394</p><p>34.3.1 测试和内存TDG399</p><p>34.3.2 测试DbGateWay400</p><p>34.4 可以用于数据库的其他模式403</p><p>34.5 结论404</p><p>34.6 参考文献404</p><p>第35章 VISITOR模式405</p><p>35.1 VISITOR模式406</p><p>35.2 ACYCLIC VISITOR模式409</p><p>35.3 DECORATOR模式418</p><p>35.4 EXTENSION OBJECT模式423</p><p>35.5 结论432</p><p>35.6 参考文献432</p><p>第36章 STATE模式433</p><p>36.1 嵌套switch/case语句434</p><p>36.1.1 内部作用域的状态变量436</p><p>36.1.2 测试动作436</p><p>36.1.3 代价和收益436</p><p>36.2 迁移表437</p><p>36.2.1 使用表解释437</p><p>36.2.2 代价和收益438</p><p>36.3 STATE模式439</p><p>36.3.1 STATE模式和STRATEGY模式441</p><p>36.3.2 代价和收益442</p><p>36.4 状态机编译器442</p><p>36.4.1 SMC生成的Turnstile.cs以及其他支持文件443</p><p>36.4.2 代价和收益448</p><p>36.5 状态机应用的场合448</p><p>36.5.1 作为GUI中的高层应用策略448</p><p>36.5.2 GUI交互控制器450</p><p>36.5.3 分布式处理450</p><p>36.6 结论451</p><p>36.7 参考文献451</p><p>第37章 薪水支付案例研究：数据库452</p><p>37.1 构建数据库452</p><p>37.2 一个代码设计缺陷453</p><p>37.3 增加雇员455</p><p>37.4 事务464</p><p>37.5 加载Employee对象468</p><p>37.6 还有什么工作478</p><p>第38章 薪水支付系统用户界面：Model-View-Presenter479</p><p>38.1 界面480</p><p>38.2 实现481</p><p>38.3 构建窗口489</p><p>38.4 Payroll窗口495</p><p>38.5 真面目504</p><p>38.6 结论505</p><p>38.7 参考文献505</p><p>附录A 双公司记506</p><p>Rufus公司：“日落”项目506</p><p>Rupert工业公司：“朝晖”项目506</p><p>附录B 什么是软件516</p><p>索引524</p><p></p></div></div><div class="d-rt"><h3>热门推荐</h3><ul><li><a href="/book/1838718.html">1838718.html</a></li><li><a href="/book/1287385.html">1287385.html</a></li><li><a href="/book/321048.html">321048.html</a></li><li><a href="/book/2564375.html">2564375.html</a></li><li><a href="/book/896746.html">896746.html</a></li><li><a href="/book/1723835.html">1723835.html</a></li><li><a href="/book/1857353.html">1857353.html</a></li><li><a href="/book/786066.html">786066.html</a></li><li><a href="/book/3208914.html">3208914.html</a></li><li><a href="/book/2717577.html">2717577.html</a></li></ul></div></div><div id="footer"><p>Copyright&nbsp;&copy;&nbsp;2025&nbsp;&nbsp;<a href="/list/">最新更新</a></p><p>请使用FDM BitComet qBittorrent uTorrent等BT下载工具，下载本站电子书资源！首推Free Download Manager下载软件。文件页数>标注页数[分册图书除外]</p></div></body></html>