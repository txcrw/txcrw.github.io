<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><script type="text/javascript" src="https://file.bkxsj.com/skin/book/js/sk.js"></script><meta name="robots" content="index,follow"><title>串行通信C程序员指南 第2版[PDF|Epub|txt|kindle电子书版本网盘下载]-灵感之桥</title><meta name="Keywords" content="串行通信C程序员指南 第2版"/><meta name="description" content="串行通信C程序员指南 第2版pdf下载文件大小为32MB,PDF页数为726页"/><meta http-equiv="X-UA-Compatible" content="IE=9; IE=8; IE=7; IE=EDGE;chrome=1"><link type="image/x-icon" rel="shortcut icon" href="https://www.shukui.net/skin/book/images/favicon.ico"><link type="text/css" rel="stylesheet" href="https://www.shukui.net/skin/book/css/style.css"><style>#main .d-main {margin-left: 0;width: 620px;}.down-btn {animation: myShake 2.5s linear .15s infinite}@keyframes myShake {0%, 66% {transform: translateZ(0)}67%, 73.6%, 83.6%, 93.6%, to {animation-timing-function: cubic-bezier(.215, .61, .355, 1);transform: translateZ(0)}80.3%, 81.4% {animation-timing-function: cubic-bezier(.755, .05, .855, .06);transform: translate3d(0, -4px, 0)}90.3% {animation-timing-function: cubic-bezier(.755, .05, .855, .06);transform: translate3d(0, -2px, 0)}97% {transform: translate3d(0, -.5px, 0)}}.copylink-btn {margin-right: 20px;}.copymd5-btn {margin-bottom: 25px;margin-left: 10px;}</style></head><body><div id="header"><div class="inner"><div class="logo"><a href="/"><img width="103" height="25" alt="灵感之桥"src="https://www.shukui.net/skin/book/images/logo.png"></a></div><div class="search"><form action="/so/search.php" target="_blank"><input type="text" autocomplete="off" id="bdcsMain" name="q" placeholder="书名 / 作者 / 出版社 / ISBN"class="inp-txt"><select class="inp-select" id="datasource" onchange="selectDatasource(this)"><option value="so">主库</option><option value="s">从库</option></select><input type="submit" value="搜索" class="inp-btn"></form></div></div></div><div id="main"><div class="d-main"><div class="tit"><h3>图书介绍</h3></div><h1 class="book-name">串行通信C程序员指南 第2版PDF|Epub|txt|kindle电子书版本网盘下载</h1><div class="d-info"><div class="b-thumb"><img src="https://www.shukui.net/cover/3/34863455.jpg" alt="串行通信C程序员指南 第2版"></div><div class="b-info"><ul><li>（美）Joe Campbell著；徐国定等译 著</li><li>出版社： 北京：清华大学出版社</li><li>ISBN：7302019002</li><li>出版时间：1995</li><li>标注页数：709页</li><li>文件大小：32MB</li><li>文件页数：726页</li><li>主题词：</li></ul></div></div><div class="tit"><h3>PDF下载</h3></div><div></br><a style="color:red;" rel="external nofollow" href="https://www.kjlm.net/ebook/3682977.html"target="_blank"><b>点此进入-本书在线PDF格式电子书下载【推荐-云解压-方便快捷】直接下载PDF格式图书。移动端-PC端通用</a></b></br><a class="down-btn" rel="external nofollow" href="https://down.trackerbk.com/bt/10/34863455.torrent"target="_blank">种子下载</a>[BT下载速度快]温馨提示：（请使用BT下载软件FDM进行下载）<a rel="nofollow" href="https://www.freedownloadmanager.org/zh/" target="_blank">软件下载地址页</a><a class="down-btn" rel="external nofollow" href="https://down.p2spdb.com/10/34863455.rar" target="_blank">直链下载</a>[便捷但速度慢]&nbsp;&nbsp;<a style="color:red;" rel="external nofollow" href="https://pdfyl.ertongbook.com/85/34863455.pdf" target="_blank"><b>[在线试读本书]</b></a>&nbsp;&nbsp;<b> <a style="color:red;" rel="external nofollow" href="https://web.jyjl.org/index/recovery.html" target="_blank">[在线获取解压码]</a></b><div class="copymd5-btn"><a href="javascript:copyToClip('ae083c49ac97ce768d59b74c3622a224')">点击复制MD5值：ae083c49ac97ce768d59b74c3622a224</a></div></div><div class="tit"><h3>下载说明</h3></div><div style="margin:20px 10px"><h2>串行通信C程序员指南 第2版PDF格式电子书版下载</h2>下载的文件为RAR压缩包。需要使用解压软件进行解压得到PDF格式图书。<br><br><div class="copymd5-btn"><a href="javascript:copyToClip('magnet:?xt=urn:btih:RX6G6JQ2LJW7PBBEDNUSCQM7ICDMHIWK')">点击复制85GB完整离线版磁力链接到迅雷FDM等BT下载工具进行下载</a>&nbsp;&nbsp;<a rel="nofollow" target="_blank">详情点击-查看共享计划</a></div>建议使用BT下载工具Free Download Manager进行下载,简称FDM(免费,没有广告,支持多平台）。本站资源全部打包为BT种子。所以需要使用专业的BT下载软件进行下载。如BitComet qBittorrent uTorrent等BT下载工具。迅雷目前由于本站不是热门资源。不推荐使用！后期资源热门了。安装了迅雷也可以迅雷进行下载！<br><br><b>（文件页数 要大于 标注页数，上中下等多册电子书除外）</b><br><br><p style="color:red;"> <b>注意：本站所有压缩包均有解压码：</b> <a rel="nofollow" target="_blank"><b>点击下载压缩包解压工具</b></a></p></div><div class="tit"><h3>图书目录</h3></div><div id="book-contents"><p>前言页1</p><p>序言1</p><p>1.1 上下文意义3</p><p>第1章 ASCII字符集3</p><p>第一部分 串行通信基础3</p><p>1.2 ASCII字符集的位4</p><p>1.1.2 人类上下文意义：字符集4</p><p>1.1.1 机器的上下文意义：指令集4</p><p>1.2.2 ASCII码表5</p><p>1.2.1 “ASCII”的歧义性5</p><p>1.3 图形字符7</p><p>1.3.1 数字字符8</p><p>1.3.2 拉丁字母表9</p><p>1.3.3 特殊字符10</p><p>1.4 控制字符13</p><p>1.3.4 ASCII码排序序列13</p><p>1.4.1 物理设备控制字符15</p><p>1.4.2 逻辑通信控制字符17</p><p>1.4.3 物理通信控制字符18</p><p>1.4.4 信息分隔符19</p><p>1.4.5 用于代码扩展的控制字符20</p><p>1.4.6 控制字符的繁难21</p><p>1.4.8 ANSI X3.64：控制代码扩展22</p><p>1.4.7 控制字符的图案表示22</p><p>1.5 控制序列前导符26</p><p>1.4.9 ANSI X3.64 控制代码格式26</p><p>1.5.1 用ANSI X3.64编程27</p><p>1.6 换行28</p><p>1.7.1 与行结束相关的词汇表29</p><p>1.7 一个合理的建议29</p><p>2.1.1 早期的并行系统30</p><p>2.1 电子通信的历史30</p><p>第2章 异步通信技术基础30</p><p>2.1.2 串行二进制系统31</p><p>2.1.3 早期的打印电报32</p><p>2.1.4 五位代码33</p><p>2.1.5 机器自动编码和解码34</p><p>2.1.6 同步化36</p><p>2.1.7 为什么要用五位代码？40</p><p>2.1.9 串行术语41</p><p>2.1.8 ASCII码的传送41</p><p>2.2.1 同步与异步串行通信的比较43</p><p>2.2 通信线路的用法43</p><p>2.3 小结44</p><p>3.2 错误检测45</p><p>3.1 错误起源45</p><p>第3章 错误及错误检测45</p><p>3.2.1 冗余位46</p><p>3.2.2 块冗余：奇介校验47</p><p>3.3.1 模-2算术运算49</p><p>3.3 循环冗余校验(CRC)49</p><p>3.3.2 普通写法的模-2除法50</p><p>3.3.3 模-2除法与硬件51</p><p>3.3.4 清除余数寄存器54</p><p>3.3.6 CRC和多项式55</p><p>3.3.5 典型的CRC电路55</p><p>3.3.7 选择生成器多项式(除数)56</p><p>3.3.9 对累加器清零的另一种考虑57</p><p>3.3.8 获得零余数57</p><p>3.4 CRC的各种变形59</p><p>3.4.3 一字节数据的CRC60</p><p>3.4.2 前导零60</p><p>3.4.1 典型CRC60</p><p>3.5 小结62</p><p>4.2 软件流控制过程63</p><p>4.1 流控制63</p><p>第4章 信息传输63</p><p>4.2.1 逐个字符的流控制过程64</p><p>4.2.2 行流控制66</p><p>4.3.2 字符协议67</p><p>4.3.1 用于硬件设备的流控制协议67</p><p>4.3 流控制协议67</p><p>4.3.4 文件传送协议69</p><p>4.3.3 整行协议69</p><p>4.4.1 发送并等待ARQ70</p><p>4.4 自动重复请求(ARQ)协议70</p><p>4.5.1 分隔信息包的控制字符71</p><p>4.5 信息包71</p><p>4.4.2 连续ARQ71</p><p>4.5.3 数据区段固定长度的信息包72</p><p>4.5.2 限定信息包的区段长度72</p><p>4.6.2 XMODEM发送73</p><p>4.6.1 XMODEM的技术说明73</p><p>4.6 XMODEM协议73</p><p>4.6.3 XMODEM接收75</p><p>4.6.4 XMODEM-CRC77</p><p>4.6.5 超时处理78</p><p>4.6.6 XMODEM的有关问题79</p><p>4.6.7 多文件XMODEM80</p><p>4.7 Kermit简介81</p><p>4.7.1 Kermit协议83</p><p>4.7.2 在Kermit信息包内控制字符的编码85</p><p>4.7.4 在Kermit DATA区段中重复计算的编码87</p><p>4.7.3 在Kermit DATA区段中数据字节高阶位的编码87</p><p>4.7.5 Kermit信息包中的区段88</p><p>4.7.6 Kermit信息包的类型89</p><p>4.7.8 终止一个传送过程91</p><p>4.7.7 一个Kermit通信会话范例91</p><p>4.7.9 Kermit的扩充93</p><p>4.7.11 加长信息包94</p><p>4.7.10 ARQ94</p><p>4.8 局部链路协议96</p><p>4.7.12 如何选择96</p><p>4.9 小结97</p><p>5.1.1 调制解调器基础99</p><p>5.1 调制解调器99</p><p>第5章 调制解调器及其控制99</p><p>5.1.2 调制100</p><p>5.1.3 通信方式或带宽用法102</p><p>5.1.4 频率调制104</p><p>5.1.5 带宽限制106</p><p>5.1.6 相位调制107</p><p>5.1.7 微分相移键控109</p><p>5.1.9 握手：建立数据链路110</p><p>5.1.8 正交调幅110</p><p>5.1.11 ECM：回波抵消系统114</p><p>5.1.10 带宽增加114</p><p>5.1.13 V.32115</p><p>5.1.12 网格编码115</p><p>5.2 调制解调器控制117</p><p>5.1.15 V.FAAT117</p><p>5.1.14 V.32bis117</p><p>5.3 RS-232标准118</p><p>5.3.1 交换电路的法定功能说明120</p><p>5.3.2 电信号特征122</p><p>5.3.3 接口电路的机械描述123</p><p>5.4 实际的RS-232124</p><p>5.4.1 调制解调器和RS-232接口125</p><p>5.4.2 微机接口129</p><p>5.5 灵巧型调制解调器130</p><p>5.5.1 调制解调器和流控制131</p><p>5.6.1 空(Null)调制解调器134</p><p>5.6 RS-232的非标准用法134</p><p>5.6.2 连接非调制解调器设备135</p><p>5.7 小结136</p><p>6.1.1 软件异步输出138</p><p>6.1 软件异步I/O138</p><p>第6章 UART：一个概念上的模型138</p><p>6.1.2 软件异步输入139</p><p>6.2.1 串行数据时钟142</p><p>6.2 UART的介绍142</p><p>6.2.2 UART发送器143</p><p>6.2.4 错误检测145</p><p>6.2.3 UART接收器145</p><p>6.2.5 接收器同步147</p><p>6.3.1 奇偶校验150</p><p>6.3 数据格式150</p><p>6.3.2 数据位个数151</p><p>6.4 RS-232接口152</p><p>6.3.4 “送BREAK”位152</p><p>6.3.3 停止位个数152</p><p>6.4.2 RS-232输入153</p><p>6.4.1 RS-232输出寄存器153</p><p>6.4.5 RS-232输出控制寄存器154</p><p>6.4.4 RS-232状态寄存器154</p><p>6.4.3 握手信号154</p><p>6.5 UART中断155</p><p>6.4.6 RS-232反相逻辑155</p><p>6.5.2 中断向量的确定156</p><p>6.5.1 生成中断156</p><p>6.6.1 过速/欠载157</p><p>6.6 FIFO式UART157</p><p>6.7.1 中断饱和158</p><p>6.7 中断等待158</p><p>6.10 小结159</p><p>6.9 一个理想FIFO的UART159</p><p>6.8 块结束问题159</p><p>7.1 National 8250/16450160</p><p>第7章 实际的UART160</p><p>7.2 8250硬件基础161</p><p>7.3.1 8250内部寄存器寻址162</p><p>7.3 8250内部结构162</p><p>7.2.1 8250时钟和同步162</p><p>7.3.2 8250寄存器用法概要164</p><p>7.3.3 8250上的中断169</p><p>7.3.4 中断服务例行程序170</p><p>7.4 National 16550 UART171</p><p>7.4.1 16550中断标识寄存器172</p><p>7.4.4 FIFO中断模式操作173</p><p>7.4.3 FIFO控制寄存器173</p><p>7.4.2 线路状态寄存器173</p><p>7.5 Zilog Z80SIO串行输入/输出控制器174</p><p>7.4.7 查询操作中16550的使用174</p><p>7.4.5 接收FIFO174</p><p>7.4.6 发送中断操作174</p><p>7.6.2 FIFO175</p><p>7.6.1 寄存器寻址175</p><p>7.6 Z80SIO与8250比较175</p><p>7.7 Z80SIO硬件基础176</p><p>7.6.5 XZ80SIO附加特征176</p><p>7.6.3 DELTA状态位锁存176</p><p>7.6.4 向量中断176</p><p>7.7.2 控制/状态口寻址178</p><p>7.7.1 数据寄存器178</p><p>7.7.3 Z80SIO中断180</p><p>7.7.4 其余寄存器概述184</p><p>7.8 小结186</p><p>第8章 baseline灵巧型调制解调器187</p><p>8.1 灵巧型调制解调器的灵巧之处何在？188</p><p>8.3.1 命令状态189</p><p>8.3 调制解调器状态189</p><p>8.2 Hayes Smart调制解调器的简史189</p><p>8.4.1 命令语法190</p><p>8.4 命令语法和调制解调器响应190</p><p>8.3.2 拨号状态190</p><p>8.3.3 握手状态190</p><p>8.3.4 在线状态190</p><p>8.3.5 在线命令状态190</p><p>8.3.6 哑终端方式190</p><p>8.4.2 命令执行时间191</p><p>8.5 软挂起：在线命令状态192</p><p>8.4.3 按键退出192</p><p>8.6 对命令的响应193</p><p>8.5.1 在线转义的危险193</p><p>8.7.1 自动波特率调整194</p><p>8.7 硬件问题194</p><p>8.7.3 非易失性存储器195</p><p>8.7.2 速率和数据格式195</p><p>8.7.4 调制解调器的RS-232接口196</p><p>8.7.7 配置开关197</p><p>8.7.6 后面板197</p><p>8.7.5 前面板197</p><p>9.2 调制解调器命令200</p><p>9.1 存根命令200</p><p>第9章 ？？调制解调器命令200</p><p>9.3.1 用户接口命令组201</p><p>9.3 方式命令201</p><p>9.3.2 基本拨号和应答命令组204</p><p>9.3.3 拨号修改标志组205</p><p>9.3.4 拨号变量命令组208</p><p>9.3.5 其他命令组210</p><p>9.3.7 电话硬件控制命令组213</p><p>9.3.6 Profile管理命令组213</p><p>9.3.8 RS-232命令组215</p><p>9.3.9 连接性选择命令组216</p><p>9.4 数字变量命令217</p><p>9.4.1 S寄存器字符变量218</p><p>9.4.2 计数/定时用S寄存器变量219</p><p>10.1.2 背景226</p><p>10.1.1 调制解调器协议226</p><p>第10章 协议调制解调器226</p><p>10.1 调制解调器协议和协议调制解调器226</p><p>10.1.3 调制解调器协议的简短回顾227</p><p>10.1.5 OSI七层网络模型228</p><p>10.1.4 网络模型228</p><p>10.2.2 体系结构230</p><p>10.2.1 同步还是异步？230</p><p>10.2 究竟什么是一个链路协议？230</p><p>10.2.4 数据等待时间231</p><p>10.2.3 数据透明性231</p><p>10.2.6 BREAK处理233</p><p>10.2.5 协议效率233</p><p>10.3.2 信息234</p><p>10.3.1 标题234</p><p>10.3 MNP协议234</p><p>10.4.6 协议效率235</p><p>10.4.5 帧校验序列235</p><p>10.3.3 帧校验序列235</p><p>10.3.4 BREAK处理235</p><p>10.4 MNP异步协议：1类和2类MNP235</p><p>10.4.1 信息包引导符235</p><p>10.4.2 标题字段235</p><p>10.4.3 信息字段235</p><p>10.4.4 信息包终结符序列235</p><p>10.5.1 信息包引导符/终结符序列236</p><p>10.5 MNP同步协议：3类和4类MNP236</p><p>10.6 LAPM(V.42)237</p><p>10.5.4 协议效率237</p><p>10.5.2 标题字段237</p><p>10.5.3 帧校验序列237</p><p>10.6.5 BREAK处理238</p><p>10.6.4 信息字段238</p><p>10.6.1 信息包引导符/终结符序列238</p><p>10.6.2 地址字段238</p><p>10.6.3 控制字段238</p><p>10.7 压缩理论239</p><p>10.7.1 重复240</p><p>10.7.2 统计重复：哈夫曼编码241</p><p>10.7.3 历史重复：Lempel-Ziv242</p><p>10.8 流控制247</p><p>10.7.6 V.42bis和5类MNP之间的比较247</p><p>10.8.1 流控制与数据压缩248</p><p>10.10 Q协议启动250</p><p>10.9 协议调制解调及其命令250</p><p>10.12 S48：特性协商251</p><p>10.11 S46：协议及压缩规程选择251</p><p>10.14 K：流控制252</p><p>10.13 S36：协商退却(Fallback)252</p><p>10.16 Wn和S95：扩展响应253</p><p>10.15 线路速度控制253</p><p>第11章 传真机256</p><p>11.1 T：30：传真通信协议258</p><p>11.2 HDLC信息包259</p><p>11.3 传真字段261</p><p>11.5.1 轮询262</p><p>11.5 同步线路控制262</p><p>11.4 成串信息包262</p><p>11.6.1 阶段A：呼叫建立263</p><p>11.6 传真的五个阶段263</p><p>11.5.2 X位(X-Bit)263</p><p>11.6.2 阶段B：识别和协商264</p><p>11.6.4 阶段D：页后过程265</p><p>11.6.3 阶段C：数据(“报文”)传输265</p><p>11.7.1 实例描述一：单页传真266</p><p>11.7 传真过程的实例描述266</p><p>11.6.5 阶段E：呼叫释放266</p><p>11.7.3 实例描述三：不同规格的多页传真268</p><p>11.7.2 实例描述二：规格相同的多页传真268</p><p>11.7.4 实例描述四：轮询方式单页传真271</p><p>11.7.5 实例描述五：在G3训练期间降低速度273</p><p>11.7.6 实例描述六：在G3训练期间提高速度274</p><p>11.8.2 新的FCF275</p><p>11.8.1 向后兼容性和可扩展性275</p><p>11.8 DIS/DCS位映象275</p><p>11.8.3 最小性能集合276</p><p>11.8.4 DIS/DCS信息包的逐位解释279</p><p>11.9 T.4.：传真图像协议282</p><p>11.10 分辨率283</p><p>11.10.1 1992年的T.4建议284</p><p>11.11.1 页面尺寸285</p><p>11.11 文件尺寸285</p><p>11.12.1 一维编码(改进型哈夫曼编码)289</p><p>11.12 传真编码289</p><p>11.12.2 二维编码(READ编码)294</p><p>11.12.3 线终码297</p><p>11.12.3 编码方式综述297</p><p>11.12.4 页编码299</p><p>11.13 差错300</p><p>11.13.1 纠错301</p><p>11.14 EIA传真调制解调器302</p><p>11.15 EIA 578(Class1)304</p><p>11.15.1 Clas-1服务305</p><p>11.15.2 命令综述306</p><p>11.16 会话实例309</p><p>12.1.1 SIOLOCAL.H文件314</p><p>12.1 Microsoft C编译器314</p><p>第二部分 用C语言编写异步通信程序314</p><p>第12章 设计一个基本的串行I/O库314</p><p>12.2 串行I/P库317</p><p>12.2.1 函数库的层次结构--分级319</p><p>12.2.2 用于屏蔽状态寄存器的常量321</p><p>12.2.3 U16x.LIB322</p><p>12.2.4 2级库：BUOS.LIB325</p><p>12.2.5 3级库：SIO.LIB326</p><p>12.3 终端模拟程序的第一个版本TERM0327</p><p>12.3.1 控制台I/O328</p><p>12.4 TERM0329</p><p>12.5.1 0级模块：IBMPC.C.331</p><p>12.5 连接TERM0331</p><p>12.6 小结332</p><p>13.1 1级函数333</p><p>第13章 程序的可移植性333</p><p>13.1.1 结构中的函数指针334</p><p>13.1.2 含有指向UART读/写函数的指针的结构sio335</p><p>13.1.3 修改后的RART.LIB函数336</p><p>13.2 SIO数据类型337</p><p>13.1.4 内存映象系统各的指针337</p><p>13.2.1 管理多个SIO338</p><p>13.3 修改1级函数339</p><p>13.4.1 进一步讨论函数指针341</p><p>13.4 修改2级函数341</p><p>13.3.1 寄存器存储类型register341</p><p>13.4.2 BUOS.LIB中修改后的2级函数342</p><p>13.4.3 声明和初始化SIO343</p><p>13.6.1 延时346</p><p>13.6 定时函数的类型346</p><p>13.5 为内存映象UART提供的SIO结构346</p><p>13.5.1 定时函数346</p><p>13.7.1 系统节拍器347</p><p>13.7 系统定时器和时间保持器347</p><p>13.6.2 超时功能347</p><p>13.8 设计一个虚拟的定时系统348</p><p>13.7.2 系统节拍器的软件接口348</p><p>13.8.1 IBM PC机的定时程序349</p><p>13.8.2 0级定时函数delay350</p><p>13.8.3 “等待字符”函数351</p><p>13.9 为定时参数定义常量352</p><p>13.10 UART清除器353</p><p>13.10.1 测试定时函数的程序354</p><p>13.11 小结355</p><p>14.1 设计目标356</p><p>第14章 波特率和数据格式函数356</p><p>14.1.2 一般假设357</p><p>14.1.1 用户准则357</p><p>14.1.3 虚拟寄存器358</p><p>14.2 IBM PC机的数据格式361</p><p>14.2.1 16X50的虚拟寄存器数组362</p><p>14.2.2 位操作的通用结构(vergbits_)363</p><p>14.2.3 IBM PC机上的数据格式364</p><p>14.2.4 通过SIO指针访问虚拟寄存器365</p><p>14.2.5 为停止位和数据长度声明的结构366</p><p>14.2.6 多寄存器操作367</p><p>14.2.7 最终版的vsetbits函数369</p><p>14.2.9 3级数据络式函数371</p><p>14.2.8 16X50的1级函数(_vestbits)371</p><p>14.3 波特率函数373</p><p>14.2.10 结构定义的位置373</p><p>14.3.1 vbaud_数据结构374</p><p>14.3.2 IBM PC的波特率数据结构375</p><p>14.3.3 设置波特率的2级函数376</p><p>14.3.4 用于16X50的1级波特率函数(_vsetbr)377</p><p>14.3.5 设置波特率的3级函数378</p><p>14.4.1 用于16X50的设置和恢复函数：s_config和s_restore379</p><p>14.4 配置和恢复379</p><p>14.4.2 用于数据格式、波特率和检错的字符串数组381</p><p>14.5 TERM2382</p><p>14.6 小结387</p><p>15.1.1 RS-232 UART输出388</p><p>15.1 RS-232输出控制388</p><p>第15章 RS-232输入控制388</p><p>15.1.2 TERM3397</p><p>15.2.1 VIN232_结构400</p><p>15.2 RS-232输入控制400</p><p>15.2.3 VIN232_结构的说明401</p><p>15.2.2 RS-232输入常量401</p><p>15.2.4 第2级RS-232输入函数(VSTAT232)402</p><p>15.2.5 新的SIO结构成员403</p><p>15.2.6 RS-232输入状态的第1级函数404</p><p>15.2.7 第3级RS-232输入函数405</p><p>15.2.8 SIO说明和初始化406</p><p>15.2.9 TERM的若干改动407</p><p>15.3 小结408</p><p>16.1.1 虚拟流控制409</p><p>16.1 流控制409</p><p>第16章 流控制和SIO管理409</p><p>16.2 商品管理413</p><p>16.2.1 打开串行I/O设备415</p><p>16.2.2 第3级open函数418</p><p>16.2.3 第3级关闭函数420</p><p>16.3 发送器和接收器函数421</p><p>16.3.1 第3级中的其他函数423</p><p>16.4 TERM的修订版424</p><p>16.5 小结425</p><p>第17章 格式输出426</p><p>17.1 格式输出427</p><p>17.1.1 soctl_结构的说明和初始化429</p><p>17.2 输出控制函数430</p><p>17.1.2 SIO结构的新结构成员430</p><p>17.2.1 速度考虑433</p><p>17.2.3 “原始”模式435</p><p>17.2.2 s_fputc概述435</p><p>17.2.4 字节的转换和删除436</p><p>17.2.6 行结束转换437</p><p>17.2.5 控制字符删除437</p><p>17.2.7 被发送字节的处理438</p><p>17.3.1 逐个字符的字符串输出440</p><p>17.3 格式I/0的第3级函数440</p><p>17.3.2 操作soctl_结构成员的函数441</p><p>17.3.3 输出控制结构的临时存储444</p><p>17.4 TERM4446</p><p>17.4.2 改进建议449</p><p>17.4.1 传送文件的其他设计方法449</p><p>17.5 小结450</p><p>18.1.1 sictl_结构451</p><p>18.1 格式输入函数451</p><p>第18章 格式输入451</p><p>18.1.3 SIO结构的新结构成员453</p><p>18.1.2 sictl_结构的说明和初始化453</p><p>18.2 s_fgetc概述454</p><p>18.2.1 原始处理457</p><p>18.2.5 “回读”机制458</p><p>18.2.4 行结束符的转换458</p><p>18.2.2 控制逻辑458</p><p>18.2.3 超时操作458</p><p>18.2.6 有关速度的进一步讨论459</p><p>18.3 格式输入的第3级函数460</p><p>18.2.7 回送460</p><p>18.3.1 输入控制结构的临时存储461</p><p>18.4.1 s_fgets函数462</p><p>18.4 带来方便的第3级输入函数462</p><p>18.5 TERM5463</p><p>18.5.1 数据转储函数dnload的设计465</p><p>18.5.3 读取函数1：cbuff468</p><p>18.5.2 数据获取函数的设计468</p><p>18.5.4 读取函数2：locbuff472</p><p>18.6 小结474</p><p>19.2 中断475</p><p>19.1 中断的基础概念475</p><p>第19章 中断I/O导论475</p><p>19.3 IBM PC机的中断结构476</p><p>19.2.1 中断和异步I/O476</p><p>19.3.1 8259外围中断控制器(PIC)477</p><p>19.4.1 SIO的新结构成员和常量478</p><p>19.4 系统中断函数478</p><p>19.4.2 主中断处理程序480</p><p>19.4.3 整体系统结构482</p><p>19.4.4 __sys_introff函数485</p><p>19.5.1 URAT中断管理程序486</p><p>19.5 UART中断函数486</p><p>19.5.2 SIO中断管理程序s_iadmin487</p><p>19.5.3 UART中断的再向量化488</p><p>19.5.4 摘要489</p><p>19.6.1 对s_spen的改动490</p><p>19.6 对第3级函数的改动490</p><p>19.6.2 对s_close的改动492</p><p>19.7 小结493</p><p>第20章 中断子处理程序494</p><p>20.1.2 串行化出错子处理程序497</p><p>20.1.1 SIO中的串行化出错497</p><p>20.1 串行化出错中断497</p><p>20.1.3 串行化出错的高层接口498</p><p>20.1.4 串行化出错的中断控制499</p><p>20.2 RS-232状态中断500</p><p>20.2.1 RS-232中断子处理程序501</p><p>20.2.2 RS-232中断控制502</p><p>20.3 检测I6550503</p><p>20.3.1 s_config函数的修改504</p><p>20.4.1 接收器中断缓冲区的设计505</p><p>20.4 接收器中断505</p><p>20.4.2 接收器中断子处理程序506</p><p>20.4.3 接收器中断到SIO的接口508</p><p>20.4.4 接收器中断控制509</p><p>20.5.1 发送器中断缓冲区的设计511</p><p>20.5 发送器中断511</p><p>20.5.2 发送器中断子处理程序512</p><p>20.5.3 发送器中断控制515</p><p>20.6 发送器中断到SIO的接口518</p><p>20.6.1 成块写接口518</p><p>20.7 TERM6522</p><p>第21章 灵巧型调制解调器程序设计524</p><p>21.1 基本设计标准524</p><p>21.1.1 用户接口524</p><p>21.1.2 RS-232控制525</p><p>21.1.3 兼容性525</p><p>21.1.4 通用性525</p><p>21.2 调制解调器的结构和常量525</p><p>21.3 调制解调器命令528</p><p>21.3.1 命令和响应的结构成员528</p><p>21.3.2 发送调制解调器命令：m_cmd529</p><p>21.4 获取调制解调器的应答530</p><p>21.4.1 取应答函数:s_fgetln530</p><p>21.4.2 取应答函数:m_getstr532</p><p>21.5 对调制解调器函数533</p><p>21.5.1 验证应答函数：m_ismessage534</p><p>21.6 高层调制解调器函数536</p><p>21.6.1 发送命令，读取应答的函数：m_cmd_str536</p><p>21.6.2 发送命令，验证其有效性：m_cmd_OK537</p><p>21.6.3 强制调制解调器转入命令状态：m_gocmd538</p><p>21.7.1 重置函数所需的调制解调器结构成员539</p><p>21.7.2 重置调制解调器的函数：m_reset539</p><p>21.7 重置函数539</p><p>21.7.3 识别调制解调器：m_whoru543</p><p>21.7.4 用于识别所需的结构成员543</p><p>21.8 对基线调制解调器进行配置545</p><p>21.8.1 配置：m_config和m_unconfig546</p><p>21.9 协议调制解调器548</p><p>21.9.1 波特率转换549</p><p>21.9.2 回归到无协议情况549</p><p>21.9.3 CONNECT消息550</p><p>21.9.4 配置550</p><p>21.9.5 协议配置的结构成员551</p><p>21.9.6 配置协议调制解调器:m_oarsernsg552</p><p>21.9.7 分析调制解调器应答的函数：m_parsernsg554</p><p>21.9.8 有关m_parsemsg的说明556</p><p>21.10 拨号和回答函数557</p><p>21.10.1 返回呼叫-进行应答：m_wait4dcd557</p><p>21.10.2 自动拨号函数:m_dial559</p><p>21.10.3 重拨上一次的号码：m_redial561</p><p>21.10.4 回答电话：m_answer561</p><p>21.10.5 终止连接的函数：m_hup562</p><p>21.10.6 考察数据载波检测(DCD)：m_warndcd563</p><p>21.10.7 调制解调器函数的字符串数组564</p><p>21.11 TERM6565</p><p>21.11.1 TERM6的一个解释568</p><p>21.12 小结569</p><p>第22章 XMODEM文件传送570</p><p>22.1 文件传送的设计考虑570</p><p>22.2 异常处理571</p><p>22.3 XMODEM传送578</p><p>22.4 XMODEM接收590</p><p>22.5 校验和出错检测函数599</p><p>22.6 结论601</p><p>23.1 多项式与CRC函数603</p><p>23.1.1 用硬件和软件实现多项式除数603</p><p>第23章 循环冗余校验CRC计算603</p><p>23.1.2 模拟CRC硬件：crchware606</p><p>23.1.3 用查表法计算CRC608</p><p>23.2 为x_snd和x_rcv提供的CRCbiov611</p><p>23.2.1 发送CRC的函数:x_sndcrc611</p><p>23.2.1 接收CRC：x_reverc612</p><p>23.3 CRC-16的计算613</p><p>23.3.1 CRC函数的CRC测试程序：CRC.C616</p><p>23.4 小结617</p><p>第24章 Group3传真图象的编码和解码618</p><p>24.1 创建一个测试位图619</p><p>24.2 T.4 编码621</p><p>24.2.1 RUN2T4：把行程编码转换为修订的哈夫曼编码624</p><p>24.3 T.4解码630</p><p>24.3.1 T4DECODE：对修订的哈夫曼编码进行解码631</p><p>24.3.2 T4TORUN：修正的哈夫曼行程编码635</p><p>24.3.3 行程编码转换为位图图象636</p><p>1.期刊641</p><p>2.书籍641</p><p>参考书目641</p><p>3.标准及参考文献643</p><p>美国国家标准协会的文件643</p><p>电子/远程通信工程协会的文件644</p><p>CCITT644</p><p>附录A 附带函数646</p><p>BIGBUFF646</p><p>HAKTC647</p><p>PUTBIN648</p><p>RFOPEN648</p><p>STR_ATIO649</p><p>WFOPEN649</p><p>B.1 汇编代码651</p><p>B.1.1 汇编程序体：CPGSC.ASM651</p><p>附录B 汇编程序接口和内存模式651</p><p>B.2 主ISR：COM1ISR.ASM653</p><p>B.3 宏：CQGSC.MAC655</p><p>附录C IBMPC.C657</p><p>C.1 SIO初始化程序：COM1SIO.C659</p><p>附录D 头文件667</p><p>ASCII.H667</p><p>BUOS.H668</p><p>CRC.H668</p><p>IBMPC.H669</p><p>LEVELO.H670</p><p>MISE.H670</p><p>KEY.H670</p><p>MODEM.H671</p><p>SIOCTL.H673</p><p>SIODEF.H675</p><p>SIOLOCAL/H683</p><p>T4.H683</p><p>UART.H684</p><p>U16X50.H684</p><p>TERM.H684</p><p>XMOD.H687</p><p>附录E TERM7690</p><p>附录F 传真编码和解码表695</p><p>附录G 函数索引706</p><p></p></div></div><div class="d-rt"><h3>热门推荐</h3><ul><li><a href="/book/1292542.html">1292542.html</a></li><li><a href="/book/1354465.html">1354465.html</a></li><li><a href="/book/1326638.html">1326638.html</a></li><li><a href="/book/2044887.html">2044887.html</a></li><li><a href="/book/622445.html">622445.html</a></li><li><a href="/book/1754670.html">1754670.html</a></li><li><a href="/book/2210973.html">2210973.html</a></li><li><a href="/book/237771.html">237771.html</a></li><li><a href="/book/2959063.html">2959063.html</a></li><li><a href="/book/2541436.html">2541436.html</a></li></ul></div></div><div id="footer"><p>Copyright&nbsp;&copy;&nbsp;2025&nbsp;&nbsp;<a href="/list/">最新更新</a></p><p>请使用FDM BitComet qBittorrent uTorrent等BT下载工具，下载本站电子书资源！首推Free Download Manager下载软件。文件页数>标注页数[分册图书除外]</p></div></body></html>