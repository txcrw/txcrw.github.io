<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><script type="text/javascript" src="https://file.bkxsj.com/skin/book/js/sk.js"></script><meta name="robots" content="index,follow"><title>深入理解Android系统[PDF|Epub|txt|kindle电子书版本网盘下载]-灵感之桥</title><meta name="Keywords" content="深入理解Android系统"/><meta name="description" content="深入理解Android系统pdf下载文件大小为138MB,PDF页数为709页"/><meta http-equiv="X-UA-Compatible" content="IE=9; IE=8; IE=7; IE=EDGE;chrome=1"><link type="image/x-icon" rel="shortcut icon" href="https://www.shukui.net/skin/book/images/favicon.ico"><link type="text/css" rel="stylesheet" href="https://www.shukui.net/skin/book/css/style.css"><style>#main .d-main {margin-left: 0;width: 620px;}.down-btn {animation: myShake 2.5s linear .15s infinite}@keyframes myShake {0%, 66% {transform: translateZ(0)}67%, 73.6%, 83.6%, 93.6%, to {animation-timing-function: cubic-bezier(.215, .61, .355, 1);transform: translateZ(0)}80.3%, 81.4% {animation-timing-function: cubic-bezier(.755, .05, .855, .06);transform: translate3d(0, -4px, 0)}90.3% {animation-timing-function: cubic-bezier(.755, .05, .855, .06);transform: translate3d(0, -2px, 0)}97% {transform: translate3d(0, -.5px, 0)}}.copylink-btn {margin-right: 20px;}.copymd5-btn {margin-bottom: 25px;margin-left: 10px;}</style></head><body><div id="header"><div class="inner"><div class="logo"><a href="/"><img width="103" height="25" alt="灵感之桥"src="https://www.shukui.net/skin/book/images/logo.png"></a></div><div class="search"><form action="/so/search.php" target="_blank"><input type="text" autocomplete="off" id="bdcsMain" name="q" placeholder="书名 / 作者 / 出版社 / ISBN"class="inp-txt"><select class="inp-select" id="datasource" onchange="selectDatasource(this)"><option value="so">主库</option><option value="s">从库</option></select><input type="submit" value="搜索" class="inp-btn"></form></div></div></div><div id="main"><div class="d-main"><div class="tit"><h3>图书介绍</h3></div><h1 class="book-name">深入理解Android系统PDF|Epub|txt|kindle电子书版本网盘下载</h1><div class="d-info"><div class="b-thumb"><img src="https://www.shukui.net/cover/40/30018192.jpg" alt="深入理解Android系统"></div><div class="b-info"><ul><li>张元亮编著 著</li><li>出版社： 北京：清华大学出版社</li><li>ISBN：9787302404392</li><li>出版时间：2015</li><li>标注页数：697页</li><li>文件大小：138MB</li><li>文件页数：709页</li><li>主题词：移动终端－应用程序－程序设计</li></ul></div></div><div class="tit"><h3>PDF下载</h3></div><div></br><a style="color:red;" rel="external nofollow" href="https://www.kjlm.net/ebook/15530.html"target="_blank"><b>点此进入-本书在线PDF格式电子书下载【推荐-云解压-方便快捷】直接下载PDF格式图书。移动端-PC端通用</a></b></br><a class="down-btn" rel="external nofollow" href="https://down.trackerbk.com/bt/00/30018192.torrent"target="_blank">种子下载</a>[BT下载速度快]温馨提示：（请使用BT下载软件FDM进行下载）<a rel="nofollow" href="https://www.freedownloadmanager.org/zh/" target="_blank">软件下载地址页</a><a class="down-btn" rel="external nofollow" href="https://down.p2spdb.com/00/30018192.rar" target="_blank">直链下载</a>[便捷但速度慢]&nbsp;&nbsp;<a style="color:red;" rel="external nofollow" href="https://pdfyl.ertongbook.com/01/30018192.pdf" target="_blank"><b>[在线试读本书]</b></a>&nbsp;&nbsp;<b> <a style="color:red;" rel="external nofollow" href="https://web.jyjl.org/index/recovery.html" target="_blank">[在线获取解压码]</a></b><div class="copymd5-btn"><a href="javascript:copyToClip('d171370910db7183aa55a896384668b2')">点击复制MD5值：d171370910db7183aa55a896384668b2</a></div></div><div class="tit"><h3>下载说明</h3></div><div style="margin:20px 10px"><h2>深入理解Android系统PDF格式电子书版下载</h2>下载的文件为RAR压缩包。需要使用解压软件进行解压得到PDF格式图书。<br><br><div class="copymd5-btn"><a href="javascript:copyToClip('magnet:?xt=urn:btih:RX6G6JQ2LJW7PBBEDNUSCQM7ICDMHIWK')">点击复制85GB完整离线版磁力链接到迅雷FDM等BT下载工具进行下载</a>&nbsp;&nbsp;<a rel="nofollow" target="_blank">详情点击-查看共享计划</a></div>建议使用BT下载工具Free Download Manager进行下载,简称FDM(免费,没有广告,支持多平台）。本站资源全部打包为BT种子。所以需要使用专业的BT下载软件进行下载。如BitComet qBittorrent uTorrent等BT下载工具。迅雷目前由于本站不是热门资源。不推荐使用！后期资源热门了。安装了迅雷也可以迅雷进行下载！<br><br><b>（文件页数 要大于 标注页数，上中下等多册电子书除外）</b><br><br><p style="color:red;"> <b>注意：本站所有压缩包均有解压码：</b> <a rel="nofollow" target="_blank"><b>点击下载压缩包解压工具</b></a></p></div><div class="tit"><h3>图书目录</h3></div><div id="book-contents"><p>第1章 获取并编译Android源码1</p><p>1.1 获取Android源码1</p><p>1.1.1 在Linux系统获取Android源码1</p><p>1.1.2 在Windows平台获取Android源码3</p><p>1.2 分析Android源码结构6</p><p>1.2.1 总体结构6</p><p>1.2.2 应用程序部分7</p><p>1.2.3 应用程序框架部分9</p><p>1.2.4 系统服务部分10</p><p>1.2.5 系统程序库部分12</p><p>1.2.6 系统运行库部分15</p><p>1.2.7 硬件抽象层部分16</p><p>1.3 分析源码中提供的接口17</p><p>1.3.1 暴露接口和隐藏接口17</p><p>1.3.2 调用隐藏接口23</p><p>1.4 编译源码26</p><p>1.4.1 搭建编译环境26</p><p>1.4.2 在模拟器中运行29</p><p>1.5 编译源码生成SDK30</p><p>第2章 分析JNI35</p><p>2.1 JNI基础35</p><p>2.1.1 JNI的功能结构35</p><p>2.1.2 JNI的调用层次36</p><p>2.1.3 分析JNI的本质36</p><p>2.2 分析MediaScanner38</p><p>2.2.1 分析Java层38</p><p>2.2.2 分析JNI层45</p><p>2.2.3 分析Native（本地）层46</p><p>2.3 分析Camera系统的JNI54</p><p>2.3.1 Java层预览接口54</p><p>2.3.2 注册预览的JNI函数56</p><p>2.3.3 C/C＋＋层的预览函数59</p><p>2.4 Java与JNI基本数据类型转换60</p><p>2.5 JNIEnv接口61</p><p>2.6 开发JNI程序62</p><p>2.6.1 开发JNI程序的步骤62</p><p>2.6.2 开发一个自己的JNI程序63</p><p>第3章 内存系统架构详解66</p><p>3.1 分析Android的进程通信机制66</p><p>3.1.1 IPC机制介绍66</p><p>3.1.2 Service Manager是Binder机制的上下文管理者67</p><p>3.1.3 Service Manager服务84</p><p>3.2 分析匿名共享内存子系统87</p><p>3.2.1 Ashmem系统基础87</p><p>3.2.2 基础数据结构88</p><p>3.2.3 初始化处理89</p><p>3.2.4 打开匿名共享内存设备文件90</p><p>3.2.5 实现内存映射93</p><p>3.2.6 实现读／写操作94</p><p>3.2.7 实现锁定和解锁96</p><p>3.2.8 回收内存块102</p><p>3.3 分析C＋＋访问接口层103</p><p>3.3.1 接口MemoryHeapBase103</p><p>3.3.2 接口MemoryBase112</p><p>3.4 分析Java访问接口层115</p><p>第4章 硬件抽象层架构详解120</p><p>4.1 HAL基础120</p><p>4.1.1 推出HAL的背景120</p><p>4.1.2 HAL的基本结构121</p><p>4.2 分析HAL module架构123</p><p>4.2.1 hw_module_t124</p><p>4.2.2 hw_module_methods_t124</p><p>4.2.3 hw_device_t125</p><p>4.3 分析文件hardware.c126</p><p>4.3.1 寻找动态链接库的地址126</p><p>4.3.2 数组variant_keys126</p><p>4.3.3 载入相应的库127</p><p>4.3.4 获得hw_module_t结构体127</p><p>4.4 分析硬件抽象层的加载过程128</p><p>4.5 分析硬件访问服务132</p><p>4.5.1 定义硬件访问服务接口132</p><p>4.5.2 具体实现133</p><p>4.6 分析官方实例134</p><p>4.6.1 获取实例工程源码135</p><p>4.6.2 直接调用service（）方法的实现代码136</p><p>4.6.3 通过Manager调用service的实现代码141</p><p>4.7 HAL和系统移植144</p><p>4.7.1 移植各个Android部件的方式144</p><p>4.7.2 设置设备权限144</p><p>4.7.3 init.rc初始化148</p><p>4.7.4 文件系统的属性148</p><p>4.8 开发自己的HAL150</p><p>4.8.1 封装HAL接口150</p><p>4.8.2 开始编译153</p><p>第5章 Binder通信机制详解155</p><p>5.1 分析Binder驱动程序155</p><p>5.1.1 数据结构binder_work155</p><p>5.1.2 结构体binder_node156</p><p>5.1.3 结构体binder_ref157</p><p>5.1.4 通知结构体binder_ref_death158</p><p>5.1.5 结构体binder_buffer158</p><p>5.1.6 结构体binder_proc159</p><p>5.1.7 结构体binder_thread160</p><p>5.1.8 结构体binder_transaction161</p><p>5.1.9 结构体binder_write_read162</p><p>5.1.10 BinderDriverCommandProtocol162</p><p>5.1.11 枚举BinderDriverReturnProtocol163</p><p>5.1.12 结构体binder_ptr_cookie和binder_transaction_data164</p><p>5.1.13 结构体flat_binder_object164</p><p>5.1.14 设备初始化165</p><p>5.1.15 打开Binder设备文件167</p><p>5.1.16 实现内存映射168</p><p>5.1.17 释放物理页面173</p><p>5.1.18 分配内核缓冲区174</p><p>5.1.19 释放内核缓冲区176</p><p>5.1.20 查询内核缓冲区179</p><p>5.2 Binder封装库179</p><p>5.2.1 Binder的3层结构180</p><p>5.2.2 类BBinder181</p><p>5.2.3 类BpRefBase183</p><p>5.2.4 类IPCThreadState185</p><p>5.3 初始化Java层Binder框架188</p><p>5.3.1 搭建交互关系188</p><p>5.3.2 实现Binder类的初始化188</p><p>5.3.3 实现BinderProxy类的初始化190</p><p>5.4 实体对象binder_node190</p><p>5.4.1 定义实体对象191</p><p>5.4.2 增加引用计数192</p><p>5.4.3 减少引用计数193</p><p>5.5 本地对象BBinder194</p><p>5.5.1 引用了运行的本地对象195</p><p>5.5.2 处理接口协议201</p><p>5.6 引用对象binder_ref205</p><p>5.7 代理对象BpBinder208</p><p>5.7.1 创建Binder代理对象208</p><p>5.7.2 销毁Binder代理对象209</p><p>第6章 init启动进程详解213</p><p>6.1 什么是init进程213</p><p>6.2 入口函数214</p><p>6.3 init配置文件217</p><p>6.3.1 init.rc基础217</p><p>6.3.2 init.rc解析219</p><p>6.4 解析Service223</p><p>6.4.1 Zygote对应的service action224</p><p>6.4.2 init组织Service224</p><p>6.4.3 解析Service用到的函数226</p><p>6.5 解析on230</p><p>6.5.1 Zygote对应的on action230</p><p>6.5.2 结构体action232</p><p>6.5.3 解析on字段所在的option232</p><p>6.6 init控制Service233</p><p>6.6.1 启动Zygote233</p><p>6.6.2 启动Service234</p><p>6.6.3 总结4种启动Service的方式238</p><p>6.7 启动属性服务243</p><p>6.7.1 引入属性243</p><p>6.7.2 设置内核变量245</p><p>6.7.3 初始化属性服务246</p><p>6.7.4 实现具体启动工作247</p><p>6.7.5 获取属性值249</p><p>6.7.6 处理请求251</p><p>第7章 Zygote进程详解253</p><p>7.1 Zygote基础253</p><p>7.2 启动Zygote254</p><p>7.2.1 init.c启动脚本254</p><p>7.2.2 创建一个Socket258</p><p>7.2.3 入口函数main（）260</p><p>7.2.4 启动函数创建一个虚拟机实例262</p><p>7.2.5 和Zygote进程中的Socket实现连接264</p><p>第8章 System进程详解271</p><p>8.1 启动前的准备271</p><p>8.1.1 获取创建的Socket271</p><p>8.1.2 启动System进程272</p><p>8.2 分析SystemServer272</p><p>8.2.1 分析主函数main（）272</p><p>8.2.2 分析函数init2（）275</p><p>8.3 第一个启动的ServiceEntropyService275</p><p>8.3.1 将内容写到urandom设备276</p><p>8.3.2 将和设备相关的信息写到urandom设备277</p><p>8.3.3 读取urandom设备的内容277</p><p>8.3.4 发送ENTROPY_WHAT278</p><p>8.4 生成并管理日志文件278</p><p>8.4.1 分析DBMS构造函数278</p><p>8.4.2 添加dropbox日志文件280</p><p>8.4.3 DBMS和settings数据库284</p><p>8.5 分析DiskStatsService285</p><p>8.6 监测系统内部存储空间的状态289</p><p>8.6.1 构造函数289</p><p>8.6.2 内存检查290</p><p>8.7 分析实现性能统计292</p><p>8.7.1 构造函数292</p><p>8.7.2 进行性能统计293</p><p>8.7.3 输出统计文件295</p><p>8.8 剪贴板服务302</p><p>8.8.1 复制数据到剪贴板302</p><p>8.8.2 从剪贴板粘贴数据304</p><p>8.8.3 管理CBS中的权限306</p><p>第9章 应用程序进程详解309</p><p>9.1 创建应用程序309</p><p>9.1.1 发送创建请求309</p><p>9.1.2 保存启动参数312</p><p>9.1.3 创建指定的应用程序314</p><p>9.1.4 创建本地对象LocalSocket315</p><p>9.1.5 接收创建新应用程序的请求316</p><p>9.2 启动线程池320</p><p>9.3 创建信息循环322</p><p>第10章 ART机制架构详解324</p><p>10.1 分析ART的启动过程324</p><p>10.1.1 运行app_process进程325</p><p>10.1.2 准备启动329</p><p>10.1.3 创建运行实例336</p><p>10.1.4 注册本地JNI函数338</p><p>10.1.5 启动守护进程339</p><p>10.1.6 解析参数340</p><p>10.1.7 初始化类、方法和域350</p><p>10.2 进入main（）主函数357</p><p>10.3 查找目标类358</p><p>10.3.1 函数LookupClass（）359</p><p>10.3.2 函数DefineClass（）361</p><p>10.3.3 函数InsertClass（）365</p><p>10.3.4 函数LinkClass（）366</p><p>10.4 类操作368</p><p>10.5 实现托管操作370</p><p>第11章 Sensor传感器系统架构详解376</p><p>11.1 Android传感器系统概述376</p><p>11.2 Java层详解377</p><p>11.3 Frameworks层详解383</p><p>11.3.1 监听传感器的变化383</p><p>11.3.2 注册监听384</p><p>11.4 JNI层详解396</p><p>11.4.1 实现Native（本地）函数396</p><p>11.4.2 处理客户端数据401</p><p>11.4.3 处理服务端数据403</p><p>11.4.4 封装HAL层的代码417</p><p>11.4.5 处理消息队列422</p><p>11.5 HAL层详解425</p><p>第12章 蓝牙系统架构详解435</p><p>12.1 短距离无线通信技术概览435</p><p>12.1.1 ZigBee——低功耗、自组网435</p><p>12.1.2 Wi-Fi——大带宽支持家庭互联435</p><p>12.1.3 蓝牙——4.0进入低功耗时代436</p><p>12.1.4 NFC——必将逐渐远离历史舞台436</p><p>12.2 蓝牙技术基础437</p><p>12.2.1 蓝牙技术的发展历程437</p><p>12.2.2 低功耗蓝牙的特点437</p><p>12.2.3 低功耗蓝牙的架构438</p><p>12.2.4 低功耗蓝牙分类439</p><p>12.2.5 集成方式439</p><p>12.2.6 BLE和传统蓝牙BR/EDR技术的对比440</p><p>12.3 蓝牙规范详解440</p><p>12.3.1 Bluetooth系统中的常用规范441</p><p>12.3.2 蓝牙协议体系结构441</p><p>12.3.3 低功耗（BLE）蓝牙协议443</p><p>12.3.4 现有的基于GATT的协议／服务443</p><p>12.3.5 双模协议栈444</p><p>12.3.6 单模协议栈445</p><p>12.4 低功耗蓝牙协议栈详解445</p><p>12.4.1 低功耗蓝牙协议栈基础445</p><p>12.4.2 蓝牙协议体系中的协议446</p><p>12.5 TI公司的低功耗蓝牙448</p><p>12.5.1 获取TI公司的低功耗蓝牙协议栈448</p><p>12.5.2 分析TI公司的低功耗蓝牙协议栈450</p><p>12.6 分析Android系统中的蓝牙模块456</p><p>12.7 分析蓝牙模块的源码458</p><p>12.7.1 初始化蓝牙芯片458</p><p>12.7.2 蓝牙服务458</p><p>12.7.3 管理蓝牙电源459</p><p>12.8 Android系统的低功耗蓝牙协议栈459</p><p>12.8.1 Android低功耗蓝牙协议栈基础460</p><p>12.8.2 低功耗蓝牙API详解460</p><p>第13章 Android多媒体框架架构详解498</p><p>13.1 Android多媒体系统介绍498</p><p>13.2 OpenMax框架详解499</p><p>13.2.1 分析OpenMax框架构成500</p><p>13.2.2 实现OpenMaxIL层接口504</p><p>13.3 OpenCore框架详解512</p><p>13.3.1 OpenCore层次结构512</p><p>13.3.2 OpenCore代码结构513</p><p>13.3.3 OpenCore编译结构514</p><p>13.3.4 操作系统兼容库518</p><p>13.3.5 实现OpenCore中的OpenMax部分520</p><p>13.4 StageFright框架详解532</p><p>13.4.1 StageFright代码结构533</p><p>13.4.2 StageFright实现OpenMax接口533</p><p>13.4.3 分析Video Buffer传输流程537</p><p>第14章 音频系统框架架构详解554</p><p>14.1 硬件架构的发展趋势554</p><p>14.1.1 原始架构模式554</p><p>14.1.2 移动处理器的解决方案554</p><p>14.1.3 升级版高通骁龙801555</p><p>14.2 音频系统基础557</p><p>14.3 音频系统的层次559</p><p>14.3.1 层次说明559</p><p>14.3.2 Media库中的Audio框架559</p><p>14.3.3 本地代码562</p><p>14.3.4 分析JNI代码564</p><p>14.3.5 分析Java层代码565</p><p>14.4 Audio系统的硬件抽象层567</p><p>14.4.1 Audio硬件抽象层基础568</p><p>14.4.2 AudioFlinger中的Audio硬件抽象层的实现569</p><p>14.4.3 真正实现Audio硬件抽象层575</p><p>14.5 Kernel Driver实现575</p><p>14.6 实现编／解码过程582</p><p>14.6.1 AMR编码583</p><p>14.6.2 AMR解码587</p><p>14.6.3 解码MP3591</p><p>第15章 视频系统架构详解594</p><p>15.1 视频输出系统594</p><p>15.1.1 基本层次结构594</p><p>15.1.2 硬件抽象层架构595</p><p>15.2 MediaPlayer架构详解602</p><p>15.2.1 MediaPlayer架构图解602</p><p>15.2.2 MediaPlayer的接口与架构603</p><p>15.2.3 分析Java部分610</p><p>15.2.4 分析JNI部分614</p><p>15.2.5 核心库libmedia.so618</p><p>15.2.6 服务库libmediaservice.so621</p><p>15.2.7 OpenCorePlayer实现libopencoreplayer.so622</p><p>15.2.8 对MediaPlayer的总结622</p><p>15.3 VideoView详解628</p><p>15.3.1 构造函数628</p><p>15.3.2 公共方法629</p><p>第16章 WebKit系统架构详解635</p><p>16.1 WebKit系统目录635</p><p>16.2 Java层的基本框架636</p><p>16.3 Java层的主要类637</p><p>16.3.1 WebView简介637</p><p>16.3.2 WebViewDatabase638</p><p>16.3.3 WebViewCore638</p><p>16.3.4 CallbackProxy638</p><p>16.3.5 BrowserFrame639</p><p>16.3.6 JWebCoreJavaBridge639</p><p>16.3.7 DownloadManagerCore639</p><p>16.3.8 其他类639</p><p>16.4 数据载入器架构639</p><p>16.5 Java层对应的C/C＋＋类库640</p><p>16.6 分析WebKit的操作过程642</p><p>16.6.1 WebKit初始化642</p><p>16.6.2 载入数据644</p><p>16.6.3 刷新绘制644</p><p>16.7 WebViewCore详解645</p><p>第17章 Android 5.0中的WebView652</p><p>17.1 WebView架构基础652</p><p>17.2 WebView类简介654</p><p>17.3 WebViewProvider接口656</p><p>17.4 WebViewChromium详解659</p><p>17.5 WebViewChromiumFactoryProvider详解660</p><p>17.6 AwContents架构663</p><p>17.7 实现Mixed Content模式666</p><p>17.8 引入第三方Cookie667</p><p>第18章 Wi-Fi系统架构详解670</p><p>18.1 Wi-Fi系统基础670</p><p>18.2 Wi-Fi本地部分架构672</p><p>18.3 Wi-Fi JNI部分架构676</p><p>18.4 Java FrameWork部分的源码677</p><p>18.4.1 WifiManager详解678</p><p>18.4.2 WifiService详解679</p><p>18.4.3 WifiWatchdogService详解688</p><p>18.5 Setting设置架构689</p><p></p></div></div><div class="d-rt"><h3>热门推荐</h3><ul><li><a href="/book/961034.html">961034.html</a></li><li><a href="/book/3463029.html">3463029.html</a></li><li><a href="/book/278024.html">278024.html</a></li><li><a href="/book/185327.html">185327.html</a></li><li><a href="/book/1057577.html">1057577.html</a></li><li><a href="/book/787490.html">787490.html</a></li><li><a href="/book/711533.html">711533.html</a></li><li><a href="/book/678433.html">678433.html</a></li><li><a href="/book/510973.html">510973.html</a></li><li><a href="/book/3613271.html">3613271.html</a></li></ul></div></div><div id="footer"><p>Copyright&nbsp;&copy;&nbsp;2025&nbsp;&nbsp;<a href="/list/">最新更新</a></p><p>请使用FDM BitComet qBittorrent uTorrent等BT下载工具，下载本站电子书资源！首推Free Download Manager下载软件。文件页数>标注页数[分册图书除外]</p></div></body></html>