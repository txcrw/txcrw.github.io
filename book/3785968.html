<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><script type="text/javascript" src="https://file.bkxsj.com/skin/book/js/sk.js"></script><meta name="robots" content="index,follow"><title>.NET 3.5与VB 2008高级编程 第3版[PDF|Epub|txt|kindle电子书版本网盘下载]-灵感之桥</title><meta name="Keywords" content=".NET 3.5与VB 2008高级编程 第3版"/><meta name="description" content=".NET 3.5与VB 2008高级编程 第3版pdf下载文件大小为237MB,PDF页数为1186页"/><meta http-equiv="X-UA-Compatible" content="IE=9; IE=8; IE=7; IE=EDGE;chrome=1"><link type="image/x-icon" rel="shortcut icon" href="https://www.shukui.net/skin/book/images/favicon.ico"><link type="text/css" rel="stylesheet" href="https://www.shukui.net/skin/book/css/style.css"><style>#main .d-main {margin-left: 0;width: 620px;}.down-btn {animation: myShake 2.5s linear .15s infinite}@keyframes myShake {0%, 66% {transform: translateZ(0)}67%, 73.6%, 83.6%, 93.6%, to {animation-timing-function: cubic-bezier(.215, .61, .355, 1);transform: translateZ(0)}80.3%, 81.4% {animation-timing-function: cubic-bezier(.755, .05, .855, .06);transform: translate3d(0, -4px, 0)}90.3% {animation-timing-function: cubic-bezier(.755, .05, .855, .06);transform: translate3d(0, -2px, 0)}97% {transform: translate3d(0, -.5px, 0)}}.copylink-btn {margin-right: 20px;}.copymd5-btn {margin-bottom: 25px;margin-left: 10px;}</style></head><body><div id="header"><div class="inner"><div class="logo"><a href="/"><img width="103" height="25" alt="灵感之桥"src="https://www.shukui.net/skin/book/images/logo.png"></a></div><div class="search"><form action="/so/search.php" target="_blank"><input type="text" autocomplete="off" id="bdcsMain" name="q" placeholder="书名 / 作者 / 出版社 / ISBN"class="inp-txt"><select class="inp-select" id="datasource" onchange="selectDatasource(this)"><option value="so">主库</option><option value="s">从库</option></select><input type="submit" value="搜索" class="inp-btn"></form></div></div></div><div id="main"><div class="d-main"><div class="tit"><h3>图书介绍</h3></div><h1 class="book-name">.NET 3.5与VB 2008高级编程 第3版PDF|Epub|txt|kindle电子书版本网盘下载</h1><div class="d-info"><div class="b-thumb"><img src="https://www.shukui.net/cover/33/34982423.jpg" alt=".NET 3.5与VB 2008高级编程 第3版"></div><div class="b-info"><ul><li>姜玲玲，唐明霞 著</li><li>出版社： 北京：清华大学出版社</li><li>ISBN：9787302208419</li><li>出版时间：2009</li><li>标注页数：1152页</li><li>文件大小：237MB</li><li>文件页数：1186页</li><li>主题词：BASIC语言－程序设计－教材</li></ul></div></div><div class="tit"><h3>PDF下载</h3></div><div></br><a style="color:red;" rel="external nofollow" href="https://www.kjlm.net/ebook/3785974.html"target="_blank"><b>点此进入-本书在线PDF格式电子书下载【推荐-云解压-方便快捷】直接下载PDF格式图书。移动端-PC端通用</a></b></br><a class="down-btn" rel="external nofollow" href="https://down.trackerbk.com/bt/10/34982423.torrent"target="_blank">种子下载</a>[BT下载速度快]温馨提示：（请使用BT下载软件FDM进行下载）<a rel="nofollow" href="https://www.freedownloadmanager.org/zh/" target="_blank">软件下载地址页</a><a class="down-btn" rel="external nofollow" href="https://down.p2spdb.com/10/34982423.rar" target="_blank">直链下载</a>[便捷但速度慢]&nbsp;&nbsp;<a style="color:red;" rel="external nofollow" href="https://pdfyl.ertongbook.com/87/34982423.pdf" target="_blank"><b>[在线试读本书]</b></a>&nbsp;&nbsp;<b> <a style="color:red;" rel="external nofollow" href="https://web.jyjl.org/index/recovery.html" target="_blank">[在线获取解压码]</a></b><div class="copymd5-btn"><a href="javascript:copyToClip('5a68c1c8fd47a0c2ba1e2435b631b0fd')">点击复制MD5值：5a68c1c8fd47a0c2ba1e2435b631b0fd</a></div></div><div class="tit"><h3>下载说明</h3></div><div style="margin:20px 10px"><h2>.NET 3.5与VB 2008高级编程 第3版PDF格式电子书版下载</h2>下载的文件为RAR压缩包。需要使用解压软件进行解压得到PDF格式图书。<br><br><div class="copymd5-btn"><a href="javascript:copyToClip('magnet:?xt=urn:btih:RX6G6JQ2LJW7PBBEDNUSCQM7ICDMHIWK')">点击复制85GB完整离线版磁力链接到迅雷FDM等BT下载工具进行下载</a>&nbsp;&nbsp;<a rel="nofollow" target="_blank">详情点击-查看共享计划</a></div>建议使用BT下载工具Free Download Manager进行下载,简称FDM(免费,没有广告,支持多平台）。本站资源全部打包为BT种子。所以需要使用专业的BT下载软件进行下载。如BitComet qBittorrent uTorrent等BT下载工具。迅雷目前由于本站不是热门资源。不推荐使用！后期资源热门了。安装了迅雷也可以迅雷进行下载！<br><br><b>（文件页数 要大于 标注页数，上中下等多册电子书除外）</b><br><br><p style="color:red;"> <b>注意：本站所有压缩包均有解压码：</b> <a rel="nofollow" target="_blank"><b>点击下载压缩包解压工具</b></a></p></div><div class="tit"><h3>图书目录</h3></div><div id="book-contents"><p>第Ⅰ部分　Visual Basic 2008与．NET平台第1章　.NET基本原理3</p><p>1.1 历史状态3</p><p>1.1.1 C/Win32 API程序员的生活3</p><p>1.1.2 C++/MFC程序员的生活4</p><p>1.1.3 Visual Basic 6.0程序员的生活4</p><p>1.1.4 Java/J2EE程序员的生活4</p><p>1.1.5 COM程序员的生活5</p><p>1.1.6 Windows DNA程序员的生活5</p><p>1.2　.NET解决方案6</p><p>1.3　.NET平台的构件块（CLR、CTS与CLS）6</p><p>1.4 Visual Basic 2008的新内容7</p><p>1.5　其他．NET支持语言8</p><p>1.6　.NET程序集概览10</p><p>1.6.1　单文件与多文件程序集11</p><p>1.6.2　公共中间语言的作用11</p><p>1.6.3　.NET类型元数据的作用14</p><p>1.6.4　程序集清单的作用15</p><p>1.7　公共类型系统15</p><p>1.7.1 CTS类类型16</p><p>1.7.2 CTS接口类型16</p><p>1.7.3 CTS结构类型16</p><p>1.7.4 CTS枚举类型17</p><p>1.7.5 CTS委托类型17</p><p>1.7.6 CTS类型成员17</p><p>1.7.7　固有CTS数据类型18</p><p>1.8　公共语言规范18</p><p>1.9 了解公共语言运行库20</p><p>1.10　程序集／名称空间／类型之间的区别21</p><p>1.10.1　通过编程访问名称空间24</p><p>1.10.2　引用外部程序集25</p><p>1.11 使用ildasm.exe25</p><p>1.11.1　查看CIL代码26</p><p>1.11.2　查看类型元数据26</p><p>1.11.3　查看程序集元数据（也称为清单）27</p><p>1.12　使用Lutz Roeder的reflector27</p><p>1.13　部署．NET运行库28</p><p>1.14　.NET的平台无关特性29</p><p>1.15　小结30</p><p>第2章　构建Visual Basic 2008应用程序31</p><p>2.1 .NET Framework 3.5 SDK的作用31</p><p>2.2 VB 2008命令行编译器（vbc.exe）32</p><p>2.3　使用vbc.exe构建VB 2008应用程序32</p><p>2.3.1　使用vbc.exe引用外部程序集34</p><p>2.3.2　使用vbc.exe编译多个源文件35</p><p>2.3.3　使用vbc.exe引用多个外部程序集36</p><p>2.4　使用vbc.exe响应文件36</p><p>2.5　使用SharpDevelop构建．NET应用程序38</p><p>2.6　使用Visual Basic 2008 Express构建．NET应用程序41</p><p>2.7　使用Visual Studio 2008构建．NET应用程序42</p><p>2.7.1 Visual Studio 2008的一些特有功能42</p><p>2.7.2　使用New Project对话框选择．NET Framework的版本43</p><p>2.7.3　使用Solution Explorer实用程序43</p><p>2.7.4 Class View实用程序45</p><p>2.7.5 Object Browser实用程序45</p><p>2.7.6 Visual Studio 2008代码片断技术45</p><p>2.7.7　可视化类设计器46</p><p>2.7.8 Object Test Bench49</p><p>2.7.9　综合帮助系统50</p><p>2.8 Visual Basic 6.0兼容性程序集的作用51</p><p>2.9　其他．NET开发工具的部分目录52</p><p>2.10 小结53</p><p>第Ⅱ部分　核心VB编程结构57</p><p>第3章　VB 2008编程结构（上）57</p><p>3.1 Module类型的作用57</p><p>3.1.1 带多个模块的项目58</p><p>3.1.2　模块是不能创建的59</p><p>3.1.3　重命名初始模块60</p><p>3.1.4　模块的成员60</p><p>3.2 Main方法的作用61</p><p>3.2.1　使用System.Environment处理命令行参数61</p><p>3.2.2　使用Main（）处理命令行参数62</p><p>3.2.3 Main（）作为函数（而不是作为子例程）62</p><p>3.2.4　使用Visual Studio 2008指定命令行参数63</p><p>3.3　一个有趣的附加作用：System.Environment类的一些其他成员63</p><p>3.4 System.Console类64</p><p>3.4.1　使用Console类的基本输入输出65</p><p>3.4.2　格式化控制台输出65</p><p>3.4.3　.NET字符串格式化标记66</p><p>3.4.4　使用String.Format（）格式化字符串67</p><p>3.5　系统数据类型与VB简洁表示法67</p><p>3.5.1　变量声明和初始化68</p><p>3.5.2　数据类型的默认值69</p><p>3.5.3　数据类型类层次结构70</p><p>3.5.4　固有数据类型和New关键字71</p><p>3.5.5　体验数值数据类型71</p><p>3.5.6 System.Boolean的成员72</p><p>3.5.7 System.Char的成员72</p><p>3.5.8　分析字符串数据中的值73</p><p>3.6 System.String类型73</p><p>3.6.1　基本字符串操作74</p><p>3.6.2　字符串连接（以及Newline常量）74</p><p>3.6.3　字符串和相等76</p><p>3.6.4　字符串是不能改变的76</p><p>3.6.5 System.Text.StringBuilder类型77</p><p>3.7　窄化（显式）或宽化（隐式）的数据类型转换78</p><p>3.7.1 Option Strict80</p><p>3.7.2　显式转换函数82</p><p>3.7.3 System.Convert的作用83</p><p>3.8　构建Visual Basic 2008代码语句83</p><p>3.8.1　语句延续字符83</p><p>3.8.2　在单行上定义多个语句84</p><p>3.9 VB 2008流程控制语句结构85</p><p>3.9.1 If/Then/Else语句85</p><p>3.9.2　构建复杂条件表达式86</p><p>3.9.3 Select/Case语句87</p><p>3.10 VB 2008迭代结构87</p><p>3.10.1 For/Next循环88</p><p>3.10.2 For/Each循环88</p><p>3.10.3 Do/While和Do/Until循环结构89</p><p>3.10.4 With结构90</p><p>3.11 小结90</p><p>第4章　VB 2008编程结构（下）91</p><p>4.1　定义子例程与函数91</p><p>4.1.1 ByVal参数修饰符92</p><p>4.1.2 ByRef参数修饰符93</p><p>4.1.3　定义可选参数94</p><p>4.1.4　使用ParamArrays95</p><p>4.1.5　方法调用约定96</p><p>4.1.6　包含静态局部变量的方法97</p><p>4.2　成员重载98</p><p>4.2.1 Overloads关键字99</p><p>4.2.2　方法重载的细节99</p><p>4.3 VB 2008中的数组操作100</p><p>4.3.1 VB 2008数组初始化语法101</p><p>4.3.2　定义Objects的数组101</p><p>4.3.3　定义数组的下边界102</p><p>4.3.4 Redim/Preserve语法103</p><p>4.3.5　使用多维数组104</p><p>4.3.6 System.Array类105</p><p>4.4 VB 2008的枚举106</p><p>4.4.1　控制枚举的底层存储107</p><p>4.4.2　声明和使用枚举107</p><p>4.4.3 System.Enum类型（以及解析关键字命名冲突的一个教训）108</p><p>4.4.4　动态地发现枚举的名／值对110</p><p>4.5 VB 2008结构类型111</p><p>4.6 小结113</p><p>第5章　设计封装类类型114</p><p>5.1 VB 2008类类型简介114</p><p>5.2　类构造函数117</p><p>5.2.1　默认构造函数的作用119</p><p>5.2.2　定义自定义构造函数119</p><p>5.2.3　再次介绍默认构造函数120</p><p>5.3 Me关键字的作用121</p><p>5.3.1　使用Me链接构造函数调用123</p><p>5.3.2　观察构造函数流程125</p><p>5.4 Shared关键字126</p><p>5.4.1 定义共享方法（和字段）126</p><p>5.4.2　定义共享数据128</p><p>5.4.3　定义共享构造函数130</p><p>5.5　定义OOP的支柱131</p><p>5.5.1　封装的作用132</p><p>5.5.2　继承的作用132</p><p>5.5.3　多态的作用133</p><p>5.6 Visual Basic 2008访问修饰符134</p><p>5.6.1　访问修饰符与嵌套类型135</p><p>5.6.2　默认访问修饰符135</p><p>5.6.3　访问修饰符与字段数据136</p><p>5.7　第一个支柱：VB 2008的封装服务136</p><p>5.7.1　使用传统的取值和赋值封装137</p><p>5.7.2　使用属性封装138</p><p>5.7.3　属性的内部表示140</p><p>5.7.4　控制属性可见性级别的Get/Set语句142</p><p>5.7.5　只读和只写属性142</p><p>5.7.6　共享属性142</p><p>5.8　常量数据143</p><p>5.9　只读字段145</p><p>5.10　局部类型定义146</p><p>5.11　通过XML文档化VB 2008源代码147</p><p>5.12　使我们的概念形象化151</p><p>5.13 小结151</p><p>第6章　继承与多态152</p><p>6.1　继承的基本机制152</p><p>6.1.1 Inherits关键字153</p><p>6.1.2　关于多个基类154</p><p>6.1.3 NotInheritable关键字155</p><p>6.2　修订Visual Studio 2008类图156</p><p>6.3　第二个支柱：继承的细节157</p><p>6.3.1　使用MyBase控制基类的创建159</p><p>6.3.2 Protected关键字160</p><p>6.3.3　添加密封类161</p><p>6.4　包容／委托模型的编程162</p><p>6.5　第三个支柱：VB 2008的多态支持165</p><p>6.5.1 Overridable和Overrides关键字166</p><p>6.5.2　用Visual Studio 2008进行重写167</p><p>6.5.3 NotOverridable关键字168</p><p>6.5.4　抽象类和MustInherit关键字169</p><p>6.5.5　用MustOverride构建一个多态接口170</p><p>6.5.6　成员屏蔽173</p><p>6.6　基类／派生类的类型强制转换规则174</p><p>6.7　终极父类：System.Object176</p><p>6.7.1　重写System.Object.ToString（）179</p><p>6.7.2　重写System.Object.Equals（）179</p><p>6.7.3　重写System.Object.GetHashCode（）180</p><p>6.7.4　测试修改后的Person类181</p><p>6.7.5 System.Object的共享成员181</p><p>6.8 小结182</p><p>第7章　结构化异常处理183</p><p>7.1　关于错误、bug和异常183</p><p>7.2　.NET异常处理的作用184</p><p>7.2.1　.NET异常处理的原子性184</p><p>7.2.2 System.Exception基类185</p><p>7.3　最简单的示例186</p><p>7.3.1　抛出一个简单的异常187</p><p>7.3.2　捕获异常188</p><p>7.4　配置异常的状态189</p><p>7.4.1 TargetSite属性189</p><p>7.4.2 StackTrace属性190</p><p>7.4.3 HelpLink属性190</p><p>7.4.4 Data属性191</p><p>7.5　系统级异常（System.SystemException）192</p><p>7.6　应用程序级异常（System.ApplicationException）193</p><p>7.6.1　构建自定义异常（Ⅰ）193</p><p>7.6.2　构建自定义异常（Ⅱ）195</p><p>7.6.3　构建自定义异常（Ⅲ）195</p><p>7.6.4　按Visual Studio方式构建自定义异常196</p><p>7.7　处理多个异常196</p><p>7.7.1　广义Catch语句198</p><p>7.7.2　重新抛出异常199</p><p>7.7.3 内部异常199</p><p>7.8 Finally块200</p><p>7.9　谁在抛出什么201</p><p>7.10　未处理异常的结果202</p><p>7.11 使用Visual Studio 2008调试未处理异常202</p><p>7.12　融合VB6错误处理与结构化异常处理203</p><p>7.13　小结204</p><p>第8章　对象生存期205</p><p>8.1　类、对象和引用205</p><p>8.2　对象生存期基础206</p><p>8.2.1 CIL的New关键字207</p><p>8.2.2　将对象引用设置成Nothing208</p><p>8.3　应用程序根的作用209</p><p>8.4　对象代210</p><p>8.5 System.GC类型210</p><p>8.6　构建可终结对象213</p><p>8.6.1　重写System.Object.Finalize（）214</p><p>8.6.2　详细介绍终结过程215</p><p>8.7　构建可诊断对象216</p><p>8.8　构建可终结和可诊断类型218</p><p>8.9　小结220</p><p>第Ⅲ部分　高级VB编程结构223</p><p>第9章　使用接口类型223</p><p>9.1　接口类型223</p><p>9.2　定义自定义接口225</p><p>9.3　实现接口226</p><p>9.3.1　更新Hexagon类227</p><p>9.3.2　支持多个接口的类型228</p><p>9.4　与支持接口的类型进行交互229</p><p>9.4.1　使用CType（）获取接口引用230</p><p>9.4.2　使用TypeOf/Is获取接口引用230</p><p>9.4.3　作为成员参数的接口231</p><p>9.4.4　作为返回值的接口233</p><p>9.4.5　接口类型的数组234</p><p>9.5　使用Implements关键字解决名称冲突问题234</p><p>9.5.1　通过Implements关键字定义通用实现方式236</p><p>9.5.2　使用Implements关键字对对象级别隐藏接口方法237</p><p>9.5.3　设计接口层次结构238</p><p>9.6　构建可枚举的类型（IEnumerable和IEnumerator）239</p><p>9.6.1　构建可以克隆的对象（ICloneable）241</p><p>9.6.2　一个更精细的克隆示例243</p><p>9.7　构建可比较的对象（IComparable）246</p><p>9.7.1　指定多种排序次序（IComparer）248</p><p>9.7.2 自定义属性与自定义排序类型249</p><p>9.8　使用接口作为回调机制250</p><p>9.9　小结253</p><p>第10章　集合、泛型和可为空值的数据类型254</p><p>10.1 System.Collections的非泛型类型254</p><p>10.1.1 System.Collections命名空间的接口255</p><p>10.1.2 IDictionaryEnumerator的作用256</p><p>10.1.3 IList的作用256</p><p>10.1.4 System.Collections的类类型257</p><p>10.2 System.Collections.Specialized名称空间260</p><p>10.3　包装与解除包装操作261</p><p>10.3.1　部分包装和解除包装实例262</p><p>10.3.2　解除自定义值类型的包装263</p><p>10.3.3　包装和解除包装操作的问题264</p><p>10.4　类型安全性和强类型的集合264</p><p>10.5 System.Collections.Generic名称空间269</p><p>10.6　可为空值的数据类型和System.Nullable（Of T）泛型类型272</p><p>10.6.1　使用可为空值的类型273</p><p>10.6.2 Visual Basic 2008可为空值的运算符（？）274</p><p>10.7　创建泛型方法275</p><p>10.8　创建泛型结构（或类）277</p><p>10.9　创建自定义泛型集合279</p><p>10.9.1 自定义泛型集合类的用处280</p><p>10.9.2　约束类型参数282</p><p>10.9.3　缺少运算符约束283</p><p>10.10　创建泛型接口284</p><p>10.11　创建泛型委托285</p><p>10.12　小结287</p><p>第11章　委托、事件和Lambdas288</p><p>11.1 了解．NET委托类型288</p><p>11.1.1　在VB 2008中定义委托类型289</p><p>11.1.2　研究自动生成的类类型290</p><p>11.1.3 System.MulticastDelegate和System.Delegate基类291</p><p>11.2　可能最简单的委托示例292</p><p>11.3　使用委托更新Car类型294</p><p>11.3.1　激活多播297</p><p>11.3.2　从委托的调用列表中删除目标298</p><p>11.4 了解（和使用）事件299</p><p>11.4.1　使用RaiseEvent关键字激活事件299</p><p>11.4.2　事件的本质300</p><p>11.4.3　使用WithEvents和Handles关联引入的事件301</p><p>11.4.4　使用Handles关键字多播302</p><p>11.4.5　为多个事件定义单个处理程序302</p><p>11.4.6 使用AddHandler/RemoveHandler动态关联引入的事件303</p><p>11.5　定义“规规矩矩的”事件304</p><p>11.6　定义强类型事件306</p><p>11.7　定制事件注册过程307</p><p>11.7.1　定义自定义事件307</p><p>11.7.2　使用自定义委托来自定义事件309</p><p>11.8 Visual Basic Lambda表达式310</p><p>11.8.1　分解Lambda表达式312</p><p>11.8.2　使用多个参数的Lambda表达式313</p><p>11.8.3　使用自定义方法赋值Lambda参数314</p><p>11.8.4　使用Zero参数的Lambda表达式315</p><p>11.9　小结315</p><p>第12章　运算符重载和自定义转换程序316</p><p>12.1　运算符重载316</p><p>12.1.1　运算符重载的情况317</p><p>12.1.2　重载二元运算符319</p><p>12.1.3　重载相等运算符320</p><p>12.1.4　重载比较运算符320</p><p>12.1.5　关于运算符重载的最后思考321</p><p>12.2　值类型和引用类型的详细情况322</p><p>12.2.1　值类型、引用类型和赋值运算符323</p><p>12.2.2　包含引用类型的值类型325</p><p>12.2.3　按值传递引用类型326</p><p>12.2.4　按引用传递引用类型327</p><p>12.2.5　值和引用类型：最后的细节328</p><p>12.2.6　回顾：数值转换329</p><p>12.2.7　回顾：相关类类型之间的转换329</p><p>12.3　创建自定义转换程序330</p><p>12.4　定义隐式转换程序332</p><p>12.5 VB DirectCast关键字334</p><p>12.6　小结336</p><p>第13章　VB 2008特有的语言特性337</p><p>13.1 了解隐式数据类型化337</p><p>13.1.1　迭代结构中的隐式类型化339</p><p>13.1.2　隐式类型数据是强类型数据340</p><p>13.1.3　禁用Option Infer340</p><p>13.1.4　后期绑定与隐式类型化341</p><p>13.1.5　隐式类型变量的限制343</p><p>13.1.6　隐式类型局部变量的有用性343</p><p>13.2　了解扩展方法344</p><p>13.2.1　定义扩展方法344</p><p>13.2.2　重载扩展方法345</p><p>13.2.3　在实例级别上调用扩展方法346</p><p>13.2.4　调用定义模块上的扩展方法346</p><p>13.2.5　扩展方法的作用域347</p><p>13.2.6　导入定义扩展方法的类型348</p><p>13.2.7　使用Visual Studio 2008标识扩展方法349</p><p>13.2.8　构建和使用扩展库349</p><p>13.2.9　通过扩展方法扩展接口类型350</p><p>13.3　对象初始化器语法351</p><p>13.3.1　使用初始化语法调用自定义构造函数353</p><p>13.3.2　初始化包含的类型354</p><p>13.4　匿名类型355</p><p>13.4.1　匿名类型的内部表示356</p><p>13.4.2 ToString（）和GetHashCode（）的实现方式357</p><p>13.4.3　匿名类型相等性的语义357</p><p>13.4.4　包含匿名类型的匿名类型359</p><p>13.5　小结359</p><p>第14章　LINQ概述360</p><p>14.1 了解LINQ的作用360</p><p>14.1.1 LINQ表达式是强类型且可扩展361</p><p>14.1.2　核心LINQ程序集361</p><p>14.2 LINQ查询表达式概述362</p><p>14.2.1 LINQ和隐式类型局部变量364</p><p>14.2.2 LINQ和扩展方法365</p><p>14.2.3　延期执行的作用365</p><p>14.2.4　立即执行的作用366</p><p>14.3 LINQ和泛型集合367</p><p>14.4 LINQ和非泛型集合368</p><p>14.5 LINQ查询运算符的内部表示370</p><p>14.5.1　使用查询运算符构建查询表达式（重访）371</p><p>14.5.2　使用Enumerable类型和Lambda构建查询表达式371</p><p>14.5.3　使用Enumerable类型和原始委托构建查询表达式372</p><p>14.6 VB LINQ查询运算符373</p><p>14.6.1　使用Enumerable计数374</p><p>14.6.2　构建新的测试项目374</p><p>14.7 LINQ查询：本身是孤岛吗379</p><p>14.8　小结381</p><p>第Ⅳ部分　使用．NET程序集编程385</p><p>第15章　.NET程序集概述385</p><p>15.1　.NET程序集的作用385</p><p>15.1.1　程序集提示代码重用385</p><p>15.1.2　程序集建立类型边界386</p><p>15.1.3　程序集是可版本化单元386</p><p>15.1.4　程序集是自描述对象386</p><p>15.1.5　程序集是可配置对象386</p><p>15.2　了解．NET程序集的格式387</p><p>15.2.1 Win32文件头387</p><p>15.2.2 CLR文件头387</p><p>15.2.3 CIL代码、类型元数据和程序集清单388</p><p>15.2.4　可选的程序集资源389</p><p>15.2.5　单文件和多文件的程序集389</p><p>15.3　构造自定义的．NET名称空间390</p><p>15.3.1　观察根名称空间391</p><p>15.3.2　定义根名称空间以外的名称空间392</p><p>15.3.3 导入自定义的名称空间393</p><p>15.3.4　使用Imports关键字构建类型别名393</p><p>15.4　构建和使用单文件程序集395</p><p>15.4.1　清单397</p><p>15.4 2 CIL398</p><p>15.4.3　类型元数据399</p><p>15.4.4　构建VB 2008客户端应用程序400</p><p>15.4.5　构建C＃客户端应用程序401</p><p>15.4.6　使用跨语言继承402</p><p>15.5　构建和使用多文件程序集403</p><p>15.5.1 ufo.netmodule文件404</p><p>15.5.2 airvehicles.dll文件404</p><p>15.5.3　使用多文件程序集405</p><p>15.6　私有程序集406</p><p>15.6.1　私有程序集的身份406</p><p>15.6.2　探查过程406</p><p>15.6.3　配置私有程序集407</p><p>15.6.4　配置文件和Visual Studio 2008409</p><p>15.6.5　.NET Framework配置实用程序409</p><p>15.7　共享程序集411</p><p>15.7.1　强名411</p><p>15.7.2　使用sn.exe强命名CarLibrary.dll413</p><p>15.7.3　使用Visual Studio 2008分配强名414</p><p>15.7.4　在GAC中安装／删除共享程序集414</p><p>15.8　使用共享程序集415</p><p>15.9　配置共享程序集416</p><p>15.9.1　冻结当前的共享程序集417</p><p>15.9.2　构建共享程序集版本2.0.0.0417</p><p>15.9.3　动态重定向到共享程序集的特定版本418</p><p>15.9.4　回顾．NET Framework配置实用程序419</p><p>15.10　发布者策略程序集420</p><p>15.11　〈codeBase〉元素421</p><p>15.12 System.Configuration名称空间423</p><p>15.13 小结424</p><p>第16章　类型反射、后期绑定和基于属性的编程425</p><p>16.1　类型元数据的必要性425</p><p>16.1.1　查看EngineState枚举的（部分）元数据426</p><p>16.1.2　查看Car类型的（部分）元数据426</p><p>16.1.3 TypeRef427</p><p>16.1.4　归档定义的程序集428</p><p>16.1.5　归档引用的程序集428</p><p>16.1.6　归档字符串文字428</p><p>16.2　反射429</p><p>16.2.1 System.Type类430</p><p>16.2.2　使用System.Object.GetType（）获得类型引用430</p><p>16.2.3　使用System.Type.GetType（）获得类型引用431</p><p>16.2.4　使用GetType（）获得类型引用431</p><p>16.3　构建自定义的元数据查看程序432</p><p>16.3.1　方法的反射432</p><p>16.3.2　字段和属性的反射432</p><p>16.3.3 已实现接口的反射433</p><p>16.3.4　显示各种零碎的内容433</p><p>16.3.5　实现Main（）方法433</p><p>16.3.6　方法参数和返回值的反射434</p><p>16.4　动态加载程序集435</p><p>16.5　共享程序集的反射437</p><p>16.6　后期绑定439</p><p>16.6.1　使用System.Activator类执行后期绑定439</p><p>16.6.2　调用无参数的方法440</p><p>16.6.3　调用带有参数的方法440</p><p>16.7　属性编程441</p><p>16.7.1　属性使用程序441</p><p>16.7.2　在VB 2008中应用预先定义的属性442</p><p>16.7.3　指定属性的构造函数参数443</p><p>16.7.4　实际应用的〈Obsolete（）〉属性444</p><p>16.7.5 VB 2008属性简写符号444</p><p>16.8　构建自定义的属性445</p><p>16.8.1　应用自定义属性445</p><p>16.8.2　限制属性使用446</p><p>16.9　程序集级（和模块级）的属性447</p><p>16.10　使用早期绑定反射属性448</p><p>16.11　使用后期绑定反射属性449</p><p>16.12　综合介绍反射、后期绑定和自定义属性450</p><p>16.13　构建可扩展的应用程序451</p><p>16.13.1　构建Common SnappableTypes.dll451</p><p>16.13.2　构建VB 2008管理单元452</p><p>16.13.3　构建C＃管理单元453</p><p>16.13.4　构建可扩展的Windows Forms应用程序453</p><p>16.14　小结455</p><p>第17章　进程、AppDomain和对象上下文456</p><p>17.1 回顾传统的Win32进程456</p><p>17.1.1　线程概览457</p><p>17.1.2　在．NET平台下与进程交互458</p><p>17.1.3　列举运行的进程459</p><p>17.1.4　研究特定的进程460</p><p>17.1.5　研究进程的线程集460</p><p>17.1.6　研究进程的模块集462</p><p>17.1.7　以编程方式启动和停止进程462</p><p>17.2　.NET应用程序域463</p><p>17.2.1　列举进程的AppDomain464</p><p>17.2.2　以编程方式创建新的AppDomain465</p><p>17.2.3 以编程方式卸载AppDomain467</p><p>17.3　对象上下文边界468</p><p>17.3.1　上下文敏捷和上下文绑定类型468</p><p>17.3.2v定义上下文绑定对象469</p><p>17.3.3　检查对象的上下文469</p><p>17.4　总结进程、应用程序域和上下文471</p><p>17.5　小结471</p><p>第18章　构建多线程应用程序472</p><p>18.1 进程／应用程序域／上下文／线程之间的关系472</p><p>18.2　简要回顾．NET委托474</p><p>18.3　委托的异步特性476</p><p>18.3.1 BeginInvoke（）和EndInvoke（）方法476</p><p>18.3.2 System.IAsyncResult接口476</p><p>18.4　异步调用方法477</p><p>18.4.1　同步调用线程477</p><p>18.4.2 AsyncCallback委托的作用479</p><p>18.4.3 AsyncResult类的作用480</p><p>18.4.4　传递和接收自定义的状态数据480</p><p>18.5 System.Threading名称空间481</p><p>18.6 System.Threading.Thread类482</p><p>18.6.1　获得当前线程的统计483</p><p>18.6.2 Name属性483</p><p>18.6.3 Priority属性484</p><p>18.7 以编程方式创建辅助线程484</p><p>18.7.1　使用ThreadStart委托485</p><p>18.7.2　创建线程：速记符号486</p><p>18.7.3　使用ParameterizedThreadStart委托487</p><p>18.7.4　前台线程和后台线程488</p><p>18.8　并发性问题489</p><p>18.8.1　使用SyncLock关键字同步491</p><p>18.8.2　使用System.Threading.Monitor类型同步化492</p><p>18.8.3　使用System.Threading.Interlocked类型同步493</p><p>18.8.4　使用〈Synchronization（）〉属性同步494</p><p>18.9　使用TimerCallback编程495</p><p>18.10 CLR线程池496</p><p>18.11 BackgroundWorker组件的作用497</p><p>18.11.1　使用BackgroundWorker类型498</p><p>18.11.2　使用BackgroundWorker类型处理数据499</p><p>18.12　小结500</p><p>第19章　.NET互操作性程序集501</p><p>19.1　.NET互操作性的作用域501</p><p>19.2　.NET到COM互操作性的简单示例502</p><p>19.3　.NET互操作程序集504</p><p>19.4　运行库可调用封装程序506</p><p>19.4.1 RCW：将COM类型转换为．NET类型507</p><p>19.4.2 RCW：管理COM类（coclass）的引用计数507</p><p>19.4.3 RCW：隐藏低级的COM接口508</p><p>19.5 COM IDL的作用508</p><p>19.5.1 观察为VB COM服务器生成的IDL510</p><p>19.5.2 IDL属性510</p><p>19.5.3 IDL库语句511</p><p>19.5.4　［default］接口的作用511</p><p>19.5.5 IDispatch的作用511</p><p>19.5.6 IDL形参属性512</p><p>19.5.7　使用类型库构建互操作程序集512</p><p>19.6　后期绑定CoCalc COM类513</p><p>19.7　构建更有趣的VB6 COM服务器514</p><p>19.7.1　支持额外的COM接口515</p><p>19.7.2　提供内部对象516</p><p>19.8　互操作程序集517</p><p>19.8.1　构建VB 2008客户端应用程序518</p><p>19.8.2　与CoCar类型交互518</p><p>19.8.3　截获COM事件520</p><p>19.9 COM到．NET互操作性521</p><p>19.10 CCW的作用522</p><p>19.11　.NET类接口的作用522</p><p>19.12　构建．NET类型523</p><p>19.12.1　使用Visual Studio 2008插入COM类524</p><p>19.12.2　定义强名526</p><p>19.13　生成类型库并注册．NET类型526</p><p>19.14　导出的类型信息527</p><p>19.15　构建VB6测试客户端528</p><p>19.16　小结528</p><p>第Ⅴ部分 .NET基类库531</p><p>第20章　文件和目录操作531</p><p>20.1 System.IO名称空间531</p><p>20.2 Directory（Info）和File（Info）类型532</p><p>20.3　使用DirectoryInfo类型533</p><p>20.3.1　使用DirectoryInfo类型列举文件534</p><p>20.3.2　使用DirectoryInfo类型创建子目录535</p><p>20.4　使用Directory类型536</p><p>20.5　使用DriveInfo类类型537</p><p>20.6　使用FileInfo类537</p><p>20.6.1 FileInfo.Create（）方法538</p><p>20.6.2 FileInfo.Open（）方法539</p><p>20.6.3 FileInfo.OpenRead（）和FileInfo.OpenWrite（）方法540</p><p>20.6.4 FileInfo.OpenText（）方法540</p><p>20.6.5 FileInfo.CreateText（）和FileInfo.AppendText（）方法541</p><p>20.7　使用File类型541</p><p>20.8　抽象的Stream类543</p><p>20.9　使用StreamWriter和StreamReader545</p><p>20.9.1　写入文本文件546</p><p>20.9.2　从文本文件读取546</p><p>20.9.3　直接创建StreamWriter/StreamReader对象547</p><p>20.10　使用StringWriter和StringReader548</p><p>20.11　使用BinaryWriter和BinaryReader549</p><p>20.12　以编程方式“监视”文件551</p><p>20.13　执行异步文件I/O552</p><p>20.14　小结554</p><p>第21章　对象串行化555</p><p>21.1 了解对象串行化555</p><p>21.2　配置用于串行化的对象557</p><p>21.3　选择串行化格式器558</p><p>21.3.1 IFormatter和IRemotingFormatting接口559</p><p>21.3.2　格式器之间的类型精确度560</p><p>21.4　使用BinaryFormatter串行化对象560</p><p>21.5　使用SoapFormatter串行化对象562</p><p>21.6　使用XmlSerializer串行化对象563</p><p>21.7　持久保存对象集合565</p><p>21.8 自定义串行化过程567</p><p>21.8.1　深入研究对象串行化567</p><p>21.8.2　使用ISerializable自定义串行化568</p><p>21.8.3　使用属性自定义串行化570</p><p>21.9　小结572</p><p>第22章　ADO.NET第1部分：连接层573</p><p>22.1 ADO.NET的高级定义573</p><p>22.2 ADO.NET数据提供者574</p><p>22.2.1 Microsoft提供的ADO.NET数据提供者576</p><p>22.2.2　获得第三方的ADO.NET数据提供者577</p><p>22.3　额外的ADO.NET名称空间577</p><p>22.4 System.Data名称空间的类型578</p><p>22.4.1 IDbConnection接口的作用579</p><p>22.4.2 IDbTransaction接口的作用579</p><p>22.4.3 IDbCommand接口的作用579</p><p>22.4.4 IDbDataParameter和IDataParameter接口的作用580</p><p>22.4.5 IDbDataAdapter和IDataAdapter接口的作用580</p><p>22.4.6 IDataReader和IDataRecord接口的作用581</p><p>22.5　使用接口抽象化数据提供者582</p><p>22.6　创建AutoLot数据库585</p><p>22.6.1　创建Inventory表585</p><p>22.6.2　创建GetPetName（）存储过程586</p><p>22.6.3　创建Customers和Orders表587</p><p>22.6.4　可视化创建表关系587</p><p>22.7 ADO.NET数据提供者工厂模型588</p><p>22.7.1 已注册的数据提供者工厂589</p><p>22.7.2　完整的数据提供者工厂模型示例590</p><p>22.7.3　〈connectionStrings〉元素592</p><p>22.8 ADO.NET的连接层593</p><p>22.8.1　使用连接对象594</p><p>22.8.2　使用ConnectionStringBuilder对象596</p><p>22.8.3　使用命令对象597</p><p>22.9　使用数据读取器598</p><p>22.10　构建可重用的数据访问库600</p><p>22.10.1　添加连接逻辑601</p><p>22.10.2　添加插入逻辑602</p><p>22.10.3　添加删除逻辑602</p><p>22.10.4　添加更新逻辑603</p><p>22.10.5　添加选择逻辑603</p><p>22.10.6　使用参数化的命令对象603</p><p>22.10.7　使用DbCommand执行存储过程605</p><p>22.11　创建基于控制台UI的前端607</p><p>22.11.1　实现Main（）方法607</p><p>22.11.2　实现ShowInstructions（）和ClearConsole（）方法609</p><p>22.11.3　实现ListInventory（）方法609</p><p>22.11.4　实现DeleteCar（）方法610</p><p>22.11.5　实现InsertNewCar（）方法610</p><p>22.11.6　实现UpdateCarPetName（）方法610</p><p>22.11.7　调用存储过程611</p><p>22.12　使用SqlCommand执行异步数据访问611</p><p>22.13　数据库事务613</p><p>22.13.1 ADo.NET事务对象的关键成员614</p><p>22.13.2　向InventoryDAL添加事务方法614</p><p>22.13.3　测试数据库事务616</p><p>22.14　小结617</p><p>第23章　ADO.NET第2部分：断开连接层618</p><p>23.1 ADO.NET的断开连接层618</p><p>23.2 DataSet的作用619</p><p>23.2.1 DataSet的关键属性619</p><p>23.2.2 DataSet的关键方法620</p><p>23.2.3　构建DataSet620</p><p>23.3 使用DataColumn621</p><p>23.3.1　构建DataColumn622</p><p>23.3.2　启用自动递增字段622</p><p>23.3.3 向DataTable添加DataColumn623</p><p>23.4　使用DataRow623</p><p>23.4.1 RowState属性625</p><p>23.4.2 DataRowVersion属性626</p><p>23.5　使用DataTable627</p><p>23.5.1　在DataSet中插入DataTable627</p><p>23.5.2　使用DataTableReader对象处理DataTable数据628</p><p>23.5.3　将DataTable/DataSet对象串行化为XML629</p><p>23.5.4　以二进制格式串行化DataTable/DataSet对象630</p><p>23.6　将DataTable对象绑定到用户界面631</p><p>23.6.1　通过泛型List（Of T）填充DataTable632</p><p>23.6.2　以编程方式删除行634</p><p>23.6.3　基于筛选标准选择行635</p><p>23.6.4　更新行637</p><p>23.6.5　使用DataView类型638</p><p>23.6.6　最后的UI增强：呈现行号639</p><p>23.7　使用数据适配器填充DataSet/DataTable对象640</p><p>23.7.1　简单的数据适配器示例640</p><p>23.7.2　将数据库名映射为友好名称641</p><p>23.8　重新访问AutoLotDAL.dll642</p><p>23.8.1 定义初始的类类型642</p><p>23.8.2　使用SqlCommandBuilder配置数据适配器643</p><p>23.8.3　实现GetAllInventory（）644</p><p>23.8.4　实现UpdateInventory（）644</p><p>23.8.5　构建Windows Forms前端644</p><p>23.9　定位多表的DataSet对象646</p><p>23.9.1　准备数据适配器646</p><p>23.9.2　构建表关系648</p><p>23.9.3　更新数据库表648</p><p>23.9.4　在相关表之间定位648</p><p>23.10 Visual Studio 2008的数据访问工具651</p><p>23.10.1　可视化设计DataGridView651</p><p>23.10.2 app.config文件和Settings.Settings文件653</p><p>23.10.3　研究生成的DataSet654</p><p>23.10.4　研究生成的DataTable和DataRow656</p><p>23.10.5　研究生成的数据适配器656</p><p>23.10.6　在代码中使用生成的类型657</p><p>23.11　从UI层分离自动生成的代码659</p><p>23.12 小结661</p><p>第24章　使用LINQAPI编程662</p><p>24.1 LINQ to ADO.NET的作用662</p><p>24.2　使用LINQ to DataSet编程663</p><p>24.2.1 DataSet扩展的作用664</p><p>24.2.2　获得LINQ兼容的DataTable664</p><p>24.2.3 EnumerableRowCollection的隐式接口666</p><p>24.2.4 DataRowExtensions.Field（Of T）（）扩展方法的作用666</p><p>24.2.5　通过LINQ查询填充新的DataTable667</p><p>24.3　使用LINQ to SQL编程668</p><p>24.3.1　实体类的作用668</p><p>24.3.2 DataContext类型的作用668</p><p>24.3.3　简单的LINQ to SQL示例669</p><p>24.3.4　构建强类型的DataContext670</p><p>24.3.5　详细介绍〈Table（）〉和〈Column（）〉属性671</p><p>24.4　使用sqlmetal.exe生成实体类672</p><p>24.4.1　研究生成的实体类673</p><p>24.4.2　使用实体类定义关系674</p><p>24.4.3　强类型的DataContext675</p><p>24.4.4　针对生成的类型编程676</p><p>24.5　使用Visual Studio 2008构建实体类677</p><p>24.5.1　插入新项678</p><p>24.5.2　更新已有的项679</p><p>24.5.3　删除已有的项679</p><p>24.6　使用LINQ to XML编程680</p><p>24.6.1　作为更好的DOM的LINQ to XML680</p><p>24.6.2 System.Xml.XLinq名称空间680</p><p>24.7 Visual Basic 2008的集成XML支持681</p><p>24.7.1　在String数据类型中存储XML字面值682</p><p>24.7.2　在XML字面值中混合编程构造682</p><p>24.8 以编程方式创建XML元素683</p><p>24.9　以编程方式创建XML文档684</p><p>24.10　通过LINQ查询生成文档686</p><p>24.11　加载和解析XML内容687</p><p>24.12　定位内存中的XML文档688</p><p>24.12.1　修改XML文档中的数据689</p><p>24.12.2 XML轴属性的作用690</p><p>24.13　小结692</p><p>第25章　Windows通信基础693</p><p>25.1　综合介绍分布式计算API693</p><p>25.1.1 DCOM的作用694</p><p>25.1.2 COM+/Enterprise Service的作用694</p><p>25.1.3 MSMQ的作用695</p><p>25.1.4　.NET Remoting的作用695</p><p>25.1.5 XML Web服务的作用696</p><p>25.1.6　命名管道、套接字和P2P698</p><p>25.2 WCF的作用699</p><p>25.2.1 WCF特性概述699</p><p>25.2.2　面向服务体系结构概述700</p><p>25.2.3 WCF概要700</p><p>25.3　研究核心WCF程序集701</p><p>25.4 Visual Studio WCF项目模板702</p><p>25.5 WCF应用程序的基本组成部分703</p><p>25.6 WCF的ABC704</p><p>25.6.1　理解WCF契约705</p><p>25.6.2　理解WCF绑定705</p><p>25.6.3　理解WCF地址708</p><p>25.7　构建WCF服务709</p><p>25.7.1　〈ServiceContract（）〉属性710</p><p>25.7.2　〈OperationContract（）〉属性711</p><p>25.7.3　作为可操作契约的服务类型711</p><p>25.8　驻留WCF服务712</p><p>25.8.1　在App.config文件中建立ABC712</p><p>25.8.2　针对ServiceHost类型编码713</p><p>25.8.3　主机编码选项714</p><p>25.8.4 ServiceHost类型的细节715</p><p>25.8.5　〈system.serviceModel〉元素的细节716</p><p>25.8.6　启用元数据交换717</p><p>25.9　构建WCF客户应用程序719</p><p>25.9.1　使用svcutil.exe生成代理代码719</p><p>25.9.2　使用Visual Studio 2008生成代理代码720</p><p>25.10　使用WCF Service Library项目模板721</p><p>25.10.1　构建简单的数学服务721</p><p>25.10.2　使用WcfTestClient.exe测试WCF服务722</p><p>25.10.3　使用SvcConfigEditor.exe修改配置文件722</p><p>25.11　作为Windows服务驻留WCF服务723</p><p>25.11.1　在代码中指定ABC724</p><p>25.11.2　启用MEX725</p><p>25.11.3　创建Windows服务安装程序726</p><p>25.11.4　安装Windows服务726</p><p>25.12　异步调用服务727</p><p>25.13　设计WCF数据契约729</p><p>25.13.1　使用以Web为中心的WCF Service项目模板729</p><p>25.13.2　实现服务契约731</p><p>25.13.3　＊.svc文件的作用732</p><p>25.13.4　更新web.config文件732</p><p>25.13.5　测试服务733</p><p>25.14　小结734</p><p>第26章　Windows工作流基础735</p><p>26.1　定义业务过程735</p><p>26.2 WF的构件736</p><p>26.2.1 WF运行时引擎737</p><p>26.2.2 WF的核心服务737</p><p>26.2.3 WF活动简介738</p><p>26.2.4　顺序和状态机工作流739</p><p>26.3 WF的程序集、名称空间和项目741</p><p>26.3.1　.NET 3.5 WF支持741</p><p>26.3.2 Visual Studio工作流项目模板741</p><p>26.3.3　深入了解工作流的流程742</p><p>26.4　构建允许工作流的简单应用程序742</p><p>26.4.1　研究初始的工作流代码743</p><p>26.4.2　添加Code活动743</p><p>26.4.3　添加While活动744</p><p>26.5　研究WF引擎宿主代码746</p><p>26.6　在工作流中调用Web服务749</p><p>26.6.1　创建MathWebService750</p><p>26.6.2　构建WF Web服务使用者751</p><p>26.6.3　配置IfElse活动753</p><p>26.6.4　配置InvokeWebService活动755</p><p>26.6.5　与WCF服务通信757</p><p>26.7　构建可重用的WF代码库760</p><p>26.7.1　执行信用检查761</p><p>26.7.2　创建Windows Forms客户应用程序763</p><p>26.8 自定义活动概述765</p><p>26.9　小结766</p><p>第Ⅵ部分　使用Windows Forms创建桌面应用程序第27章　Windows Forms769</p><p>27.1 System.Windows.Forms名称空间概述769</p><p>27.2　使用Windows Forms类型771</p><p>27.2.1　手动创建主窗口771</p><p>27.2.2　遵守关注点分离772</p><p>27.3 Application类的功能773</p><p>27.3.1　使用Application类773</p><p>27.3.2 System.EventHandler委托774</p><p>27.4　窗体分析775</p><p>27.5 Control类的功能776</p><p>27.5.1　使用Control类778</p><p>27.5.2　响应MouseMove事件779</p><p>27.5.3　确定单击的鼠标键780</p><p>27.5.4　响应键盘事件780</p><p>27.6 Form类的功能781</p><p>27.7 用Visual Studio 2008构建Windows应用程序784</p><p>27.7.1　剖析Visual Studio 2008的Windows Forms项目785</p><p>27.7.2　在设计时实现事件787</p><p>27.7.3 StartUp Object/Main（） Sub区别788</p><p>27.8　使用MenuStrip和ContextMenuStrip789</p><p>27.8.1　给MenuStrip添加文本框790</p><p>27.8.2　创建上下文菜单791</p><p>27.8.3　选中菜单项793</p><p>27.9　使用StatusStrip795</p><p>27.9.1　设计菜单系统796</p><p>27.9.2　设计StatusStrip797</p><p>27.9.3　使用Timer类型798</p><p>27.9.4　触发显示799</p><p>27.9.5　显示菜单选择提示800</p><p>27.9.6　构建“就绪”状态800</p><p>27.10　使用ToolStrip801</p><p>27.11　构建MDI应用程序804</p><p>27.11.1　构建父窗体805</p><p>27.11.2　构建子窗体806</p><p>27.11.3　产生子窗口806</p><p>27.12　小结807</p><p>第28　章使用GDI＋呈现图形数据808</p><p>28.1 GDI＋名称空间概述808</p><p>28.2 System.Drawing名称空间概述809</p><p>28.3 System.Drawing的实用程序类型810</p><p>28.3.1 Point和PointF类型810</p><p>28.3.2 Rectangle和RectangleF类型811</p><p>28.3.3 Region、Size和SizeF类811</p><p>28.4　理解Graphics类812</p><p>28.5　理解Paint会话813</p><p>28.5.1　使窗体的客户区失效814</p><p>28.5.2　在Paint事件处理程序之外获取Graphics对象815</p><p>28.5.3　关于Graphics对象的处理816</p><p>28.6 GDI＋坐标系统817</p><p>28.6.1　默认的量度单位818</p><p>28.6.2　指定替代的量度单位818</p><p>28.6.3　指定替代的圆点819</p><p>28.7　定义颜色值821</p><p>28.8　操作字体822</p><p>28.8.1　使用字体家族823</p><p>28.8.2　使用字体和字体大小824</p><p>28.8.3　列举安装的字体826</p><p>28.8.4 FontDialog类828</p><p>28.9 System.Drawing.Drawing2D名称空间概述829</p><p>28.10　使用Pen829</p><p>28.11 使用Brush833</p><p>28.11.1　使用HatchBrush834</p><p>28.11.2　使用TextureBrush835</p><p>28.11.3　使用LinearGradientBrush836</p><p>28.12　呈现图像837</p><p>28.13 PictureBox控件的拖动和命中测试839</p><p>28.13.1　呈现图像的命中测试841</p><p>28.13.2　非矩形图像的命中测试843</p><p>28.14　理解Windows Forms资源格式845</p><p>28.14.1 System.Resources名称空间846</p><p>28.14.2　以编程的方式创建＊.resx文件846</p><p>28.14.3　构建＊.resources文件847</p><p>28.14.4　将＊.resources文件绑定到．NET程序集中848</p><p>28.14.5　使用ResourceWriters848</p><p>28.14.6　使用Visual Studio 2008生成资源849</p><p>28.14.7　以编程的方式读取资源850</p><p>28.15 小结851</p><p>第29章　使用Windows Forms控件编程852</p><p>29.1 Windows Forms控件概述852</p><p>29.2　手动给窗体添加控件852</p><p>29.3 使用Visual Studio 2008添加控件到窗体855</p><p>29.4　使用基础控件856</p><p>29.4.1　使用Label856</p><p>29.4.2 使用TextBox857</p><p>29.4.3　使用MaskedTextBox859</p><p>29.4.4　使用Button860</p><p>29.4.5　使用CheckBox、RadioButton和GroupBox862</p><p>29.4.6　使用CheckedListBox865</p><p>29.4.7　使用ListBox866</p><p>29.4.8　使用ComboBox867</p><p>29.5　配置制表符顺序868</p><p>29.6　设置窗体的默认输入按钮869</p><p>29.7　使用较为特殊的控件869</p><p>29.7.1　使用MonthCalendar869</p><p>29.7.2　使用ToolTip871</p><p>29.7.3　使用TabControl872</p><p>29.7.4　使用TrackBar873</p><p>29.7.5　使用Panel875</p><p>29.7.6　使用UpDown控件876</p><p>29.7.7　使用ErrorProvider878</p><p>29.7.8　使用TreeView880</p><p>29.7.9　使用WebBrowser884</p><p>29.8　构建自定义Windows Forms控件885</p><p>29.8.1　创建图像886</p><p>29.8.2　构建设计时GUI886</p><p>29.8.3　实现核心CarControl886</p><p>29.8.4　定义自定义事件888</p><p>29.8.5　定义自定义特性888</p><p>29.8.6　控制动画889</p><p>29.8.7　呈现昵称889</p><p>29.9　测试CarControl类型890</p><p>29.10　构建自定义CarControl主窗体890</p><p>29.11 System.ComponentModel名称空间的功能892</p><p>29.11.1　增强CarControl的设计时显示892</p><p>29.11.2　定义默认特性和默认事件893</p><p>29.11.3　指定自定义工具箱位图894</p><p>29.12　构建自定义对话框895</p><p>29.12.1 DialogResult特性896</p><p>29.12.2　理解窗体继承897</p><p>29.13　动态定位Windows Forms控件899</p><p>29.13.1 Anchor特性899</p><p>29.13.2 Dock特性900</p><p>29.13.3　表和流程布局901</p><p>29.14　小结902</p><p>第Ⅶ部分　使用WPF创建桌面应用程序905</p><p>第30章　WPF和XAML905</p><p>30.1 WPF的动机905</p><p>30.1.1　统一不同的API906</p><p>30.1.2　通过XAML提供关注点分离906</p><p>30.1.3　提供最佳渲染模型907</p><p>30.1.4　其他以WPF为中心的特殊性能907</p><p>30.2　各种类型的WPF应用程序908</p><p>30.2.1　传统桌面应用程序908</p><p>30.2.2　基于导航的WPF应用程序908</p><p>30.2.3 XBAP应用程序909</p><p>30.2.4 Silverlight应用程序910</p><p>30.3　研究WPF程序集910</p><p>30.3.1 Application类的功能911</p><p>30.3.2 Window类的功能912</p><p>30.4　构建（XAML-Free）WPF应用程序916</p><p>30.4.1　扩展Window类的类型918</p><p>30.4.2　创建一个简单的用户界面919</p><p>30.5 Application类型的其他细节920</p><p>30.5.1　应用程序范围数据和处理命令行实参920</p><p>30.5.2 Application的Windows集合的迭代921</p><p>30.5.3 Application类型的其他事件921</p><p>30.6 Window类型的其他细节922</p><p>30.6.1 Window对象的生存期922</p><p>30.6.2　处理Window对象的关闭923</p><p>30.6.3　处理窗口级的鼠标事件924</p><p>30.6.4　处理窗口级的键盘事件925</p><p>30.6.5　构建（以XAML为中心）WPF应用程序925</p><p>30.6.6　在XAML中定义MainWindow926</p><p>30.6.7　在XAML中定义Application对象927</p><p>30.6.8　通过msbuild.exe处理XAML文件928</p><p>30.7　将标记转换成．NET程序集930</p><p>30.7.1　映射XAML到VB代码930</p><p>30.7.2 BAML的功能931</p><p>30.7.3　针对程序集的XAML处理小结932</p><p>30.8　使用代码分离文件的关注点分离933</p><p>30.9 XAML的语法935</p><p>30.9.1 XAML名称空间和XAML关键字935</p><p>30.9.2 XAML元素和XAML属性937</p><p>30.9.3　理解XAML属性元素语法938</p><p>30.9.4　理解XAML附加特性940</p><p>30.9.5　理解XAML类型转换器941</p><p>30.9.6　理解XAML标记扩展941</p><p>30.9.7　资源和数据绑定预览943</p><p>30.10　使用Visual Studio 2008构建WPF应用程序945</p><p>30.10.1 WPF项目模板945</p><p>30.10.2　改变初始窗口的名称945</p><p>30.10.3 WPF设计器946</p><p>30.11　在运行库中处理XAML：SimpleXamlPad.exe948</p><p>30.11.1　实现Loaded事件949</p><p>30.11.2　实现Button的Click事件950</p><p>30.11.3　实现Closed事件951</p><p>30.11.4　测试应用程序951</p><p>30.12 Microsoft Expression Blend的功能952</p><p>30.13　小结953</p><p>第31章　使用WPF控件编程954</p><p>31.1 WPF控件库概述954</p><p>31.1.1 WPF控件和Visual Studio 2008955</p><p>31.1.2　文档中的细节955</p><p>31.2　在XAML中声明控件956</p><p>31.3　理解依赖属性的功能958</p><p>31.3.1　研究现有的依赖属性959</p><p>31.3.2　注册依赖属性960</p><p>31.3.3　为DependencyProperty字段定义封装器特性961</p><p>31.4　理解路由事件962</p><p>31.4.1　路由冒泡事件的功能963</p><p>31.4.2　继续或者停止冒泡964</p><p>31.4.3　路由隧道事件的功能964</p><p>31.5　使用Button类型966</p><p>31.5.1 ButtonBase类型966</p><p>31.5.2 Button类型967</p><p>31.5.3 ToggleButton类型967</p><p>31.5.4 RepeatButton类型968</p><p>31.6　使用CheckBoxes和RadioButtons969</p><p>31.6.1　建立逻辑群970</p><p>31.6.2　构架GroupBox中的相关元素971</p><p>31.6.3　构架Expander中的相关元素971</p><p>31.7　使用ListBox和ComboBox类型972</p><p>31.7.1　以编程的方式填充List控件973</p><p>31.7.2　添加专用内容974</p><p>31.7.3　确定当前选择975</p><p>31.7.4　确定内嵌内容的当前选择976</p><p>31.8　使用文本区域977</p><p>31.8.1　使用TextBox类型977</p><p>31.8.2　使用PasswordBox类型978</p><p>31.9　使用窗格控制内容布局979</p><p>31.9.1 WPF的核心窗格类型980</p><p>31.9.2　在Canvas窗格内定位内容981</p><p>31.9.3　在WrapPanel窗格内定位内容983</p><p>31.9.4　在StackPanel窗格内定位内容984</p><p>31.9.5　在Grid窗格内定位内容985</p><p>31.9.6　在DockPanel窗格内定位内容987</p><p>31.9.7　启用Panel类型的滚动行为987</p><p>31.10　使用内嵌窗格构建窗口的构架988</p><p>31.10.1　构建菜单系统989</p><p>31.10.2　构建工具栏990</p><p>31.10.3　构建状态条991</p><p>31.10.4　结束UI设计991</p><p>31.10.5　结束实现992</p><p>31.11　理解WPF控件命令993</p><p>31.11.1 内部控件命令对象993</p><p>31.11.2　连接命令到命令特性994</p><p>31.11.3　连接命令到专用UI元素995</p><p>31.12　理解WPF数据绑定模型996</p><p>31.12.1　初观数据绑定997</p><p>31.12.2 DataContext特性998</p><p>31.12.3 Mode特性998</p><p>31.13　使用IValueConverter的数据转换999</p><p>31.14　绑定自定义对象1001</p><p>31.14.1　使用Observable Collection（Of T）类型1003</p><p>31.14.2　创建自定义数据模板1004</p><p>31.15　绑定UI元素到XML文档1005</p><p>31.15.1　构建自定义对话框1006</p><p>31.15.2　分配DialogResult值1007</p><p>31.15.3　获得当前选择1008</p><p>31.15.4　显示自定义对话框1008</p><p>31.16　小结1009</p><p>第32章　WPF二维图形渲染、资源和主题1010</p><p>32.1 WPF图形渲染服务哲学1010</p><p>32.1.1 WPF图形渲染选项1011</p><p>32.1.2　选择合适的方法1016</p><p>32.2　探索Shape派生类型1016</p><p>32.3　使用WPF画笔1019</p><p>32.3.1　用单色构建画笔1019</p><p>32.3.2　使用渐变画笔1020</p><p>32.3.3 ImageBrush类型1021</p><p>32.4　使用WPF笔1021</p><p>32.5　探索Drawing派生类型1022</p><p>32.5.1　几何类型的功能1022</p><p>32.5.2　剖析简单的绘制几何1023</p><p>32.5.3 DrawingImage包含的Drawing类型1024</p><p>32.5.4 DrawingBrush中包含的Drawing类型1024</p><p>32.5.5　更加复杂的Drawing几何1025</p><p>32.6 UI转换的功能1026</p><p>32.6.1 Transform派生类型1026</p><p>32.6.2　应用转换1027</p><p>32.7　理解WPF的动画服务1028</p><p>32.7.1 Animation后缀类型的功能1028</p><p>32.7.2 Timeline基类的功能1029</p><p>32.7.3　在VB代码中编写动画1029</p><p>32.7.4　控制动画的调步1031</p><p>32.7.5　反向和循环动画1031</p><p>32.7.6　在XAML中编写动画1032</p><p>32.7.7 Animation关键帧的功能1033</p><p>32.8　理解WPF资源系统1036</p><p>32.8.1　使用二进制资源1036</p><p>32.8.2　对象（又称为逻辑）资源的功能1037</p><p>32.9　为WPF控件定义并应用样式1037</p><p>32.9.1　使用内联样式1038</p><p>32.9.2　使用命名样式1039</p><p>32.9.3　重写样式设置1040</p><p>32.9.4　使现有样式成为子类1040</p><p>32.9.5　扩展样式1041</p><p>32.9.6　收缩样式1042</p><p>32.9.7　隐式地分配样式1042</p><p>32.9.8　用触发器定义样式1042</p><p>32.9.9　以编程的方式分配样式1044</p><p>32.10　使用模板更改控件的UI1045</p><p>32.10.1　构建自定义模板1046</p><p>32.10.2　添加触发器到模板1047</p><p>32.10.3　合并模板到样式中1048</p><p>32.11　小结1050</p><p>第Ⅷ部分　用ASP.NET构建Web应用程序第33章 构建ASP.NET Web页面1053</p><p>33.1 HTTP的功能1053</p><p>33.1.1 HTTP请求／响应循环1053</p><p>33.1.2 HTTP是一种无状态协议1054</p><p>33.2　理解Web应用程序和Web服务器1054</p><p>33.2.1 IIS虚拟目录的功能1055</p><p>33.2.2 ASP.NET开发服务器1056</p><p>33.3 HTTP的功能1057</p><p>33.3.1 HTML文档结构1057</p><p>33.3.2 HTML窗体开发1058</p><p>33.3.3　构建基于HTML的用户界面1059</p><p>33.4　客户端脚本的功能1061</p><p>33.4.1　客户端脚本示例1062</p><p>33.4.2　验证default.htm窗体数据1062</p><p>33.5　提交窗体数据（获取和提交）1063</p><p>33.6　构建传统ASP页面1063</p><p>33.7　传统ASP的问题1065</p><p>33.7.1 ASP.NET 1.x的主要优点1065</p><p>33.7.2 ASP.NET 2.0的主要改进1066</p><p>33.7.3　主要的ASP.NET 3.5 Web的改进1066</p><p>33.8 ASP.NET名称空间1066</p><p>33.9 ASP.NET Web页面代码模型1067</p><p>33.9.1　构建以数据为中心的单文件测试页面1068</p><p>33.9.2　使用代码分离页面模型1073</p><p>33.10 ASP.NET网站目录结构细节1076</p><p>33.10.1　引用程序集1076</p><p>33.10.2 App_Code文件夹的功能1077</p><p>33.11 ASP.NET页面编译周期1077</p><p>33.11.1　单文件页面的编译周期1078</p><p>33.11.2　多文件页面的编译周期1078</p><p>33.12　页面类型的继承链1080</p><p>33.13　与入站HTTP请求进行互操作1081</p><p>33.13.1　获得浏览器统计数据1082</p><p>33.13.2　访问引入的窗体数据1082</p><p>33.13.3 IsPostBack特性1083</p><p>33.14　与出站HTTP响应进行互操作1084</p><p>33.14.1　发送HTML内容1084</p><p>33.14.2　重定向用户1085</p><p>33.15 ASP.NET Web页面的生命周期1085</p><p>33.15.1 AutoEventWireup属性的功能1087</p><p>33.15.2 Error事件1088</p><p>33.16 web.config文件的功能1089</p><p>33.17　小结1091</p><p>第34章　ASP.NET Web控件、主题和Master页面1092</p><p>34.1　理解Web控件的实质1092</p><p>34.1.1　限定服务器端的事件处理1093</p><p>34.1.2 AutoPostBack特性1093</p><p>34.1.3 System.Web.UI.Control类型1094</p><p>34.1.4　枚举已包含的控件1095</p><p>34.1.5　动态添加（或者移除）控件1096</p><p>34.2 System.Web.UI.WebControls.WebControl类型的关键成员1097</p><p>34.3 ASP.NET Web控件的类别1098</p><p>34.4 构建ASP.NET网站1099</p><p>34.4.1　使用Master页面1100</p><p>34.4.2　定义Default.aspx内容页面1105</p><p>34.4.3　设计目录内容页面1106</p><p>34.4.4 设计Build-a-Car内容页面1110</p><p>34.5　验证控件的功能1111</p><p>34.5.1 RequiredFieldValidator1113</p><p>34.5.2 RegularExpressionValidator1113</p><p>34.5.3 RangeValidator1114</p><p>34.5.4 CompareValidator1114</p><p>34.5.5　创建验证小结1115</p><p>34.6　使用主题1115</p><p>34.6.1　理解＊.skin文件1116</p><p>34.6.2　应用站点范围的主题1117</p><p>34.6.3　在页面级应用主题1118</p><p>34.6.4 SkinID特性1118</p><p>34.6.5 以编程的方式分配主题1119</p><p>34.7 小结1120</p><p>第35章　ASP.NET状态管理技术1122</p><p>35.1　发布状态1122</p><p>35.2 ASP.NET状态管理技术1124</p><p>35.3 理解ASP.NET查看状态的功能1124</p><p>35.3.1　示范查看状态1125</p><p>35.3.2　添加自定义查看状态数据1126</p><p>35.3.3 关于控件状态的简述1127</p><p>35.4 Global.asax文件的功能1127</p><p>35.4.1　全局最后机会异常事件处理程序1129</p><p>35.4.2 HttpApplication基类1129</p><p>35.5　理解应用程序／会话的区别1130</p><p>35.5.1　维护应用程序级状态数据1130</p><p>35.5.2　修改应用程序数据1133</p><p>35.5.3　处理Web应用程序的关闭1133</p><p>35.6　使用应用程序缓存1134</p><p>35.6.1　使用数据缓存1134</p><p>35.6.2　修改＊.aspx文件1137</p><p>35.7　维护会话数据1138</p><p>35.7.1 其他HttpSessionState成员1140</p><p>35.7.2　理解Cookie1141</p><p>35.7.3　创建Cookie1142</p><p>35.7.4　读取引入的Cookie数据1143</p><p>35.8　〈sessionState〉元素的功能1144</p><p>35.8.1 在ASP.NET会话状态服务器上存储会话数据1144</p><p>35.8.2　在专用数据库中存储会话数据1145</p><p>35.9 理解ASP.NET配置文件API1146</p><p>35.9.1 ASPNETDB数据库1146</p><p>35.9.2　在web.config中定义用户配置文件1147</p><p>35.9.3 以编程的方式访问配置文件数据1148</p><p>35.9.4　分组配置文件数据并保留自定义对象1151</p><p>35.10　小结1152</p><p></p></div></div><div class="d-rt"><h3>热门推荐</h3><ul><li><a href="/book/3224276.html">3224276.html</a></li><li><a href="/book/1061044.html">1061044.html</a></li><li><a href="/book/476768.html">476768.html</a></li><li><a href="/book/3405977.html">3405977.html</a></li><li><a href="/book/2450341.html">2450341.html</a></li><li><a href="/book/1854429.html">1854429.html</a></li><li><a href="/book/3795130.html">3795130.html</a></li><li><a href="/book/2013943.html">2013943.html</a></li><li><a href="/book/337714.html">337714.html</a></li><li><a href="/book/1072995.html">1072995.html</a></li></ul></div></div><div id="footer"><p>Copyright&nbsp;&copy;&nbsp;2025&nbsp;&nbsp;<a href="/list/">最新更新</a></p><p>请使用FDM BitComet qBittorrent uTorrent等BT下载工具，下载本站电子书资源！首推Free Download Manager下载软件。文件页数>标注页数[分册图书除外]</p></div></body></html>