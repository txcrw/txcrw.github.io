<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><script type="text/javascript" src="https://file.bkxsj.com/skin/book/js/sk.js"></script><meta name="robots" content="index,follow"><title>数字逻辑设计 VHDL 基础 英文版[PDF|Epub|txt|kindle电子书版本网盘下载]-灵感之桥</title><meta name="Keywords" content="数字逻辑设计 VHDL 基础 英文版"/><meta name="description" content="数字逻辑设计 VHDL 基础 英文版pdf下载文件大小为71MB,PDF页数为853页"/><meta http-equiv="X-UA-Compatible" content="IE=9; IE=8; IE=7; IE=EDGE;chrome=1"><link type="image/x-icon" rel="shortcut icon" href="https://www.shukui.net/skin/book/images/favicon.ico"><link type="text/css" rel="stylesheet" href="https://www.shukui.net/skin/book/css/style.css"><style>#main .d-main {margin-left: 0;width: 620px;}.down-btn {animation: myShake 2.5s linear .15s infinite}@keyframes myShake {0%, 66% {transform: translateZ(0)}67%, 73.6%, 83.6%, 93.6%, to {animation-timing-function: cubic-bezier(.215, .61, .355, 1);transform: translateZ(0)}80.3%, 81.4% {animation-timing-function: cubic-bezier(.755, .05, .855, .06);transform: translate3d(0, -4px, 0)}90.3% {animation-timing-function: cubic-bezier(.755, .05, .855, .06);transform: translate3d(0, -2px, 0)}97% {transform: translate3d(0, -.5px, 0)}}.copylink-btn {margin-right: 20px;}.copymd5-btn {margin-bottom: 25px;margin-left: 10px;}</style></head><body><div id="header"><div class="inner"><div class="logo"><a href="/"><img width="103" height="25" alt="灵感之桥"src="https://www.shukui.net/skin/book/images/logo.png"></a></div><div class="search"><form action="/so/search.php" target="_blank"><input type="text" autocomplete="off" id="bdcsMain" name="q" placeholder="书名 / 作者 / 出版社 / ISBN"class="inp-txt"><select class="inp-select" id="datasource" onchange="selectDatasource(this)"><option value="so">主库</option><option value="s">从库</option></select><input type="submit" value="搜索" class="inp-btn"></form></div></div></div><div id="main"><div class="d-main"><div class="tit"><h3>图书介绍</h3></div><h1 class="book-name">数字逻辑设计 VHDL 基础 英文版PDF|Epub|txt|kindle电子书版本网盘下载</h1><div class="d-info"><div class="b-thumb"><img src="https://www.shukui.net/cover/9/31574106.jpg" alt="数字逻辑设计 VHDL 基础 英文版"></div><div class="b-info"><ul><li>（美）斯蒂芬·布朗（StephenBrown），（美）兹翁科·弗拉内希奇（ZvonkoVranesic）著 著</li><li>出版社： 北京：机械工业出版社</li><li>ISBN：7111106407</li><li>出版时间：2002</li><li>标注页数：840页</li><li>文件大小：71MB</li><li>文件页数：853页</li><li>主题词：</li></ul></div></div><div class="tit"><h3>PDF下载</h3></div><div></br><a style="color:red;" rel="external nofollow" href="https://www.kjlm.net/ebook/1403855.html"target="_blank"><b>点此进入-本书在线PDF格式电子书下载【推荐-云解压-方便快捷】直接下载PDF格式图书。移动端-PC端通用</a></b></br><a class="down-btn" rel="external nofollow" href="https://down.trackerbk.com/bt/04/31574106.torrent"target="_blank">种子下载</a>[BT下载速度快]温馨提示：（请使用BT下载软件FDM进行下载）<a rel="nofollow" href="https://www.freedownloadmanager.org/zh/" target="_blank">软件下载地址页</a><a class="down-btn" rel="external nofollow" href="https://down.p2spdb.com/04/31574106.rar" target="_blank">直链下载</a>[便捷但速度慢]&nbsp;&nbsp;<a style="color:red;" rel="external nofollow" href="https://pdfyl.ertongbook.com/32/31574106.pdf" target="_blank"><b>[在线试读本书]</b></a>&nbsp;&nbsp;<b> <a style="color:red;" rel="external nofollow" href="https://web.jyjl.org/index/recovery.html" target="_blank">[在线获取解压码]</a></b><div class="copymd5-btn"><a href="javascript:copyToClip('9fc3b3c1ebc51a38c2ad39ef3d5f3666')">点击复制MD5值：9fc3b3c1ebc51a38c2ad39ef3d5f3666</a></div></div><div class="tit"><h3>下载说明</h3></div><div style="margin:20px 10px"><h2>数字逻辑设计 VHDL 基础 英文版PDF格式电子书版下载</h2>下载的文件为RAR压缩包。需要使用解压软件进行解压得到PDF格式图书。<br><br><div class="copymd5-btn"><a href="javascript:copyToClip('magnet:?xt=urn:btih:RX6G6JQ2LJW7PBBEDNUSCQM7ICDMHIWK')">点击复制85GB完整离线版磁力链接到迅雷FDM等BT下载工具进行下载</a>&nbsp;&nbsp;<a rel="nofollow" target="_blank">详情点击-查看共享计划</a></div>建议使用BT下载工具Free Download Manager进行下载,简称FDM(免费,没有广告,支持多平台）。本站资源全部打包为BT种子。所以需要使用专业的BT下载软件进行下载。如BitComet qBittorrent uTorrent等BT下载工具。迅雷目前由于本站不是热门资源。不推荐使用！后期资源热门了。安装了迅雷也可以迅雷进行下载！<br><br><b>（文件页数 要大于 标注页数，上中下等多册电子书除外）</b><br><br><p style="color:red;"> <b>注意：本站所有压缩包均有解压码：</b> <a rel="nofollow" target="_blank"><b>点击下载压缩包解压工具</b></a></p></div><div class="tit"><h3>图书目录</h3></div><div id="book-contents"><p>Chapter 1 DESIGN CONCEPTS 11</p><p>1．1 Digital Hardware2</p><p>1．1．1 Standard Chips4</p><p>1．1．2 Programmable Logic Devices4</p><p>1．1．3 Custom-Designed Chips5</p><p>1．2 The Design Process6</p><p>1．3 Design of Digital Hardware8</p><p>1．3．1 Basic Design Loop8</p><p>1．3．2 Design of a Digital Hardware Unit9</p><p>1．4 Logic Circuit Design in this Book12</p><p>1．5 Theory and Practice14</p><p>References15</p><p>Chapter 2 INTRODUCTION TO LOGIC CIRCUITS17</p><p>2．1 Variables and Functions18</p><p>2．2 Inversion21</p><p>2．3 Truth Tables22</p><p>2．4 Logic Gates and Networks23</p><p>2．4．1 Analysis of a Logic Network24</p><p>2．5 Boolean Algebra27</p><p>2．5．1 The Venn Diagram30</p><p>2．5．2 Notation and Terminology34</p><p>2．5．3 Precedence of Operations34</p><p>2．6 Synthesis Using AND，OR，and NOT Gates35</p><p>2．6．1 Sum-of-Products and Product-of-Sums Forms37</p><p>2．7 Design Examples41</p><p>2．7．1 Three Way Light Control42</p><p>2．7．2 Multiplexer Circuit43</p><p>2．8 Introduction to CAD Tools45</p><p>2．8．1 Design Entry46</p><p>2．8．2 Synthesis48</p><p>2．8．3 Functional Simulation49</p><p>2．8．4 Summary49</p><p>2．9 Introduction to VHDL51</p><p>2．9．2 Writing Simple VHDL Code52</p><p>4．2 Strategy for Minimization52</p><p>2．9．1 Representation of Digital Signals in VHDL52</p><p>2．9．3 How Not to Write VHDL Code54</p><p>2．10 Concluding Remarks55</p><p>Problems56</p><p>References60</p><p>Chapter 3 IMPLEMENTATION TECHNOLOGY61</p><p>3．1 Transistor Switches63</p><p>3．2 NMOS Logic Gates65</p><p>3．3 CMOS Logic Gates68</p><p>3．3．1 Speed of Logic Gate Circuits75</p><p>3．4 Negative Logic System76</p><p>3．5 Standard Chips77</p><p>3．5．1 7400-Series Standard Chips77</p><p>3．6 Programmable Logic Devices81</p><p>3．6．1 Programmable Logic Array(PLA)81</p><p>3．6．2 Programmable Array Logic(PAL)84</p><p>3．6．3 Programming of PLAs and PALs86</p><p>3．6．4 Complex Programmable Logic Devices (CPLDs)88</p><p>3．6．5 Field-Programmable Gate Arrays92</p><p>3．6．6 Using CAD Tools to Implement Circuits in CPLDs and FPGAs96</p><p>3．7 Custom Chips，Standard Cells，and Gate Arrays97</p><p>3．8 Practical Aspects100</p><p>3．8．1 MOSFET Fabrication and Behavior100</p><p>3．8．2 MOSFET On-Resistance104</p><p>3．8．3 Voltage Levels in Logic Gates105</p><p>3．8．4 Noise Margin107</p><p>3．8．5 Dynamic Operation of Logic Gates108</p><p>3．8．6 Power Dissipation in Logic Gates111</p><p>3．8．7 Passing Is and Os Through Transistor Switches112</p><p>3．8．8 Fan-in and Fan-out in Logic Gates114</p><p>3．9 Transmission Gates120</p><p>3．9．1 Exclusive-OR Gates121</p><p>3．9．2 Multiplexer Circuit122</p><p>3．10 Implementation Details for SPLDs，CPLDs，and FPGAs123</p><p>3．10．1 Implementation in FPGAs129</p><p>3．11 Concluding Remarks131</p><p>Problems132</p><p>References141</p><p>Chapter 4 OPTIMIZED IMPLEMENTATION OF LOGIC FUNCTIONS143</p><p>4．1 Karnaugh Map144</p><p>4．2．1 Terminology153</p><p>4．2．2 Minimization Procedure154</p><p>4．3 Minimization of Product-of-Sums Forms158</p><p>4．4 Incompletely Specified Functions160</p><p>4．5 Multiple-Output Circuits161</p><p>4．6 NAND and NOR Logic Networks165</p><p>4．7 Multilevel Synthesis167</p><p>4．7．1 Factoring168</p><p>4．7．2 Functional Decomposition171</p><p>4．7．3 Multilevel NAND and NOR Circuits177</p><p>4．8 Analysis of Multilevel Circuits180</p><p>4．9 Cubical Representation185</p><p>4．9．1 Cubes and Hypercubes185</p><p>4．10 Minimization Using Cubical Representation189</p><p>4．10．1 Generation of Prime Implicants189</p><p>4．10．2 Determination of Essential Prime Implicants192</p><p>4．10．3 Complete Procedure for Finding a Minimal Cover194</p><p>4．11 Practical Considerations196</p><p>4．12 CAD Tools197</p><p>4．12．1 Logic Synthesis and Optimization198</p><p>4．12．2 Physical Design199</p><p>4．12．3 Timing Simulation201</p><p>4．12．4 Summary of Design Flow202</p><p>4．12．5 Examples of Circuits Synthesized from VHDL Code204</p><p>4．13 Concluding Remarks210</p><p>Problems211</p><p>References214</p><p>Chapter 5 NUMBER REPRESENTATION AND ARITHMETIC CIRCUITS217</p><p>5．1 Positional Number Representation218</p><p>5．1．1 Unsigned Integers218</p><p>5．1．2 Conversion between Decimal and Binary Systems219</p><p>5．1．3 Octal and Hexadecimal Representations220</p><p>5．2 Addition of Unsigned Numbers222</p><p>5．2．1 Decomposed Full-Adder226</p><p>5．2．2 Ripple-Carry Adder227</p><p>5．2．3 Design Example228</p><p>5．3 Signed Numbers228</p><p>5．3．1 Negative Numbers228</p><p>5．3．2 Addition and Subtraction232</p><p>5．3．3 Adder and Subtractor Unit236</p><p>5．3．4 Radix-Complement Schemes237</p><p>5．3．5 Arithmetic Overflow241</p><p>5．3．6 Performance Issues242</p><p>5．4．1 Carrv-Lookahead Adder243</p><p>5．4 Fast Adders243</p><p>5．5 Design of Arithmetic Circuits Using CAD Tools250</p><p>5．5．1 Design of Arithmetic Circuits Using Schematic Capture250</p><p>5．5．2 Design of Arithmetic Circuits Using VHDL253</p><p>5．5．3 Representation of Numbers in VHDL Code256</p><p>5．5．4 Arithmetic Assignment Statements258</p><p>5．6 Multiplication262</p><p>5．6．1 Array Multiplier for Unsigned Numbers263</p><p>5．6．2 Multiplication of Signed Numbers264</p><p>5．7 Other Number Representations267</p><p>5．7．1 Fixed-Point Numbers267</p><p>5．7．2 Floating-Point Numbers267</p><p>5．7．3 Binary-Coded-Decimal Representation269</p><p>5．8 ASCII Character Code273</p><p>Problems276</p><p>References280</p><p>Chapter 6 COMBINATIONAL-CIRCUIT BUILDING BLOCKS281</p><p>6．1 Multiplexers282</p><p>6．1．1 Synthesis of Logic Functions Using Multiplexers287</p><p>6．1．2 Multiplexer Synthesis Using Shannon s Expansion288</p><p>6．2 Decoders295</p><p>6．2．1 Demultiplexers298</p><p>6．3 Encoders300</p><p>6．3．1 Binary Encoders300</p><p>6．3．2 Priority Encoders301</p><p>6．4 Code Converters302</p><p>6．5 Arithmetic Comparison Circuits304</p><p>6．6 VHDL for Combinational Circuits304</p><p>6．6．1 Assignment Statements305</p><p>6．6．2 Selected Signal Assignment305</p><p>6．6．3 Conditional Signal Assignment308</p><p>6．6．4 Generate Statements312</p><p>6．6．5 Concurrent and Sequential Assignment Statements315</p><p>6．6．6 Process Statement315</p><p>6．6．7 Case Statement321</p><p>6．7 Concluding Remarks324</p><p>Problems326</p><p>References330</p><p>Chapter 7 FLIP-FLOPS，REGISTERS，COUNTERS，AND A SIMPLE PROCESSOR331</p><p>7．1 Basic Latch333</p><p>7．2 Gated SR Latch335</p><p>7．2．1 Gated SR Latch with NAND Gates337</p><p>7．3 Gated D Latch338</p><p>7．3．1 Effects of Propagation Delays340</p><p>7．4 Master-Slave and Edge-Triggered D Flip-Flops341</p><p>7．4．1 Master-Slave D Flip-Flop341</p><p>7．4．2 Edge-Triggered D Flip-Flop342</p><p>7．4．3 D FLIP-Flops with Clear and Preset344</p><p>7．5 T Flip-Flop346</p><p>7．5．1 Configurable Flip-Flops349</p><p>7．6 JK Flip-Flop349</p><p>7．8 Registers350</p><p>7．7 Summary of Terminology350</p><p>7．8．1 Shift Register351</p><p>7．8．2 Parallel-Access Shift Register352</p><p>7．9 Counters353</p><p>7．9．1 Asynchronous Counters353</p><p>7．9．2 Synchronous Counters356</p><p>7．9．3 Counters with Parallel Load360</p><p>7．10 Reset Synchronization360</p><p>7．11 Other Types of Counters364</p><p>7．11．1 BCD Counter364</p><p>7．11．2 Ring Counter365</p><p>7．11．3 Johnson Counter366</p><p>7．12 Using Storage Elements with CAD Tools367</p><p>7．12．1 Including Storage Elements in Schematics367</p><p>7．11．4 Remarks on Counter Design367</p><p>7．12．2 Using Latches and Flip-Flops in VHDL Code370</p><p>7．12．3 Using VHDL Sequential Statements for Storage Elements370</p><p>7．13 Using Registers and Counters with CAD Tools375</p><p>7．13．1 Including Registers and Counters in Schematics375</p><p>7．13．2 Registers and Counters in VHDL Code378</p><p>7．13．3 Using VHDL Sequential Statements for Registers and Counters379</p><p>7．14 Design Examples387</p><p>7．14．1 Bus Structure387</p><p>7．14．2 Simple Processor400</p><p>7．14．3 Reaction Timer413</p><p>7．15 Concluding Remarks418</p><p>Problems418</p><p>References424</p><p>Chapter 8 SYNCHRONOUS SEQUENTIAL CIRCUITS427</p><p>8．1 Basic Design Steps429</p><p>8．1．1 State Diagram429</p><p>8．1．2 State Table431</p><p>8．1．3 State Assignment431</p><p>8．1．4 Choice of Flip-Flops and Derivation of Next-State and Output Expressions433</p><p>8．1．5 Timing Diagram435</p><p>8．1．6 Summary of Design Steps436</p><p>8．2 State-Assignment Problem440</p><p>8．2．1 One-Hot Encoding442</p><p>8．3 Mealy State Model444</p><p>8．4 Design of Finite State Machines Using CAD Tools449</p><p>8．4．1 VHDL Code for Moore-Type FSMs449</p><p>8．4．2 Synthesis of VHDL Code451</p><p>8．4．3 Simulating and Testing the Circuit454</p><p>8．4．4 An Alternative Style of VHDL Code456</p><p>8．4．5 Summary of Design Steps When Using CAD Tools456</p><p>8．4．6 Specifying the State Assignment in VHDL Code458</p><p>8．4．7 Specification of Mealy FSMs Using VHDL459</p><p>8．5 Serial Adder Example463</p><p>8．5．1 Mealy-Type FSM for Serial Adder463</p><p>8．5．2 Moore-Type FSM for Serial Adder464</p><p>8．5．3 VHDL Code for the Serial Adder467</p><p>8．6 State Minimization470</p><p>8．6．1 Partitioning Minimization Procedure473</p><p>8．6．2 Incompletely Specified FSMs480</p><p>8．7．2 State Assignment482</p><p>8．7 Design of a Counter Using the Sequential Circuit Approach482</p><p>8．7．1 State Diagram and State Table for a Modulo-8 Counter482</p><p>8．7．3 Implementation Using D-Type Flip-Flops484</p><p>8．7．4 Implementation Using JK-Type Flip-Flops485</p><p>8．7．5 Example-A Different Counter489</p><p>8．8 FSM as an Arbiter Circuit492</p><p>8．8．1 Implementation of the Arbiter Circuit496</p><p>8．8．2 Minimizing the Output Delays for an Fsm499</p><p>8．8．3 Summary499</p><p>8．9 Analysis of Synchronous Sequential Circuits500</p><p>8．10 Algorithmic State Machine(ASM)Charts504</p><p>8．11 Formal Model for Sequential Circuits507</p><p>Problems509</p><p>8．12 Concluding Remarks509</p><p>References513</p><p>Chapter 9 ASYNCHRONOUS SEQUENTIAL CIRCUITS515</p><p>9．1 Asynchronous Behavior516</p><p>9．2 Analysis of Asynchronous Circuits519</p><p>9．3 Synthesis of Asynchronous Circuits528</p><p>9．4 State Reduction540</p><p>9．5 State Assignment555</p><p>9．5．1 Transition Diagram558</p><p>9．5．2 Exploiting Unspecified Next-State Entries561</p><p>9．5．3 State Assignment Using Additional State Variables565</p><p>9．5．4 One-Hot State Assignment569</p><p>9．6 Hazards571</p><p>9．6．1 Static Hazards572</p><p>9．6．2 Dynamic Hazards576</p><p>9．6．3 Significance of Hazards578</p><p>9．7 A Complete Design Example579</p><p>9．7．1 The Vending-Machine Controller579</p><p>9．8 Concluding Remarks583</p><p>Problems585</p><p>References590</p><p>Chapter 10 DIGITAL SYSTEM DESIGN591</p><p>10．1 Building Block Circuits592</p><p>10．1．1 Flip-Flops and Registers with Enable Inputs592</p><p>10．1．2 Shift Registers with Enable Inputs593</p><p>10．1．3 Static Random Access Memory (SRAM)595</p><p>10．2 Design Examples600</p><p>10．2．1 A Bit-Counting Circuit600</p><p>10．1．4 SRAM Blocks in PLDs600</p><p>10．2．2 ASM Chart Implied Timing Information601</p><p>10．2．3 Shift-and-Add Multiplier603</p><p>10．2．4 Divider612</p><p>10．2．5 Arithmetic Mean623</p><p>10．2．6 Sort Operation629</p><p>10．3 Clock Synchronization639</p><p>10．3．1 Clock Skew640</p><p>10．3．2 Filp-Flop Timing Parameters641</p><p>10．3．3 Asynchronous Inputs to Flip-Flops644</p><p>10．4 Concluding Remarks645</p><p>10．3．4 Switch Debouncing645</p><p>Problems647</p><p>References651</p><p>Chapter 11 TESTING OF LOGIC CIRCUITS653</p><p>11．1 Fault Model654</p><p>11．1．1 Stuck-at Model654</p><p>11．1．2 Single and Multiple Faults655</p><p>11．1．3 CMOS Circuits655</p><p>11．2 Complexity of a Test Set655</p><p>11．3 Path Sensitizing657</p><p>11．3．1 Detection of a Specific Fault659</p><p>11．4 Circuits with Tree Structure661</p><p>11．5 Random Tests662</p><p>11．6 Testing of Sequential Circuits665</p><p>11．6．1 Design for Testability665</p><p>11．7 Built-in Self-Test669</p><p>11．7．1 Built-in Logic Block Observer673</p><p>11．7．2 Signature Analysis675</p><p>11．7．3 Boundary Scan676</p><p>11．8 Printed Circuit Boards676</p><p>11．8．1 Testing of PCBs678</p><p>11．8．2 Instrumentation679</p><p>11．9 Concluding Remarks680</p><p>Problems680</p><p>References683</p><p>Appendix A VHDL REFERENCE685</p><p>A．1 Documentation in VHDL Code686</p><p>A．2 Data Objects687</p><p>A．2．1 Data Object Names687</p><p>A．2．2 Data Object Values and Numbers687</p><p>A．2．3 SIGNAL Data Objects687</p><p>A．2．4 BIT and BIT_VECTOR Types688</p><p>A．2．5 STD_LOGIC and STD_LOGIC_VECTOR Types688</p><p>A．2．6 STD_ULOGIC Type689</p><p>A．2．7 SIGNED and UNSIGNED Types690</p><p>A．2．8 INTEGER Type690</p><p>A．2．9 BOOLEAN Type691</p><p>A．2．10 ENUMERATION Type691</p><p>A．2．12 VARIABLE Data Ojbects692</p><p>A．2．13 Type Conversion692</p><p>A．2．11 CONSTANT Data Objects692</p><p>A．2．14 Arrays693</p><p>A．3 Operators693</p><p>A．4 VHDL Design Entity694</p><p>A．4．1 ENTITY Declaration695</p><p>A．4．2 ARCHITECTURE695</p><p>A．5 Package697</p><p>A．6 Using Subcircuits698</p><p>A．6．1 Declaring a COMPONENT in a Package700</p><p>A．7 Concurrent Assignment Statements701</p><p>A．7．1 Simple Signal Assignment701</p><p>A．7．2 Assigning Signal Values Using OTHERS703</p><p>A．7．4 Conditional Signal Assignment704</p><p>A．7．3 Selected Signal Assignment704</p><p>A．7．5 GENERATE Statement705</p><p>A．8 Defining an Entity with GENERICs707</p><p>A．9 Sequential Assignment Statements707</p><p>A．9．1 PROCESS Statement708</p><p>A．9．2 IF Statement708</p><p>A．9．3 CASE Statement709</p><p>A．9．4 LOOP Statements710</p><p>A．9．5 Using a Process for a Combinational Circuit710</p><p>A．9．6 Statement Ordering711</p><p>A．9．7 Using a VARIABLE in a PRocess712</p><p>A．10 Sequential Circuits716</p><p>A．10．2 D Flip-Flop717</p><p>A．10．1 A Gated D Latch717</p><p>A．10．3 Using a WAIT UNTIL Statement719</p><p>A．10．4 A Flip-Flop with Asynchronous Reset719</p><p>A．10．5 Synchronous Reset719</p><p>A．10．6 Instantiating a Flip-Flop from a Library721</p><p>A．10．7 Registers721</p><p>A．10．8 Shift Registers723</p><p>A．10．9 Counters725</p><p>A．10．10 Using Subcircuits with GENERIC Parameters725</p><p>A．10．11 A Moore-Type Finite State Machine728</p><p>A．10．12 A Mealy-Type Finite State Machine731</p><p>A．10．13 Manual State Assignment for a Finite State Machine731</p><p>A．11 Common Errors in VHDL Code734</p><p>References738</p><p>A．12 Concluding Remarks738</p><p>Appendix B TUTORIAL 1739</p><p>B．1 Introduction740</p><p>B．1．1 Getting Started740</p><p>B．2 Design Entry Using Schematic Capture743</p><p>B．2．1 Specifying the Project Name744</p><p>B．2．2 Using the Graphic Editor744</p><p>B．2．3 Synthesizing a Circuit from the Schematic750</p><p>B．2．4 Performing Functional Simulation751</p><p>B．2．5 Using the Message Processor to Locate and Fix Errors755</p><p>B．3 Design Entry Using VHDL757</p><p>B．3．1 Specifying the Project Name757</p><p>B．3．2 Using the Text Editor757</p><p>B．3．4 Performing Functional Simulation759</p><p>B．3．3 Synthesizing a Circuit from the VHDL Code759</p><p>B．3．5 Using the Message Processor to Debug VHDL Code760</p><p>B．4 Design Entry Using Truth Tables760</p><p>B．4．1 Using the Waveform Dditor760</p><p>B．4．2 Create the Timing Diagram761</p><p>B．4．3 Synthesizing a Circuit from the Waveforms763</p><p>B．5 Mixing Design-Entry Methods764</p><p>B．5．1 Creating a Schematic that Includes a Truth Table764</p><p>B．5．2 Synthesizing and Simulating a Circuit from the Schematic765</p><p>B．5．3 Using the Hierarchy Display766</p><p>B．5．4 Concluding Remarks767</p><p>Appendix C TUTORIAL 2769</p><p>C．1 Implementing a Circuit in a MAX 7000 CPLD770</p><p>C．1．1 Using the Compiler771</p><p>C．1．2 Selecting a Chip772</p><p>C．1．3 Viewing the Logic Synthesis Options773</p><p>C．1．4 Examining the Implemented Circuit774</p><p>C．1．5 Running the Timing Simulator775</p><p>C．1．6 Using the Floorplan Editor776</p><p>C．2 Implementing a Circuit in a FLEX 10K FPGA779</p><p>C．3 Downloading a Circuit into a Device781</p><p>C．4 Making Pin Assignments783</p><p>C．4．1 Assigning Signals to Pins in the Floorplan Editor785</p><p>C．4．2 Making Pin Assignments Permanent786</p><p>C．5 Concluding Remarks787</p><p>Appendix D TUTORIAL 3789</p><p>D．1．2 The Ripple-Carry Adder Dode790</p><p>D．1 Design Using Hierarchical VHDL Code790</p><p>D．1．1 The Full-Adder Subcircuit790</p><p>D．1．3 Alternative Style of Code for the Ripple-Carry Adder795</p><p>D．1．4 Using the Timing Analyzer Module795</p><p>D．2 Using an LPM Module796</p><p>D．3 Design of a Sequential Circuit800</p><p>D．3．1 Using the Graphic Editor800</p><p>D．3．2 Synthesizing a Circuit and Using the Timing Simulator806</p><p>D．3．3 Using the Timing Analyzer807</p><p>D．3．4 Using VHDL Code807</p><p>D．4 Design of a Finite State Machine809</p><p>D．4．1 Implementation in a CPLD810</p><p>D．4．2 Implementation in an FPGA813</p><p>D．5 Concluding Remarks815</p><p>Appendix E COMMERCIAL DEVICES817</p><p>E．1 Simple PLDs818</p><p>E．1．1 The 22V10PAL Device818</p><p>E．2 Complex PLDs820</p><p>E．2．1 Altera MAX 7000821</p><p>E．3 Field-Programmable Gate Arrays822</p><p>E．3．1 Altera FLEX 10K823</p><p>E．3．2 Xilinx XC4000826</p><p>E．4 Transistor-Transistor Logic827</p><p>E．4．1 TTL Circuit Families829</p><p>References830</p><p>INDEX831</p><p></p></div></div><div class="d-rt"><h3>热门推荐</h3><ul><li><a href="/book/3615001.html">3615001.html</a></li><li><a href="/book/139570.html">139570.html</a></li><li><a href="/book/1306237.html">1306237.html</a></li><li><a href="/book/357380.html">357380.html</a></li><li><a href="/book/3764627.html">3764627.html</a></li><li><a href="/book/2119367.html">2119367.html</a></li><li><a href="/book/112470.html">112470.html</a></li><li><a href="/book/3370414.html">3370414.html</a></li><li><a href="/book/325483.html">325483.html</a></li><li><a href="/book/2090956.html">2090956.html</a></li></ul></div></div><div id="footer"><p>Copyright&nbsp;&copy;&nbsp;2025&nbsp;&nbsp;<a href="/list/">最新更新</a></p><p>请使用FDM BitComet qBittorrent uTorrent等BT下载工具，下载本站电子书资源！首推Free Download Manager下载软件。文件页数>标注页数[分册图书除外]</p></div></body></html>