<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><script type="text/javascript" src="https://file.bkxsj.com/skin/book/js/sk.js"></script><meta name="robots" content="index,follow"><title>程序设计抽象思想 C语言描述[PDF|Epub|txt|kindle电子书版本网盘下载]-灵感之桥</title><meta name="Keywords" content="程序设计抽象思想 C语言描述"/><meta name="description" content="程序设计抽象思想 C语言描述pdf下载文件大小为120MB,PDF页数为687页"/><meta http-equiv="X-UA-Compatible" content="IE=9; IE=8; IE=7; IE=EDGE;chrome=1"><link type="image/x-icon" rel="shortcut icon" href="https://www.shukui.net/skin/book/images/favicon.ico"><link type="text/css" rel="stylesheet" href="https://www.shukui.net/skin/book/css/style.css"><style>#main .d-main {margin-left: 0;width: 620px;}.down-btn {animation: myShake 2.5s linear .15s infinite}@keyframes myShake {0%, 66% {transform: translateZ(0)}67%, 73.6%, 83.6%, 93.6%, to {animation-timing-function: cubic-bezier(.215, .61, .355, 1);transform: translateZ(0)}80.3%, 81.4% {animation-timing-function: cubic-bezier(.755, .05, .855, .06);transform: translate3d(0, -4px, 0)}90.3% {animation-timing-function: cubic-bezier(.755, .05, .855, .06);transform: translate3d(0, -2px, 0)}97% {transform: translate3d(0, -.5px, 0)}}.copylink-btn {margin-right: 20px;}.copymd5-btn {margin-bottom: 25px;margin-left: 10px;}</style></head><body><div id="header"><div class="inner"><div class="logo"><a href="/"><img width="103" height="25" alt="灵感之桥"src="https://www.shukui.net/skin/book/images/logo.png"></a></div><div class="search"><form action="/so/search.php" target="_blank"><input type="text" autocomplete="off" id="bdcsMain" name="q" placeholder="书名 / 作者 / 出版社 / ISBN"class="inp-txt"><select class="inp-select" id="datasource" onchange="selectDatasource(this)"><option value="so">主库</option><option value="s">从库</option></select><input type="submit" value="搜索" class="inp-btn"></form></div></div></div><div id="main"><div class="d-main"><div class="tit"><h3>图书介绍</h3></div><h1 class="book-name">程序设计抽象思想 C语言描述PDF|Epub|txt|kindle电子书版本网盘下载</h1><div class="d-info"><div class="b-thumb"><img src="https://www.shukui.net/cover/70/33138266.jpg" alt="程序设计抽象思想 C语言描述"></div><div class="b-info"><ul><li>（美）Eric S.Roberts著；闪四清译 著</li><li>出版社： 北京：清华大学出版社</li><li>ISBN：7302101655</li><li>出版时间：2005</li><li>标注页数：665页</li><li>文件大小：120MB</li><li>文件页数：687页</li><li>主题词：C语言－程序设计</li></ul></div></div><div class="tit"><h3>PDF下载</h3></div><div></br><a style="color:red;" rel="external nofollow" href="https://www.kjlm.net/ebook/2420676.html"target="_blank"><b>点此进入-本书在线PDF格式电子书下载【推荐-云解压-方便快捷】直接下载PDF格式图书。移动端-PC端通用</a></b></br><a class="down-btn" rel="external nofollow" href="https://down.trackerbk.com/bt/07/33138266.torrent"target="_blank">种子下载</a>[BT下载速度快]温馨提示：（请使用BT下载软件FDM进行下载）<a rel="nofollow" href="https://www.freedownloadmanager.org/zh/" target="_blank">软件下载地址页</a><a class="down-btn" rel="external nofollow" href="https://down.p2spdb.com/07/33138266.rar" target="_blank">直链下载</a>[便捷但速度慢]&nbsp;&nbsp;<a style="color:red;" rel="external nofollow" href="https://pdfyl.ertongbook.com/56/33138266.pdf" target="_blank"><b>[在线试读本书]</b></a>&nbsp;&nbsp;<b> <a style="color:red;" rel="external nofollow" href="https://web.jyjl.org/index/recovery.html" target="_blank">[在线获取解压码]</a></b><div class="copymd5-btn"><a href="javascript:copyToClip('c447086af08e53870f0dd59413123474')">点击复制MD5值：c447086af08e53870f0dd59413123474</a></div></div><div class="tit"><h3>下载说明</h3></div><div style="margin:20px 10px"><h2>程序设计抽象思想 C语言描述PDF格式电子书版下载</h2>下载的文件为RAR压缩包。需要使用解压软件进行解压得到PDF格式图书。<br><br><div class="copymd5-btn"><a href="javascript:copyToClip('magnet:?xt=urn:btih:RX6G6JQ2LJW7PBBEDNUSCQM7ICDMHIWK')">点击复制85GB完整离线版磁力链接到迅雷FDM等BT下载工具进行下载</a>&nbsp;&nbsp;<a rel="nofollow" target="_blank">详情点击-查看共享计划</a></div>建议使用BT下载工具Free Download Manager进行下载,简称FDM(免费,没有广告,支持多平台）。本站资源全部打包为BT种子。所以需要使用专业的BT下载软件进行下载。如BitComet qBittorrent uTorrent等BT下载工具。迅雷目前由于本站不是热门资源。不推荐使用！后期资源热门了。安装了迅雷也可以迅雷进行下载！<br><br><b>（文件页数 要大于 标注页数，上中下等多册电子书除外）</b><br><br><p style="color:red;"> <b>注意：本站所有压缩包均有解压码：</b> <a rel="nofollow" target="_blank"><b>点击下载压缩包解压工具</b></a></p></div><div class="tit"><h3>图书目录</h3></div><div id="book-contents"><p>第Ⅰ部分 预备知识1</p><p>第1章 ANSI C概述1</p><p>1.1 什么是C1</p><p>目录1</p><p>1.2 C程序的结构3</p><p>1.2.1 注释4</p><p>1.2.2 库包含5</p><p>1.2.3 程序级定义5</p><p>1.2.4 函数原型5</p><p>1.2.5 main程序6</p><p>1.3 变量、值和类型7</p><p>1.3.1 变量7</p><p>1.2.6 函数定义7</p><p>1.3.2 命名规则8</p><p>1.3.3 局部变量和全局变量9</p><p>1.3.4 数据类型的概念9</p><p>1.3.5 整数类型9</p><p>1.3.6 浮点类型10</p><p>1.3.7 文本类型11</p><p>1.3.8 布尔类型12</p><p>1.3.9 简单的输入与输出12</p><p>1.4 表达式14</p><p>1.4.1 优先级与结合性14</p><p>1.4.2 表达式中的类型混合15</p><p>1.4.3 整数除法和求余运算符16</p><p>1.4.5 赋值运算符17</p><p>1.4.4 类型转换17</p><p>1.4.6 递增与递减运算符19</p><p>1.4.7 布尔运算符20</p><p>1.5 语句22</p><p>1.5.1 简单语句22</p><p>1.5.2 块22</p><p>1.5.3 if语句23</p><p>1.5.4 switch语句23</p><p>1.5.5 while语句25</p><p>1.5.6 for语句28</p><p>1.6 函数29</p><p>1.6.1 返回函数结果29</p><p>1.6.3 函数调用过程的机制30</p><p>1.6.2 函数定义和原型30</p><p>1.6.4 逐步求精31</p><p>1.7 小结31</p><p>1.8 复习题32</p><p>1.9 编程练习33</p><p>第2章 C的数据类型38</p><p>2.1 枚举类型38</p><p>2.1.1 枚举类型的内部表示39</p><p>2.1.2 标量类型40</p><p>2.1.3 理解typedef41</p><p>2.2 数据和内存41</p><p>2.2.1 位、字节、字42</p><p>2.2.2 内存地址42</p><p>2.3.1 把地址当作数值44</p><p>2.3 指针44</p><p>2.3.2 声明指针变量45</p><p>2.3.3 基本的指针运算45</p><p>2.3.4 特殊指针NULL47</p><p>2.3.5 通过引用传递参数48</p><p>2.4 数组51</p><p>2.4.1 声明数组51</p><p>2.4.2 数组选择52</p><p>2.4.3 有效空间和已分配空间53</p><p>2.4.4 作为参数传递数组54</p><p>2.4.5 初始化数组56</p><p>2.4.6 多维数组57</p><p>2.5 指针和数组59</p><p>2.5.1 指针运算60</p><p>2.5.2 指针的自加和自减62</p><p>2.5.3 指针和数组的关系62</p><p>2.6 记录64</p><p>2.6.1 定义一种新的结构类型65</p><p>2.6.2 声明结构变量66</p><p>2.6.3 记录选择66</p><p>2.6.4 初始化纪录66</p><p>2.6.5 记录的指针67</p><p>2.7 动态分配68</p><p>2.7.1 类型void68</p><p>2.7.2 应对内存限制70</p><p>2.7.3 动态数组71</p><p>2.7.4 动态记录72</p><p>2.8 小结73</p><p>2.9 复习题74</p><p>2.10 编程练习76</p><p>第3章 库和接口83</p><p>3.1 接口的概念83</p><p>3.1.1 接口和实现84</p><p>3.1.2 包和抽象84</p><p>3.1.3 良好的接口设计规则85</p><p>3.2 随机数字85</p><p>3.2.1 random.h接口的结构86</p><p>3.2.2 构建客户程序89</p><p>3.2.3 有关随机数字的ANSI函数91</p><p>3.2.4 实现random.c93</p><p>3.3 字符串96</p><p>3.3.1 字符串的底层表示96</p><p>3.3.2 数据类型string97</p><p>3.3.3 ANSI字符串库98</p><p>3.3.4 接口strlib.h102</p><p>3.4 标准的I/O库108</p><p>3.4.1 数据文件108</p><p>3.4.2 在C中使用文件109</p><p>3.4.3 标准文件110</p><p>3.4.4 字符I/O110</p><p>3.4.5 从输入文件中重读字符111</p><p>3.4.6 更新文件112</p><p>3.4.7 面向行的I/O113</p><p>3.4.8 格式化的I/O114</p><p>3.4.9 scanf函数115</p><p>3.5 其他ANSI库116</p><p>3.6 小结118</p><p>3.7 复习题118</p><p>3.8 编程练习120</p><p>第Ⅱ部分 递归和算法分析127</p><p>第4章 递归入门127</p><p>4.1 一个简单的递归示例128</p><p>4.2 阶乘函数129</p><p>4.2.1 Fact的递归公式130</p><p>4.2.2 追踪递归过程130</p><p>4.3 费波那契函数134</p><p>4.2.3 递归跳跃的信任134</p><p>4.3.1 计算费波那契序列135</p><p>4.3.2 增进实现递归的信心136</p><p>4.3.3 递归实现的效率137</p><p>4.3.4 不应该责备递归138</p><p>4.4 其他递归示例139</p><p>4.4.1 探测回文139</p><p>4.4.2 二分查找142</p><p>4.4.3 交互递归143</p><p>4.5 以递归的方式思考144</p><p>4.5.1 保持整体观145</p><p>4.5.2 避免常见的错误145</p><p>4.6 小结146</p><p>4.7 复习题147</p><p>4.8 编程练习149</p><p>第5章 递归过程152</p><p>5.1 汉诺塔152</p><p>5.1.1 分解问题153</p><p>5.1.2 寻找递归策略153</p><p>5.1.3 验证递归策略155</p><p>5.1.4 解决方案的编码156</p><p>5.1.5 追踪递归过程156</p><p>5.2 产生排列160</p><p>5.3 递归在绘图中的应用162</p><p>5.3.1 图形库162</p><p>5.3.2 电脑艺术示例165</p><p>5.3.3 不规则碎片形169</p><p>5.4 小结173</p><p>5.5 复习题174</p><p>5.6 编程练习175</p><p>第6章 回溯算法183</p><p>6.1 用递归回溯解决迷宫问题183</p><p>6.1.1 右手规则183</p><p>6.1.2 寻找递归方法184</p><p>6.1.3 识别简单情景185</p><p>6.1.4 编写迷宫解决方案算法186</p><p>6.1.5 确信解决方案可以正确运行190</p><p>6.2 回溯与游戏192</p><p>6.2.1 拿子游戏193</p><p>6.2.2 常规化的双人游戏程序199</p><p>6.2.3 最小最大策略200</p><p>6.2.4 实现最小最大化算法202</p><p>6.2.5 在具体的游戏中采用常规策略204</p><p>6.3 小结216</p><p>6.4 复习题217</p><p>6.5 编程练习218</p><p>第7章 算法分析225</p><p>7.1 排序问题225</p><p>7.1.1 选择排序算法226</p><p>7.1.2 性能的经验度量227</p><p>7.1.3 分析选择排序的性能228</p><p>7.2.2 大O的标准简化230</p><p>7.2.1 大O符号230</p><p>7.2 计算复杂度230</p><p>7.2.3 排序算法的计算复杂度231</p><p>7.2.4 根据代码结构预测计算复杂度232</p><p>7.2.5 最差情况复杂度与平均情况复杂度233</p><p>7.2.6 大O的正式定义233</p><p>7.3 递归帮助235</p><p>7.3.1 分治策略的威力235</p><p>7.3.2 合并两个数组236</p><p>7.3.3 合并排序算法237</p><p>7.3.4 合并排序的计算复杂度239</p><p>7.3.5 比较N2和NlogN的性能240</p><p>7.4 标准复杂度类型241</p><p>7.5 快速排序算法242</p><p>7.5.1 分割数组244</p><p>7.5.2 分析快速排序的性能246</p><p>7.6 数学归纳法247</p><p>7.7 小结250</p><p>7.8 复习题250</p><p>7.9 编程练习252</p><p>第Ⅲ部分 数据抽象257</p><p>第8章 抽象数据类型257</p><p>8.1 堆栈258</p><p>8.1.1 基本的堆栈比喻258</p><p>8.1.2 堆栈和函数调用258</p><p>8.2 定义堆栈的ADT259</p><p>8.1.3 堆栈和袖珍计算器259</p><p>8.2.1 定义堆栈抽象的类型260</p><p>8.2.2 不透明类型261</p><p>8.2.3 定义stack.h接口262</p><p>8.3 在应用程序中使用堆栈265</p><p>8.4 实现堆栈抽象269</p><p>8.4.1 定义具体类型269</p><p>8.4.2 实现堆栈操作269</p><p>8.4.3 不透明类型的优点271</p><p>8.4.4 改进stack.c的实现272</p><p>8.5 定义扫描器ADT273</p><p>8.5.1 封装状态的危险274</p><p>8.5.2 抽象数据类型作为封装状态的替代274</p><p>8.5.3 实现扫描器抽象279</p><p>8.6 小结283</p><p>8.7 复习题284</p><p>8.8 编程练习285</p><p>第9章 效率与ADT297</p><p>9.1 编辑器缓冲区的概念297</p><p>9.2 定义缓冲区抽象298</p><p>9.2.1 接口buffer.h中的函数299</p><p>9.2.2 为编辑器应用程序编写代码301</p><p>9.3 用数组实现编辑器303</p><p>9.3.1 定义具体类型303</p><p>9.3.2 实现缓冲区的操作304</p><p>9.3.3 数组实现的计算复杂度308</p><p>9.4 用堆栈实现编辑器309</p><p>9.4.1 定义基于堆栈的缓冲区的具体结构310</p><p>9.4.2 实现缓冲区的操作310</p><p>9.4.3 比较计算复杂度313</p><p>9.5 用链表实现编辑器313</p><p>9.5.1 链表的概念314</p><p>9.5.2 设计链表数据结构314</p><p>9.5.3 使用链表表示缓冲区316</p><p>9.5.4 链表缓冲区中的插入317</p><p>9.5.5 链表缓冲区中的删除320</p><p>9.5.6 链表表示中的光标移动321</p><p>9.5.7 链表的习惯用法323</p><p>9.5.8 完成缓冲区实现324</p><p>9.5.10 双向链表328</p><p>9.5.9 链表缓冲区的计算复杂度328</p><p>9.5.11 时间-空间的权衡329</p><p>9.6 小结329</p><p>9.7 复习题330</p><p>9.8 编程练习331</p><p>第10章 线性结构337</p><p>10.1 堆栈回顾337</p><p>10.2 队列344</p><p>10.2.1 接口queue.h的结构344</p><p>10.2.2 基于数组的队列实现347</p><p>10.2.3 队列的链表实现351</p><p>10.3 使用队列的仿真355</p><p>10.3.3 离散时间356</p><p>10.3.2 排队模型356</p><p>10.3.1 仿真与模型356</p><p>10.3.4 仿真时间中的事件357</p><p>10.3.5 实现仿真357</p><p>10.4 小结364</p><p>10.5 复习题365</p><p>10.6 编程练习366</p><p>第11章 符号表371</p><p>11.1 定义符号表抽象371</p><p>11.1.1 选择值和键的类型372</p><p>11.1.2 表示未定义项373</p><p>11.1.3 符号表接口的初始版本373</p><p>11.2 散列375</p><p>11.2.1 实现散列表策略375</p><p>11.2.2 选择散列函数380</p><p>11.2.3 确定桶的数量381</p><p>11.3 初级接口的限制382</p><p>11.4 使用函数作为数据384</p><p>11.4.1 通用绘图函数384</p><p>11.4.2 声明函数指针与函数类385</p><p>11.4.3 实现PlotFunction386</p><p>11.4.4 qsort函数387</p><p>11.5 映射函数391</p><p>11.5.1 映射符号表中的所有项391</p><p>11.5.2 实现MapSymbolTable394</p><p>11.5.3 向回调函数传递客户数据395</p><p>11.6.1 使用迭代器396</p><p>11.6 迭代器396</p><p>11.6.2 定义迭代器接口397</p><p>11.6.3 实现针对符号表的迭代器抽象398</p><p>11.7 命令分派表401</p><p>11.8 小结404</p><p>11.9 复习题405</p><p>11.10 编程练习406</p><p>第Ⅳ部分 递归数据411</p><p>第12章 递归链表411</p><p>12.1 链表的递归表述412</p><p>12.2 定义抽象链表类型413</p><p>12.2.1 不变类型416</p><p>12.2.2 操纵链表结构的函数417</p><p>12.2.3 连接多个链表419</p><p>12.2.4 不变类型间的内部共享421</p><p>12.3 使用链表表示大整数422</p><p>12.3.1 bigint.h接口423</p><p>12.3.2 表示类型bigIntADT425</p><p>12.3.3 实现bigint包426</p><p>12.3.4 使用bigint.h包430</p><p>12.4 小结432</p><p>12.5 复习题433</p><p>12.6 编程练习434</p><p>第13章 树438</p><p>13.1 家谱树438</p><p>13.1.2 树的递归特性439</p><p>13.1.1 描述树的术语439</p><p>13.1.3 用C语言表示家谱树440</p><p>13.2 二叉搜索树441</p><p>1 3.2.1 使用二叉搜索树的底层动机442</p><p>13.2.2 在二叉搜索树中查找节点443</p><p>13.2.3 在二叉搜索树中插入新节点444</p><p>13.2.4 树的遍历447</p><p>13.3 平衡树449</p><p>13.3.1 树的平衡策略450</p><p>13.3.2 举例说明AVL的思想451</p><p>13.3.3 单旋转452</p><p>13.3.4 双旋转454</p><p>13.3.5 实现AVL算法455</p><p>13.4 为二叉搜索树定义通用接口458</p><p>13.4.1 允许客户定义节点结构462</p><p>13.4.2 泛化键的类型465</p><p>13.4.3 删除节点465</p><p>13.4.4 实现二叉搜索树包467</p><p>13.4.5 使用二叉树实现symtab.h接口472</p><p>13.5 小结474</p><p>13.6 复习题474</p><p>13.7 编程练习477</p><p>第14章 表达式树484</p><p>14.1 解释器概述484</p><p>14.2 表达式的抽象结构487</p><p>14.2.1 表达式的递归定义487</p><p>14.2.2 歧义性488</p><p>14.2.3 表达式树489</p><p>14.2.4 定义表达式的抽象接口490</p><p>14.3 定义具体表达式类型494</p><p>14.3.1 联合类型494</p><p>14.3.2 用带标记联合表示表达式496</p><p>14.3.3 可视化具体表示498</p><p>14.3.4 实现构造器和选择器函数500</p><p>14.4 分析表达式502</p><p>14.4.1 语法分析和语法502</p><p>14.4.2 不考虑优先级的语法分析503</p><p>14.4.3 在语法分析器中加入优先级507</p><p>14.5 计算表达式509</p><p>14.6 小结511</p><p>14.7 复习题512</p><p>14.8 编程练习513</p><p>第15章 集合525</p><p>15.1 作为数学抽象的集合525</p><p>15.1.1 成员资格526</p><p>15.1.2 集合运算526</p><p>15.1.3 集合恒等式527</p><p>15.2 设计集合接口529</p><p>15.2.1 定义元素类型529</p><p>15.2.2 编写set.h接口531</p><p>15.2.3 字符集合534</p><p>15.2.4 使用指针集合来避免重复535</p><p>15.3 实现集合包537</p><p>15.4.1 泛化迭代器函数的原型544</p><p>15.4 设计多态迭代器544</p><p>15.4.2 在迭代器中实现多态性545</p><p>15.4.3 导出聚集类型546</p><p>15.4.4 编码迭代器包550</p><p>15.4.5 foreach的习惯用法554</p><p>15.5 提高整数集合的效率554</p><p>15.5.1 特征向量555</p><p>15.5.2 压缩的位数组555</p><p>15.5.3 位运算符556</p><p>15.5.4 使用位运算符实现特征向量559</p><p>15.5.5 实现高级集合操作561</p><p>15.5.6 使用混合实现561</p><p>15.6 小结561</p><p>15.7 复习题563</p><p>15.8 编程练习565</p><p>第16章 图570</p><p>16.1 图的结构570</p><p>16.1.1 有向图和无向图572</p><p>16.1.2 路径和环573</p><p>16.1.3 连通性573</p><p>16.2 图的实现策略574</p><p>16.2.1 使用邻接列表表示连接575</p><p>16.2.2 使用邻接矩阵表示连接578</p><p>16.3 扩展图抽象581</p><p>16.3.1 将数据与节点和图关联581</p><p>16.3.2 显式弧581</p><p>16.3.3 迭代和图582</p><p>16.3.4 分层抽象583</p><p>16.3.5 基于集合的图接口584</p><p>16.4 图的遍历592</p><p>16.4.1 深度优先遍历593</p><p>16.4.2 广度优先搜索595</p><p>16.5 寻找最短路径597</p><p>16.6 小结604</p><p>16.7 复习题605</p><p>16.8 编程练习607</p><p>第17章 展望Java614</p><p>17.1 面向对象范式614</p><p>17.1.1 面向对象编程的历史615</p><p>17.1.3 类层次结构与继承616</p><p>17.1.2 对象、类和方法616</p><p>17.2 Java简介618</p><p>17.2.1 Web结构618</p><p>17.2.2 applet619</p><p>17.2.3 执行Java applet623</p><p>17.3 Java结构624</p><p>17.3.1 Java的语法625</p><p>17.3.2 Java中的原子类型626</p><p>17.3.3 定义一个新类626</p><p>17.3.4 构造器方法628</p><p>17.3.5 this关键字628</p><p>17.3.6 定义方法629</p><p>17.3.7 定义子类631</p><p>17.4.1 String类637</p><p>17.4 Java中的预定义类637</p><p>17.4.2 Hashtable类638</p><p>17.4.3 原子类型的对象包装器641</p><p>17.4.4 Vector类641</p><p>17.4.5 Stack类643</p><p>17.5 创建交互式applet的工具644</p><p>17.5.1 组件与容器644</p><p>17.5.2 action方法645</p><p>17.5.3 用于绘制简单图形的applet646</p><p>17.5.4 更进一步654</p><p>17.6 小结654</p><p>17.8 复习题654</p><p>17.9 编程练习656</p><p></p></div></div><div class="d-rt"><h3>热门推荐</h3><ul><li><a href="/book/2680166.html">2680166.html</a></li><li><a href="/book/2076634.html">2076634.html</a></li><li><a href="/book/3204887.html">3204887.html</a></li><li><a href="/book/3115592.html">3115592.html</a></li><li><a href="/book/3172470.html">3172470.html</a></li><li><a href="/book/2752294.html">2752294.html</a></li><li><a href="/book/3057699.html">3057699.html</a></li><li><a href="/book/1569799.html">1569799.html</a></li><li><a href="/book/2277062.html">2277062.html</a></li><li><a href="/book/2538615.html">2538615.html</a></li></ul></div></div><div id="footer"><p>Copyright&nbsp;&copy;&nbsp;2025&nbsp;&nbsp;<a href="/list/">最新更新</a></p><p>请使用FDM BitComet qBittorrent uTorrent等BT下载工具，下载本站电子书资源！首推Free Download Manager下载软件。文件页数>标注页数[分册图书除外]</p></div></body></html>