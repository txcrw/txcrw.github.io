<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><script type="text/javascript" src="https://file.bkxsj.com/skin/book/js/sk.js"></script><meta name="robots" content="index,follow"><title>计算机系统 英文版[PDF|Epub|txt|kindle电子书版本网盘下载]-灵感之桥</title><meta name="Keywords" content="计算机系统 英文版"/><meta name="description" content="计算机系统 英文版pdf下载文件大小为119MB,PDF页数为40072383页"/><meta http-equiv="X-UA-Compatible" content="IE=9; IE=8; IE=7; IE=EDGE;chrome=1"><link type="image/x-icon" rel="shortcut icon" href="https://www.shukui.net/skin/book/images/favicon.ico"><link type="text/css" rel="stylesheet" href="https://www.shukui.net/skin/book/css/style.css"><style>#main .d-main {margin-left: 0;width: 620px;}.down-btn {animation: myShake 2.5s linear .15s infinite}@keyframes myShake {0%, 66% {transform: translateZ(0)}67%, 73.6%, 83.6%, 93.6%, to {animation-timing-function: cubic-bezier(.215, .61, .355, 1);transform: translateZ(0)}80.3%, 81.4% {animation-timing-function: cubic-bezier(.755, .05, .855, .06);transform: translate3d(0, -4px, 0)}90.3% {animation-timing-function: cubic-bezier(.755, .05, .855, .06);transform: translate3d(0, -2px, 0)}97% {transform: translate3d(0, -.5px, 0)}}.copylink-btn {margin-right: 20px;}.copymd5-btn {margin-bottom: 25px;margin-left: 10px;}</style></head><body><div id="header"><div class="inner"><div class="logo"><a href="/"><img width="103" height="25" alt="灵感之桥"src="https://www.shukui.net/skin/book/images/logo.png"></a></div><div class="search"><form action="/so/search.php" target="_blank"><input type="text" autocomplete="off" id="bdcsMain" name="q" placeholder="书名 / 作者 / 出版社 / ISBN"class="inp-txt"><select class="inp-select" id="datasource" onchange="selectDatasource(this)"><option value="so">主库</option><option value="s">从库</option></select><input type="submit" value="搜索" class="inp-btn"></form></div></div></div><div id="main"><div class="d-main"><div class="tit"><h3>图书介绍</h3></div><h1 class="book-name">计算机系统 英文版PDF|Epub|txt|kindle电子书版本网盘下载</h1><div class="d-info"><div class="b-thumb"><img src="https://www.shukui.net/cover/36/31800403.jpg" alt="计算机系统 英文版"></div><div class="b-info"><ul><li>（美）布赖恩特（Bryant，R.E.）等著 著</li><li>出版社： 北京：电子工业出版社</li><li>ISBN：7505396242</li><li>出版时间：2004</li><li>标注页数：978页</li><li>文件大小：119MB</li><li>文件页数：40072383页</li><li>主题词：计算机系统－教材－英文</li></ul></div></div><div class="tit"><h3>PDF下载</h3></div><div></br><a style="color:red;" rel="external nofollow" href="https://www.kjlm.net/ebook/1544328.html"target="_blank"><b>点此进入-本书在线PDF格式电子书下载【推荐-云解压-方便快捷】直接下载PDF格式图书。移动端-PC端通用</a></b></br><a class="down-btn" rel="external nofollow" href="https://down.trackerbk.com/bt/file/k0/5278f0a5.pdf.torrent"target="_blank">种子下载</a>[BT下载速度快]温馨提示：（请使用BT下载软件FDM进行下载）<a rel="nofollow" href="https://www.freedownloadmanager.org/zh/" target="_blank">软件下载地址页</a><a class="down-btn" rel="external nofollow" href="https://down.p2spdb.com/file/k0/5278f0a5.pdf.rar" target="_blank">直链下载</a>[便捷但速度慢]&nbsp;&nbsp;<a style="color:red;" rel="external nofollow" href="https://pdfyl.ertongbook.com/35/31800403.pdf" target="_blank"><b>[在线试读本书]</b></a>&nbsp;&nbsp;<b> <a style="color:red;" rel="external nofollow" href="https://web.jyjl.org/index/recovery.html" target="_blank">[在线获取解压码]</a></b><div class="copymd5-btn"><a href="javascript:copyToClip('')">点击复制MD5值：</a></div></div><div class="tit"><h3>下载说明</h3></div><div style="margin:20px 10px"><h2>计算机系统 英文版PDF格式电子书版下载</h2>下载的文件为RAR压缩包。需要使用解压软件进行解压得到PDF格式图书。<br><br><div class="copymd5-btn"><a href="javascript:copyToClip('magnet:?xt=urn:btih:RX6G6JQ2LJW7PBBEDNUSCQM7ICDMHIWK')">点击复制85GB完整离线版磁力链接到迅雷FDM等BT下载工具进行下载</a>&nbsp;&nbsp;<a rel="nofollow" target="_blank">详情点击-查看共享计划</a></div>建议使用BT下载工具Free Download Manager进行下载,简称FDM(免费,没有广告,支持多平台）。本站资源全部打包为BT种子。所以需要使用专业的BT下载软件进行下载。如BitComet qBittorrent uTorrent等BT下载工具。迅雷目前由于本站不是热门资源。不推荐使用！后期资源热门了。安装了迅雷也可以迅雷进行下载！<br><br><b>（文件页数 要大于 标注页数，上中下等多册电子书除外）</b><br><br><p style="color:red;"> <b>注意：本站所有压缩包均有解压码：</b> <a rel="nofollow" target="_blank"><b>点击下载压缩包解压工具</b></a></p></div><div class="tit"><h3>图书目录</h3></div><div id="book-contents"><p>1 A Tour of Computer Systems1</p><p>1.1 Information is Bits＋Context2</p><p>1.2 Programs Are Translated by Other Programs into Different Forms4</p><p>1.3 It Pays to Understand How Compilation Systems Work6</p><p>1.4 Processors Read and Interpret Instructions Stored in Memory6</p><p>1.4.1 Hardware Organization of a System7</p><p>1.4.2 Running the he ll o Program9</p><p>1.5 Caches Matter11</p><p>1.6 Storage Devices Form a Hierarchy12</p><p>1.7 The Operating System Manages the Hardware13</p><p>1.7.1 Processes15</p><p>1.7.2 Threads16</p><p>1.7.3 Virtual Memory16</p><p>1.7.4 Files18</p><p>1.8 Systems Communicate With Other Systems Using Networks18</p><p>1.9 The Next Step20</p><p>1.10 Summary20</p><p>Bibliographics Notes21</p><p>Part Ⅰ Program Structure and Execution24</p><p>2 Representing and Manipulating Information24</p><p>2.1 Information Storage28</p><p>2.1.1 Hexadecimal Notation28</p><p>2.1.2 Words32</p><p>2.1.3 Data Sizes32</p><p>2.1.4 Addressing and Byte Ordering34</p><p>2.1.5 Representing Strings40</p><p>2.1.6 Representing Code41</p><p>2.1.7 Boolean Algebras and Rings42</p><p>2.1.8 Bit-Level Operations in C46</p><p>2.1.9 Logical Operations in C49</p><p>2.1.10 Shift Operations in C50</p><p>2.2 Integer Representations51</p><p>2.2.1 Integral Data Types51</p><p>2.2.2 Unsigned and Twvo's-Complement Encodings51</p><p>2.2.3 Conversions Between Signed and Unsigned56</p><p>2.2.4 Signed vs. Unsigned in C59</p><p>2.2.5 Expanding the Bit Representation of a Number61</p><p>2.2.6 Truncating Numbers63</p><p>2.2.7 Advice on Signed vs.Unsigned65</p><p>2.3 Integer Arithmetic65</p><p>2.3.1 Unsigned Addition66</p><p>2.3.2 Twvo's-Complement Addition69</p><p>2.3.3 Twvo's-Complement Negation72</p><p>2.3.4 Unsigned Multiplication74</p><p>2.3.5 Two's-Complement Multiplication75</p><p>2.3.6 Multiplying by Powers of Two76</p><p>2.3.7 Dividing by Powers of Two77</p><p>2.4 Floating Point80</p><p>2.4.1 Fractional Binary Numbers81</p><p>2.4.2 IEEE Floating-Point Representation83</p><p>2.4.3 Example Numbers85</p><p>2.4.4 Rounding89</p><p>2.4.5 Floating-Point Operations91</p><p>2.4.6 Floating Point in C92</p><p>2.5 Summary98</p><p>Bibliographic Notes99</p><p>Homework Problems99</p><p>Solution to Practice Problems108</p><p>3 Machine-Level Representation of Programs122</p><p>3.1 A Historical Perspective125</p><p>3.2 Program Encodings128</p><p>3.2.1 Machine-Level Code129</p><p>3.2.2 Code Examples130</p><p>3.2.3 A Note on Formatting133</p><p>3.3 Data Formats135</p><p>3.4 Accessing Information136</p><p>3.4.1 Operand Specifiers137</p><p>3.4.2 Data Movement Instructions138</p><p>3.4.3 Data Movement Example141</p><p>3.5 Arithmetic and Logical Operations143</p><p>3.5.1 Load Effective Address143</p><p>3.5.2 Unary and Binary Operations144</p><p>3.5.3 Shift Operations145</p><p>3.5.4 Discussion146</p><p>3.5.5 Special Arithmetic Operations147</p><p>3.6 Control148</p><p>3.6.1 Condition Codes149</p><p>3.6.2 Accessing the Condition Codes150</p><p>3.6.3 Jump Instructions and their Encodings152</p><p>3.6.4 Translating Conditional Branches156</p><p>3.6.5 Loops158</p><p>3.6.6 Switch Statements166</p><p>3.7 Procedures170</p><p>3.7.1 Stack Frame Structure170</p><p>3.7.2 Transferring Control172</p><p>3.7.3 Register Usage Conventions173</p><p>3.7.4 Procedure Example174</p><p>3.7.5 Recursive Procedures178</p><p>3.8 Array Allocation and Access180</p><p>3.8.1 Basic Principles180</p><p>3.8.2 Pointer Arithmetic182</p><p>3.8.3 Arrays and Loops183</p><p>3.8.4 Nested Arrays183</p><p>3.8.5 Fixed Size Arrays186</p><p>3.8.6 Dynamically Allocated Arrays188</p><p>3.9 Heterogeneous Data Structures191</p><p>3.9.1 Structures191</p><p>3.9.2 Unions194</p><p>3.10 Alignment198</p><p>3.11 Putting it Together: Understanding Pointers201</p><p>3.12 Life in the Real World: Using the GDB Debugger204</p><p>3.13 Out-of-Bounds Memory References and Buffer Overflow206</p><p>3.14 Floating-Point Code211</p><p>3.14.1 Floating-Point Registers211</p><p>3.14.2 Stack Evaluation of Expressions212</p><p>3.14.3 Floating-Point Data Movement and Conversion Operations215</p><p>3.14.4 Floating-Point Arithmetic Instructions217</p><p>3.14.5 Using Floating Point in Procedures220</p><p>3.14.6 Testing and Comparing Floating-Point Values221</p><p>3.15 Embedding Assembly Code in C Programs223</p><p>3.15.1 Basic Inline Assembly224</p><p>3.15.2 Extended Form of asm226</p><p>3.16 Summary230</p><p>Bibliographic Notes231</p><p>Homework Problems231</p><p>Solutions to Practice Problems238</p><p>4 Processor Architecture254</p><p>4.1 The Y86 Instruction Set Architecture258</p><p>4.2 Logic Design and the Hardware Control Language HCL271</p><p>4.2.1 Logic Gates271</p><p>4.2.2 Combinational Circuits and HCL Boolean Expressions272</p><p>4.2.3 Word-Level Combinational Circuits and HCL Integer Expressions274</p><p>4.2.4 Set Membership278</p><p>4.2.5 Memory and Clocking279</p><p>4.3 Sequential Y86 Implementations280</p><p>4.3.1 Organizing Processing into Stages281</p><p>4.3.2 SEQ Hardware Structure291</p><p>4.3.3 SEQ Timing295</p><p>4.3.4 SEQ Stage Implementations298</p><p>4.3.5 SEQ+: Rearranging the Computation Stages305</p><p>4.4 General Principles of Pipelining309</p><p>4.4.1 Computational Pipelines309</p><p>4.4.2 A Detailed Look at Pipeline Operation311</p><p>4.4.3 Limitations of Pipelining313</p><p>4.4.4 Pipelining a System with Feedback315</p><p>4.5 Pipelined Y86 Implementations317</p><p>4.5.1 Inserting Pipeline Registers317</p><p>4.5.2 Rearranging and Relabeling Signals321</p><p>4.5.3 Next PC Prediction322</p><p>4.5.4 Pipeline Hazards323</p><p>4.5.5 Avoiding Data Hazards by Stalling328</p><p>4.5.6 Avoiding Data Hazards by Forwarding330</p><p>4.5.7 Load/Use Data Hazards335</p><p>4.5.8 PIPE Stage Implementations337</p><p>4.5.9 Pipeline Control Logic343</p><p>4.5.10 Performance Analysis352</p><p>4.5.11 Unfinished Business354</p><p>4.6 Summary359</p><p>4.6.1 Y86 Simulators360</p><p>Bibliographic Notes360</p><p>Homework Problems360</p><p>Solutions to Practice Problems365</p><p>5 Optimizing Program Performance376</p><p>5.1 Capabilities and Limitations of Optimizing Compilers379</p><p>5.2 Expressing Program Performance382</p><p>5.3 Program Example384</p><p>5.4 Eliminating Loop Inefficiencies387</p><p>5.5 Reducing Procedure Calls391</p><p>5.6 Eliminating Unneeded Memory References393</p><p>5.7 Understanding Modern Processors395</p><p>5.7.1 Overall Operation395</p><p>5.7.2 Functional Unit Performance399</p><p>5.7.3 A Closer Look at Processor Operation400</p><p>5.8 Reducing Loop Overhead408</p><p>5.9 Converting to Pointer Code412</p><p>5.10 Enhancing Parallelism415</p><p>5.10.1 Loop Splitting415</p><p>5.10.2 Register Spilling420</p><p>5.10.3 Limits to Parallelism421</p><p>5.11 Putting it Together: Summary of Results for Optimizing Combining Code423</p><p>5.11.1 Floating-Point Performance Anomaly423</p><p>5.11.2 Changing Platforms425</p><p>5.12 Branch Prediction and Misprediction Penalties425</p><p>5.13 Understanding Memory Performance429</p><p>5.13.1 Load Latency429</p><p>5.13.2 Store Latency431</p><p>5.14 Life in the Real World: Performance Improvement Techniques436</p><p>5.15 Identifying and Eliminating Performance Bottlenecks437</p><p>5.15.1 Program Profiling437</p><p>5.15.2 Using a Profiler to Guide Optimization439</p><p>5.15.3 Amdahl's Law443</p><p>5.16 Summary444</p><p>Bibliographic Notes445</p><p>Homework Problems445</p><p>Solutions to Practice Problems450</p><p>6 The Memory Hierarchy454</p><p>6.1 Storage Technologies457</p><p>6.1.1 Random-Access Memory457</p><p>6.1.2 Disk Storage464</p><p>6.1.3 Storage Technology Trends476</p><p>6.2 Locality478</p><p>6.2.1 Locality of References to Program Data478</p><p>6.2.2 Locality of Instruction Fetches480</p><p>6.2.3 Summary of Locality481</p><p>6.3 The Memory Hierarchy482</p><p>6.3.1 Caching in the Memory Hierarchy484</p><p>6.3.2 Summary of Memory Hierarchy Concepts486</p><p>6.4 Cache Memories487</p><p>6.4.1 Generic Cache Memory Organization488</p><p>6.4.2 Direct-Mapped Caches490</p><p>6.4.3 Set Associative Caches497</p><p>6.4.4 Fully Associative Caches499</p><p>6.4.5 Issues with Writes503</p><p>6.4.6 Instruction Caches and Unified Caches504</p><p>6.4.7 Performance Impact of Cache Parameters505</p><p>6.5 Writing Cache-Friendly Code507</p><p>6.6 Putting it Together: The Impact of Caches on Program Performance511</p><p>6.6.1 The Memory Mountain512</p><p>6.6.2 Rearranging Loops to Increase Spatial Locality517</p><p>6.6.3 Using Blocking to Increase Temporal Locality520</p><p>6.7 Putting It Together: Exploiting Locality in Your Programs523</p><p>6.8 Summary524</p><p>Bibliographic Notes524</p><p>Homework Problems525</p><p>Solutions to Practice Problems531</p><p>Part Ⅱ Running Programs on a System538</p><p>7 Linking538</p><p>7.1 Compiler Drivers541</p><p>7.2 Static Linking542</p><p>7.3 Object Files543</p><p>7.4 Relocatable Object Files544</p><p>7.5 Symbols and Symbol Tables545</p><p>7.6 Symbol Resolution548</p><p>7.6.1 How Linkers Resolve Multiply Defined Global Symbols549</p><p>7.6.2 Linking with Static Libraries553</p><p>7.6.3 How Linkers Use Static Libraries to Resolve References556</p><p>7.7 Relocation557</p><p>7.7.1 Relocation Entries558</p><p>7.7.2 Relocating Symbol References558</p><p>7.8 Executable Object Files561</p><p>7.9 Loading Executable Object Files564</p><p>7.10 Dynamic Linking with Shared Libraries566</p><p>7.11 Loading and Linking Shared Libraries from Applications568</p><p>7.12 Position-Independent Code （PIC）570</p><p>7.12.1 PIC Data References572</p><p>7.12.2 PIC Function Calls572</p><p>7.13 Tools for Manipulating Object Files574</p><p>7.14 Summary575</p><p>Bibliographic Notes575</p><p>Homework Problems576</p><p>Solutions to Practice Problems582</p><p>8 Exceptional Control Flow584</p><p>8.1 Exceptions587</p><p>8.1.1 Exception Handling588</p><p>8.1.2 Classes of Exceptions590</p><p>8.1.3 Exceptions in Intel Processors592</p><p>8.2 Processes594</p><p>8.2.1 Logical Control Flow594</p><p>8.2.2 Private Address Space595</p><p>8.2.3 User and Kernel Modes596</p><p>8.2.4 Context Switches597</p><p>8.3 System Calls and Error Handling599</p><p>8.4 Process Control600</p><p>8.4.1 Obtaining Process ID's600</p><p>8.4.2 Creating and Terminating Processes600</p><p>8.4.3 Reaping Child Processes605</p><p>8.4.4 Putting Processes to Sleep610</p><p>8.4.5 Loading and Running Programs611</p><p>8.4.6 Using fork and execve to Run Programs614</p><p>8.5 Signals617</p><p>8.5.1 Signal Terminology617</p><p>8.5.2 Sending Signals619</p><p>8.5.3 Receiving Signals623</p><p>8.5.4 Signal Handling Issues625</p><p>8.5.5 Portable Signal Handling631</p><p>8.5.6 Explicitly Blocking Signals633</p><p>8.6 Nonlocal Jumps635</p><p>8.7 Tools for Manipulating Processes638</p><p>8.8 Summary638</p><p>Bibliographic Notes639</p><p>Homework Problems639</p><p>Solutions to Practice Problems645</p><p>9 Measuring Program Execution Time650</p><p>9.1 The Flow of Time on a Computer System653</p><p>9.1.1 Process Scheduling and Timer Interrupts654</p><p>9.1.2 Time from an Application Program's Perspective655</p><p>9.2 Measuring Time by Interval Counting658</p><p>9.2.1 Operation658</p><p>9.2.2 Reading the Process Timers659</p><p>9.2.3 Accuracy of Process Timers660</p><p>9.3 Cycle Counters663</p><p>9.3.1 IA32 Cycle Counters663</p><p>9.4 Measuring Program Execution Time with Cycle Counters665</p><p>9.4.1 The Effects of Context Switching665</p><p>9.4.2 Caching and Other Effects667</p><p>9.4.3 The K -Best Measurement Scheme671</p><p>9.5 Time-of-Day Measurements680</p><p>9.6 Putting it Together: An Experimental Protocol683</p><p>9.7 Looking into the Future684</p><p>9.8 Life in the Real World: An Implementation of the K -Best Measurement Scheme684</p><p>9.9 Lessons Learned685</p><p>9.10 Summary686</p><p>Bibliographic Notes686</p><p>Homework Problems687</p><p>Solutions to Practice Problems688</p><p>10 Virtual Memory690</p><p>10.1 Physical and Virtual Addressing693</p><p>10.2 Address Spaces694</p><p>10.3 VM as a Tool for Caching695</p><p>10.3.1 DRAM Cache Organization696</p><p>10.3.2 Page Tables696</p><p>10.3.3 Page Hits698</p><p>10.3.4 Page Faults698</p><p>10.3.5 Allocating Pages700</p><p>10.3.6 Locality to the Rescue Again700</p><p>10.4 VM as a Tool for Memory Management701</p><p>10.4.1 Simplifying Linking701</p><p>10.4.2 Simplifying Sharing702</p><p>10.4.3 Simplifying Memory Allocation702</p><p>10.4.4 Simplifying Loading703</p><p>10.5 VM as a Tool for Memory Protection703</p><p>10.6 Address Translation704</p><p>10.6.1 Integrating Caches and VM707</p><p>10.6.2 Speeding up Address Translation with a TLB707</p><p>10.6.3 Multi-Level Page Tables709</p><p>10.6.4 Putting it Together: End-to-End Address Translation711</p><p>10.7 Case Study: The Pentium/Linux Memory System715</p><p>10.7.1 Pentium Address Translation716</p><p>10.7.2 Linux Virtual Memory System721</p><p>10.8 Memory Mapping724</p><p>10.8.1 Shared Objects Revisited725</p><p>10.8.2 The fork Function Revisited727</p><p>10.8.3 The execve Function Revisited727</p><p>10.8.4 User-Level Memory Mapping with the mmap Function728</p><p>10.9 Dynamic Memory Allocation730</p><p>10.9.1 The malloc and free Functions731</p><p>10.9.2 Why Dynamic Memory Allocation?733</p><p>10.9.3 Allocator Requirements and Goals735</p><p>10.9.4 Fragmentation736</p><p>10.9.5 Implementation Issues737</p><p>10.9.6 Implicit Free Lists737</p><p>10.9.7 Placing Allocated Blocks739</p><p>10.9.8 Splitting Free Blocks740</p><p>10.9.9 Getting Additional Heap Memory740</p><p>10.9.10 Coalescing Free Blocks741</p><p>10.9.11 Coalescing with Boundary Tags741</p><p>10.9.12 Putting it Together: Implementing a Simple Allocator744</p><p>10.9.13 Explicit Free Lists751</p><p>10.9.14 Segregated Free Lists752</p><p>10.10 Garbage Collection755</p><p>10.10.1 Garbage Collector Basics756</p><p>10.10.2 Mark&amp;Sweep Garbage Collectors757</p><p>10.10.3 Conservative Mark&amp;Sweep for C Programs758</p><p>10.11 Common Memory-Related Bugs in C Programs759</p><p>10.11.1 Dereferencing Bad Pointers759</p><p>10.11.2 Reading Uninitialized Memory760</p><p>10.11.3 Allowing Stack Buffer Overflows760</p><p>10.11.4 Assuming that Pointers and the Objects they Point to Are the Same Size761</p><p>10.11.5 Making Off-by-One Errors761</p><p>10.11.6 Referencing a Pointer Instead of the Object it Points to762</p><p>10.11.7 Misunderstanding Pointer Arithmetic762</p><p>10.11.8 Referencing Nonexistent Variables763</p><p>10.11.9 Referencing Data in Free Heap Blocks763</p><p>10.11.10 Introducing Memory Leaks764</p><p>10.12 Recapping Some Key Ideas About Virtual Memory764</p><p>10.13 Summary764</p><p>Bibliographic Notes765</p><p>Homework Problems766</p><p>Solutions to Practice Problems770</p><p>Part Ⅲ Interaction and Communication Between Programs776</p><p>11 System-Level I/O776</p><p>11.1 Unix I/O778</p><p>11.2 Opening and Closing Files779</p><p>11.3 Reading and Writing Files781</p><p>11.4 Robust Reading and Writing with the RIo Package783</p><p>11.4.1 RIo Unbuffered Input and Output Functions783</p><p>11.4.2 RIo Buffered Input Functions784</p><p>11.5 Reading File Metadata789</p><p>11.6 Sharing Files791</p><p>11.7 I/O Redirection793</p><p>11.8 Standard I/O795</p><p>11.9 Putting It Together: Which I/O Functions Should I Use?796</p><p>11.10 Summary797</p><p>Bibliographic Notes798</p><p>Homework Problems798</p><p>12 Network Programming800</p><p>12.1 The Client-Server Programming Model802</p><p>12.2 Networks803</p><p>12.3 The Global IP Internet807</p><p>12.3.1 IP Addresses809</p><p>12.3.2 Internet Domain Names811</p><p>12.3.3 Internet Connections815</p><p>12.4 The Sockets Interface816</p><p>12.4.1 Socket Address Structures817</p><p>12.4.2 The socket Function818</p><p>12.4.3 The connect Function818</p><p>12.4.4 Theopen_clientfdFunction819</p><p>12.4.5 The bind Function819</p><p>12.4.6 The l i s ten Function820</p><p>12.4.7 Theopen_listenfdFunction821</p><p>12.4.8 The accept Function821</p><p>12.4.9 Example Echo Client and Server823</p><p>12.5 Web Servers826</p><p>12.5.1 Web Basics826</p><p>12.5.2 Web Content827</p><p>12.5.3 HTTP Transactions828</p><p>12.5.4 Serving Dynamic Content831</p><p>12.6 Putting it Together: The TINY Web Server834</p><p>12.7 Summary841</p><p>Bibliographic Notes842</p><p>Homework Problems842</p><p>Solutions to Practice Problems843</p><p>13 Concurrent Programming846</p><p>13.1 Concurrent Programming With Processes849</p><p>13.11 A Concurrent Server Based on Processes851</p><p>13.1.2 Pros and Cons of Processes851</p><p>13.2 Concurrent Programming With 1/O Multiplexing853</p><p>13.2.1 A Concurrent Event-Driven Server Based on I/O Multiplexing856</p><p>13.2.2 Pros and Cons of I/O Multiplexing860</p><p>13.3 Concurrent Programming With Threads861</p><p>13.3.1 Thread Execution Model862</p><p>13.3.2 Posix Threads863</p><p>13.3.3 Creating Threads864</p><p>13.3.4 Terminating Threads864</p><p>13.3.5 Reaping Terminated Threads865</p><p>13.3.6 Detaching Threads865</p><p>13.3.7 Initializing Threads866</p><p>13.3.8 A Concurrent Server Based on Threads866</p><p>13.4 Shared Variables in Threaded Programs868</p><p>13.4.1 Threads Memory Model869</p><p>13.4.2 Mapping Variables to Memory870</p><p>13.4.3 Shared Variables870</p><p>13.5 Synchronizing Threads with Semaphores871</p><p>13.5.1 Progress Graphs874</p><p>13.5.2 Using Semaphores to Access Shared Variables877</p><p>13.5.3 Posix Semaphores878</p><p>13.5.4 Using Semaphores to Schedule Shared Resources879</p><p>13.6 Putting It Together: A Concurrent Server Based on Prethreading882</p><p>13.7 Other Concurrency Issues885</p><p>13.7.1 Thread Safety885</p><p>13.7.2 Reentrancy888</p><p>13.7.3 Using Existing Library Functions in Threaded Programs889</p><p>13.7.4 Races890</p><p>13.7.5 Deadlocks891</p><p>13.8 Summary894</p><p>Bibliographic Notes895</p><p>Homework Problems895</p><p>Solutions to Practice Problems899</p><p>A HCL Descriptions of Processor Control Logic905</p><p>B Error Handling925</p><p>Bibliography949</p><p>Index953</p><p></p></div></div><div class="d-rt"><h3>热门推荐</h3><ul><li><a href="/book/3121341.html">3121341.html</a></li><li><a href="/book/394082.html">394082.html</a></li><li><a href="/book/802311.html">802311.html</a></li><li><a href="/book/2278389.html">2278389.html</a></li><li><a href="/book/3545921.html">3545921.html</a></li><li><a href="/book/1385553.html">1385553.html</a></li><li><a href="/book/3455519.html">3455519.html</a></li><li><a href="/book/3413471.html">3413471.html</a></li><li><a href="/book/1650166.html">1650166.html</a></li><li><a href="/book/1540122.html">1540122.html</a></li></ul></div></div><div id="footer"><p>Copyright&nbsp;&copy;&nbsp;2025&nbsp;&nbsp;<a href="/list/">最新更新</a></p><p>请使用FDM BitComet qBittorrent uTorrent等BT下载工具，下载本站电子书资源！首推Free Download Manager下载软件。文件页数>标注页数[分册图书除外]</p></div></body></html>