<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><script type="text/javascript" src="https://file.bkxsj.com/skin/book/js/sk.js"></script><meta name="robots" content="index,follow"><title>汇编语言 基于Linux环境 3版[PDF|Epub|txt|kindle电子书版本网盘下载]-灵感之桥</title><meta name="Keywords" content="汇编语言 基于Linux环境 3版"/><meta name="description" content="汇编语言 基于Linux环境 3版pdf下载文件大小为79MB,PDF页数为588页"/><meta http-equiv="X-UA-Compatible" content="IE=9; IE=8; IE=7; IE=EDGE;chrome=1"><link type="image/x-icon" rel="shortcut icon" href="https://www.shukui.net/skin/book/images/favicon.ico"><link type="text/css" rel="stylesheet" href="https://www.shukui.net/skin/book/css/style.css"><style>#main .d-main {margin-left: 0;width: 620px;}.down-btn {animation: myShake 2.5s linear .15s infinite}@keyframes myShake {0%, 66% {transform: translateZ(0)}67%, 73.6%, 83.6%, 93.6%, to {animation-timing-function: cubic-bezier(.215, .61, .355, 1);transform: translateZ(0)}80.3%, 81.4% {animation-timing-function: cubic-bezier(.755, .05, .855, .06);transform: translate3d(0, -4px, 0)}90.3% {animation-timing-function: cubic-bezier(.755, .05, .855, .06);transform: translate3d(0, -2px, 0)}97% {transform: translate3d(0, -.5px, 0)}}.copylink-btn {margin-right: 20px;}.copymd5-btn {margin-bottom: 25px;margin-left: 10px;}</style></head><body><div id="header"><div class="inner"><div class="logo"><a href="/"><img width="103" height="25" alt="灵感之桥"src="https://www.shukui.net/skin/book/images/logo.png"></a></div><div class="search"><form action="/so/search.php" target="_blank"><input type="text" autocomplete="off" id="bdcsMain" name="q" placeholder="书名 / 作者 / 出版社 / ISBN"class="inp-txt"><select class="inp-select" id="datasource" onchange="selectDatasource(this)"><option value="so">主库</option><option value="s">从库</option></select><input type="submit" value="搜索" class="inp-btn"></form></div></div></div><div id="main"><div class="d-main"><div class="tit"><h3>图书介绍</h3></div><h1 class="book-name">汇编语言 基于Linux环境 3版PDF|Epub|txt|kindle电子书版本网盘下载</h1><div class="d-info"><div class="b-thumb"><img src="https://www.shukui.net/cover/15/35025097.jpg" alt="汇编语言 基于Linux环境 3版"></div><div class="b-info"><ul><li>（美）达特曼著 著</li><li>出版社： 北京：清华大学出版社</li><li>ISBN：9787302345923</li><li>出版时间：2014</li><li>标注页数：567页</li><li>文件大小：79MB</li><li>文件页数：588页</li><li>主题词：汇编语言－程序设计；Linux操作系统</li></ul></div></div><div class="tit"><h3>PDF下载</h3></div><div></br><a style="color:red;" rel="external nofollow" href="https://www.kjlm.net/ebook/3826246.html"target="_blank"><b>点此进入-本书在线PDF格式电子书下载【推荐-云解压-方便快捷】直接下载PDF格式图书。移动端-PC端通用</a></b></br><a class="down-btn" rel="external nofollow" href="https://down.trackerbk.com/bt/10/35025097.torrent"target="_blank">种子下载</a>[BT下载速度快]温馨提示：（请使用BT下载软件FDM进行下载）<a rel="nofollow" href="https://www.freedownloadmanager.org/zh/" target="_blank">软件下载地址页</a><a class="down-btn" rel="external nofollow" href="https://down.p2spdb.com/10/35025097.rar" target="_blank">直链下载</a>[便捷但速度慢]&nbsp;&nbsp;<a style="color:red;" rel="external nofollow" href="https://pdfyl.ertongbook.com/88/35025097.pdf" target="_blank"><b>[在线试读本书]</b></a>&nbsp;&nbsp;<b> <a style="color:red;" rel="external nofollow" href="https://web.jyjl.org/index/recovery.html" target="_blank">[在线获取解压码]</a></b><div class="copymd5-btn"><a href="javascript:copyToClip('500ced3bcfc42e083e0cf326bed4d800')">点击复制MD5值：500ced3bcfc42e083e0cf326bed4d800</a></div></div><div class="tit"><h3>下载说明</h3></div><div style="margin:20px 10px"><h2>汇编语言 基于Linux环境 3版PDF格式电子书版下载</h2>下载的文件为RAR压缩包。需要使用解压软件进行解压得到PDF格式图书。<br><br><div class="copymd5-btn"><a href="javascript:copyToClip('magnet:?xt=urn:btih:RX6G6JQ2LJW7PBBEDNUSCQM7ICDMHIWK')">点击复制85GB完整离线版磁力链接到迅雷FDM等BT下载工具进行下载</a>&nbsp;&nbsp;<a rel="nofollow" target="_blank">详情点击-查看共享计划</a></div>建议使用BT下载工具Free Download Manager进行下载,简称FDM(免费,没有广告,支持多平台）。本站资源全部打包为BT种子。所以需要使用专业的BT下载软件进行下载。如BitComet qBittorrent uTorrent等BT下载工具。迅雷目前由于本站不是热门资源。不推荐使用！后期资源热门了。安装了迅雷也可以迅雷进行下载！<br><br><b>（文件页数 要大于 标注页数，上中下等多册电子书除外）</b><br><br><p style="color:red;"> <b>注意：本站所有压缩包均有解压码：</b> <a rel="nofollow" target="_blank"><b>点击下载压缩包解压工具</b></a></p></div><div class="tit"><h3>图书目录</h3></div><div id="book-contents"><p>第1章 又一个令人愉快的星期六1</p><p>1.1一切尽在计划之中1</p><p>1.1.1步骤和测试2</p><p>1.1.2不止两种方式3</p><p>1.1.3计算机像我们一样思考4</p><p>1.2如果这是真实情况4</p><p>1.3此路不通，请绕行5</p><p>1.3.1 Big Bux游戏6</p><p>1.3.2玩Big Bux游戏8</p><p>1.4像棋盘游戏一样的汇编语言编程9</p><p>1.4.1代码和数据10</p><p>1.4.2地址11</p><p>1.4.3隐喻，将军12</p><p>第2章 外星基数14</p><p>2.1新数学怪物归来14</p><p>2.2在火星上计数15</p><p>2.2.1火星数字剖析17</p><p>2.2.2数字基数的本质19</p><p>2.3八进制：绿色精怪怎样偷走8和9的19</p><p>2.4十六进制：解决数字的短缺23</p><p>2.5从十六进制到十进制，从十进制到十六进制27</p><p>2.5.1从十六进制到十进制27</p><p>2.5.2从十进制到十六进制28</p><p>2.5.3练习！练习！再练习30</p><p>2.6十六进制运算31</p><p>2.6.1列和进位34</p><p>2.6.2减法和借位34</p><p>2.6.3跨多列借位36</p><p>2.6.4意义何在37</p><p>2.7二进制37</p><p>2.7.1二进制值39</p><p>2.7.2为什么使用二进制41</p><p>2.8二进制简写方式：十六进制42</p><p>第3章 摘下面具44</p><p>3.1 RAXie，我们怎么不认识你44</p><p>3.2开关、晶体管和存储器46</p><p>3.2.1如果走陆路，就是147</p><p>3.2.2晶体管开关47</p><p>3.2.3难以置信的位缩水49</p><p>3.2.4随机访问51</p><p>3.2.5存储器访问时间52</p><p>3.2.6字节，字，双字，四字53</p><p>3.2.7精致的芯片排成一行54</p><p>3.2.8车间工长和流水线57</p><p>3.2.9对话内存57</p><p>3.2.10驾驭数据总线58</p><p>3.2.11车间工长的口袋59</p><p>3.2.12流水线60</p><p>3.3遵循计划行事的盒子60</p><p>3.3.1取指和执行61</p><p>3.3.2车间工长的内脏62</p><p>3.3.3改变航向64</p><p>3.4是什么vs.怎么做：体系结构和微体系结构65</p><p>3.4.1体系结构的演变66</p><p>3.4.2地下室里的秘密机制67</p><p>3.5工厂经理68</p><p>3.5.1操作系统：角落办公室69</p><p>3.5.2 BIOS：是软件，但并不软69</p><p>3.5.3多任务魔术70</p><p>3.5.4内核提升71</p><p>3.5.5内核爆炸73</p><p>3.5.6计划73</p><p>第4章 位置，位置，位置74</p><p>4.1内存模式的乐趣74</p><p>4.1.1 16位将带来64K存储空间75</p><p>4.1.2兆字节的本质79</p><p>4.1.3向后兼容和虚拟86模式80</p><p>4.1.4 16位眼罩80</p><p>4.2段的本质81</p><p>4.2.1一个界限，而非一个位置84</p><p>4.2.2用两个16位寄存器构成20位地址84</p><p>4.3 16位和32位寄存器87</p><p>4.3.1通用寄存器88</p><p>4.3.2半寄存器90</p><p>4.3.3指令指针寄存器91</p><p>4.3.4标志寄存器92</p><p>4.4三种主要的汇编编程模型93</p><p>4.4.1实模式平面模型93</p><p>4.4.2实模式段模型95</p><p>4.4.3保护模式平面模型97</p><p>4.5保护模式下不再允许我们做的事情100</p><p>4.5.1内存映射视频系统100</p><p>4.5.2直接访问端口硬件101</p><p>4.5.3直接调用BIOS102</p><p>4.6展望未来：64位“长模式”102</p><p>第5章 汇编的权利105</p><p>5.1文件及其包含的内容106</p><p>5.1.1二进制文件vs.文本文件106</p><p>5.1.2用Bless编辑器查看文件内容108</p><p>5.1.3解释原始数据112</p><p>5.1.4“字节序”113</p><p>5.2文本进去，代码出来116</p><p>5.2.1汇编语言117</p><p>5.2.2注释119</p><p>5.2.3当心“只写”源代码120</p><p>5.2.4目标代码和连接器120</p><p>5.2.5重定位能力123</p><p>5.3汇编语言开发过程124</p><p>5.3.1工作目录规范125</p><p>5.3.2编辑源代码文件126</p><p>5.3.3编译源代码文件126</p><p>5.3.4汇编错误127</p><p>5.3.5回到编辑器129</p><p>5.3.6汇编警告129</p><p>5.3.7连接目标代码文件130</p><p>5.3.8连接错误131</p><p>5.3.9测试.EXE文件131</p><p>5.3.10错误vs.漏洞132</p><p>5.3.11我们还在那里吗133</p><p>5.3.12调试器和调试133</p><p>5.4沿着汇编小路旅行134</p><p>5.4.1安装软件135</p><p>5.4.2第1步：在编辑器中编辑程序137</p><p>5.4.3第2步：使用NASM编译程序138</p><p>5.4.4第3步：使用LD连接器140</p><p>5.4.5第4步：测试可执行文件141</p><p>5.4.6第5步：在调试器中观察程序运行142</p><p>5.4.7准备好要来真格的了吗148</p><p>第6章 有地儿，有工具149</p><p>6.1 Kate编辑器151</p><p>6.1.1安装Kate编辑器151</p><p>6.1.2启动Kate152</p><p>6.1.3配置154</p><p>6.1.4 Kate会话156</p><p>6.1.5 Kate编辑器的文件管理158</p><p>6.1.6向工具栏添加菜单项161</p><p>6.1.7 Kate编辑器的编辑控制162</p><p>6.1.8编程期间使用Kate编辑器166</p><p>6.2 Linux和终端169</p><p>6.2.1 Linux控制台169</p><p>6.2.2 Konsole中的字符编码170</p><p>6.2.3三个标准Unix文件172</p><p>6.2.4 I/O重定向173</p><p>6.2.5简易文本过滤器175</p><p>6.2.6使用转义序列进行终端控制177</p><p>6.2.7为什么不用汇编语言编写GUI应用程序呢178</p><p>6.3使用Linux Make179</p><p>6.3.1依赖条件180</p><p>6.3.2文件何时最新182</p><p>6.3.3依赖链182</p><p>6.3.4从Kate编辑器内部调用Make实用工具184</p><p>6.3.5使用touch命令强制执行生成操作187</p><p>6.4 Insight调试器187</p><p>6.4.1运行Insight188</p><p>6.4.2 Insight的众多窗口189</p><p>6.4.3快速体验Insight190</p><p>6.4.4拿起你的工具193</p><p>第7章 跟踪指令194</p><p>7.1为自己建立一个沙盒194</p><p>7.1.1一个最小的NASM程序195</p><p>7.1.2指令及其操作数197</p><p>7.1.3源操作数和目标操作数197</p><p>7.1.4立即数198</p><p>7.1.5寄存器数据200</p><p>7.1.6内存数据202</p><p>7.1.7混淆数据和它的地址203</p><p>7.1.8内存数据的尺寸204</p><p>7.1.9糟糕的过去204</p><p>7.2 CPU的标志位205</p><p>7.2.1标志规范208</p><p>7.2.2使用INC指令和DEC指令加1和减1208</p><p>7.2.3从Insight中观察标志209</p><p>7.2.4标志如何改变程序的执行211</p><p>7.3有符号值和无符号值214</p><p>7.3.1补码和NEG214</p><p>7.3.2符号扩展和MOVSX217</p><p>7.4隐式操作数和Mul219</p><p>7.4.1 MUL和进位标志221</p><p>7.4.2使用DIV实现无符号除法221</p><p>7.4.3 x86中的“慢动作”指令223</p><p>7.5阅读和使用汇编语言参考资料223</p><p>7.5.1对于复杂记忆的唤醒文件224</p><p>7.5.2初学者汇编语言参考指南224</p><p>7.5.3标志225</p><p>7.6 NEG：求补（求补码；即，与-1相乘）225</p><p>7.6.1合法形式227</p><p>7.6.2操作数符号227</p><p>7.6.3示例228</p><p>7.6.4注解228</p><p>7.6.5这里没有包含的内容229</p><p>第8章 我们的崇高目标230</p><p>8.1汇编语言程序的基本框架230</p><p>8.1.1最开始处的注释块232</p><p>8.1.2 .data段233</p><p>8.1.3 .bss段233</p><p>8.1.4 .text段234</p><p>8.1.5标号234</p><p>8.1.6己初始化变量235</p><p>8.1.7字符串变量235</p><p>8.1.8通过EQU和＄推导字符串的长度237</p><p>8.2通过堆栈实现后进先出239</p><p>8.2.1每小时500个盘子239</p><p>8.2.2堆栈的内容上下颠倒241</p><p>8.2.3 Push-y指令242</p><p>8.2.4 POP指令244</p><p>8.2.5临时存储246</p><p>8.3通过INT80使用Linux内核服务247</p><p>8.3.1不中断任何事情的中断247</p><p>8.3.2再次返回252</p><p>8.3.3通过使用INT 80h退出一个程序253</p><p>8.3.4软件中断VS硬件中断254</p><p>8.3.5 INT 80h和可移植性盲目崇拜255</p><p>8.4设计一个有价值的程序256</p><p>8.4.1问题定义257</p><p>8.4.2从伪代码开始258</p><p>8.4.3连续改进259</p><p>8.4.4不可避免的“哎呀！时刻”263</p><p>8.4.5扫描缓冲区264</p><p>8.4.6缓冲溢出（“Off By One”）错误266</p><p>8.4.7进一步学习271</p><p>第9章 位、标志、分支和表272</p><p>9.1位就是二进制位（字节也是二进制位）272</p><p>9.1.1位编号273</p><p>9.1.2逻辑操作273</p><p>9.1.3与指令274</p><p>9.1.4位屏蔽275</p><p>9.1.5或指令276</p><p>9.1.6异或指令276</p><p>9.1.7非指令278</p><p>9.1.8段寄存器对逻辑操作没有反应278</p><p>9.2移位操作279</p><p>9.2.1根据什么进行移位操作279</p><p>9.2.2移位指令的工作原理279</p><p>9.2.3将位移入进位标志280</p><p>9.2.4循环移位指令280</p><p>9.2.5将己知值存入进位标志CF282</p><p>9.3位操作282</p><p>9.3.1将一个字节分解为两个“半字节”285</p><p>9.3.2将高半字节移入低半字节286</p><p>9.3.3使用查找表286</p><p>9.3.4通过移位和相加来实现相乘288</p><p>9.4标志、测试和分支291</p><p>9.4.1无条件转移292</p><p>9.4.2条件转移指令292</p><p>9.4.3条件“缺席”时进行跳转293</p><p>9.4.4标志294</p><p>9.4.5通过CMP进行比较操作295</p><p>9.4.6转移指令的错综复杂之处296</p><p>9.4.7“大于”与“以上”296</p><p>9.4.8使用TEST指令查找位1298</p><p>9.4.9使用BT指令查找位0300</p><p>9.5保护模式下内存寻址详解301</p><p>9.5.1有效地址计算303</p><p>9.5.2位移量303</p><p>9.5.3基址+位移量寻址方式304</p><p>9.5.4基址+索引寻址方式304</p><p>9.5.5索引×缩放比例+位移量寻址方式305</p><p>9.5.6其他寻址方式307</p><p>9.5.7 LEA：最机密的数学机器309</p><p>9.5.8 16位寄存器的负担311</p><p>9.6字符表转换312</p><p>9.6.1转换表312</p><p>9.6.2用MOV或者XLAT进行转换315</p><p>9.7用表来代替计算319</p><p>第10章 分治321</p><p>10.1盒子里面的盒子322</p><p>10.2调用和返回331</p><p>10.2.1调用中的调用334</p><p>10.2.2意外递归的危险335</p><p>10.2.3一个需要提防的标志规范Bug336</p><p>10.2.4过程及其所需的数据337</p><p>10.2.5保存主调程序的寄存器338</p><p>10.2.6局部数据341</p><p>10.2.7更多的表格技巧342</p><p>10.2.8在过程定义中加入常量数据344</p><p>10.3局部标号和跳转的长度345</p><p>10.3.1“强行”访问局部标号348</p><p>10.3.2短转移、近转移和远转移349</p><p>10.4生成外部过程库350</p><p>10.4.1全局声明和外部声明351</p><p>10.4.2全局过程和外部过程的机制353</p><p>10.4.3连接库文件到程序中361</p><p>10.4.4太多过程和太多库的危险362</p><p>10.5自定义过程的艺术362</p><p>10.5.1可维护性和可重用性363</p><p>10.5.2确定哪些代码应该成为一个过程364</p><p>10.5.3使用注释标头365</p><p>10.6 Linux控制台下的简单光标控制366</p><p>10.7创建和使用宏374</p><p>10.7.1宏定义机制375</p><p>10.7.2定义带参数的宏380</p><p>10.7.3宏调用机制382</p><p>10.7.4宏内部的局部标号383</p><p>10.7.5像包含文件一样的宏库文件384</p><p>10.7.6宏vs.过程：优点和缺点385</p><p>第11章 字符串奏鸣曲387</p><p>11.1汇编语言字符串的概念387</p><p>11.1.1彻底颠覆你的“字符串感觉”388</p><p>11.1.2源字符串和目标字符串388</p><p>11.1.3虚拟文本显示屏389</p><p>11.2 REP STOSB，软件机枪397</p><p>11.2.1机枪扫射虚拟显示器397</p><p>11.2.2执行STOSB指令398</p><p>11.2.3 STOSB和方向标志（DF）399</p><p>11.2.4在显示缓冲区中定义行400</p><p>11.2.5将缓冲区发送到Linux控制台401</p><p>11.3半自动武器：不带REP的STOSB401</p><p>11.3.1是谁递减了ECX402</p><p>11.3.2 LOOP指令402</p><p>11.3.3在屏幕上显示一个标尺403</p><p>11.3.4 MUL并非IMUL404</p><p>11.3.5添加ASCII数字406</p><p>11.3.6调整AAA408</p><p>11.3.7 Ruler过程的教训409</p><p>11.3.8 STOS指令的16位版本和32位版本409</p><p>11.4 MOVSB：快速块拷贝409</p><p>11.4.1 DF和重叠块移动411</p><p>11.4.2使用Insight单步调试REP字符串指令413</p><p>11.5将数据存储到不连续的字符串中414</p><p>11.5.1显示一个ASCII表414</p><p>11.5.2嵌套指令循环416</p><p>11.5.3当ECX变为0时进行跳转416</p><p>11.5.4关闭内层循环417</p><p>11.5.5关闭外层循环418</p><p>11.5.6 Showchar小结419</p><p>11.6命令行参数和堆栈检查419</p><p>11.6.1两块虚拟内存420</p><p>11.6.2 Linux堆栈剖析422</p><p>11.6.3为什么堆栈的地址是不可预测的424</p><p>11.6.4使用Insight设置命令行参数424</p><p>11.6.5通过Insight的内存视图查看堆栈425</p><p>11.7使用SCASB进行字符串搜索427</p><p>11.7.1 REPNE v.s.REPE431</p><p>11.7.2从堆栈中弹出，还是对堆栈寻址432</p><p>11.7.3额外的学分434</p><p>第12章 C语言435</p><p>12.1什么是GNU436</p><p>12.1.1“瑞士军刀”编译器437</p><p>12.1.2以GNU的方式生成代码437</p><p>12.1.3如何在汇编工作中使用gcc439</p><p>12.1.4为什么不用gas440</p><p>12.2连接到标准的C函数库441</p><p>12.2.1 C调用公约442</p><p>12.2.2建立一个框架443</p><p>12.2.3保存和恢复寄存器443</p><p>12.2.4建立堆栈帧444</p><p>12.2.5销毁堆栈帧446</p><p>12.2.6通过puts（）输出字符447</p><p>12.3使用printf（）格式化文本输出448</p><p>12.4使用fgets（）和scanf（）进行数据输入452</p><p>12.5驾驭时间459</p><p>12.5.1 C库的时间机制459</p><p>12.5.2从系统时钟中取出time t值461</p><p>12.5.3将time t值转换为一个格式化字符串461</p><p>12.5.4生成单独的本地时间值462</p><p>12.5.5通过使用MOVSD复制glibc的tm结构463</p><p>12.6理解AT＆T指令助记符467</p><p>12.6.1 AT＆T助记符公约467</p><p>12.6.2查看gcc创建的gas源文件468</p><p>12.6.3 AT＆T内存引用语法471</p><p>12.7产生随机数472</p><p>12.7.1利用srand（）为随机生成器“播种”473</p><p>12.7.2产生伪随机数474</p><p>12.7.3有些位比其他位更具随机性479</p><p>12.7.4调用寄存器中的地址481</p><p>12.8 C如何看待命令行参数482</p><p>12.9简单文件输入/输出484</p><p>12.9.1通过sscanf（）将字符串转换为数字485</p><p>12.9.2创建和打开文件486</p><p>12.9.3使用fgets（）从文件中读取文本488</p><p>12.9.4使用fprintf（）写文本到文件中490</p><p>12.9.5关于收集过程到库中的注解492</p><p>结论：不是结束，而是刚刚开始501</p><p>附录A 部分x86指令集505</p><p>附录B 字符集图565</p><p></p></div></div><div class="d-rt"><h3>热门推荐</h3><ul><li><a href="/book/2429821.html">2429821.html</a></li><li><a href="/book/1172477.html">1172477.html</a></li><li><a href="/book/1075143.html">1075143.html</a></li><li><a href="/book/1511130.html">1511130.html</a></li><li><a href="/book/33365.html">33365.html</a></li><li><a href="/book/3182667.html">3182667.html</a></li><li><a href="/book/612796.html">612796.html</a></li><li><a href="/book/2015403.html">2015403.html</a></li><li><a href="/book/2889630.html">2889630.html</a></li><li><a href="/book/2967112.html">2967112.html</a></li></ul></div></div><div id="footer"><p>Copyright&nbsp;&copy;&nbsp;2025&nbsp;&nbsp;<a href="/list/">最新更新</a></p><p>请使用FDM BitComet qBittorrent uTorrent等BT下载工具，下载本站电子书资源！首推Free Download Manager下载软件。文件页数>标注页数[分册图书除外]</p></div></body></html>